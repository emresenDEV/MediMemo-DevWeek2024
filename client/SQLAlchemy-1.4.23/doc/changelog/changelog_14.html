<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

        <title>
            
    
    1.4 Changelog
 &mdash;
    SQLAlchemy 1.4 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.4 Documentation" href="../index.html" />
        <link rel="up" title="Changes and Migration" href="index.html" />
        <link rel="next" title="1.3 Changelog" href="changelog_13.html" />
        <link rel="prev" title="Migrating to SQLAlchemy 2.0" href="migration_20.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.4.23</span>


        | Release Date: August 18, 2021

    </div>

    <h1><a href="../index.html">SQLAlchemy 1.4 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.4 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="Changes and Migration">Changes and Migration</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="migration_14.html">What’s New in SQLAlchemy 1.4?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_20.html">Migrating to SQLAlchemy 2.0</a></span></li>
<li class="selected"><span class="link-container"><strong>1.4 Changelog</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23">1.4.23</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23-general">general</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23-mssql">mssql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.23-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.22">1.4.22</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.22-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.22-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.22-sql">sql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.21">1.4.21</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.21-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.21-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.21-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.21-mssql">mssql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.20">1.4.20</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.20-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.20-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.20-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.20-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.20-mysql">mysql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.20-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.19">1.4.19</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.19-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.19-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.19-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.19-asyncio">asyncio</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.19-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.19-mysql">mysql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.19-mssql">mssql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.18">1.4.18</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.18-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.18-asyncio">asyncio</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.18-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.18-sqlite">sqlite</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.17">1.4.17</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.17-orm">orm</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.16">1.4.16</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.16-general">general</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.16-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.16-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.16-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.16-mssql">mssql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.16-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.15">1.4.15</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.15-general">general</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.15-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.15-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.15-mysql">mysql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.14">1.4.14</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.14-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.14-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.14-sql">sql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.13">1.4.13</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.13-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.13-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.13-asyncio">asyncio</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.13-postgresql">postgresql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.12">1.4.12</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.12-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.12-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.12-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.12-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.12-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.12-sqlite">sqlite</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.12-mssql">mssql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.11">1.4.11</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.11-orm-declarative">orm declarative</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.11-engine">engine</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.10">1.4.10</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.10-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.10-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.10-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.10-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.10-mssql">mssql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.10-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.9">1.4.9</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.9-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.9-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.9-postgresql">postgresql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.8">1.4.8</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.8-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.8-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.8-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.8-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.8-asyncio">asyncio</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.8-mssql">mssql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.7">1.4.7</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.7-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.7-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.7-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.7-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.7-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.7-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.6">1.4.6</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.6-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.6-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.6-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.6-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.6-asyncio">asyncio</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5">1.4.5</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-asyncio">asyncio</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-mysql">mysql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-mssql">mssql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.5-oracle">oracle</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.4">1.4.4</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.4-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.4-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.4-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.4-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.3">1.4.3</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.3-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.3-orm-declarative">orm declarative</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.3-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.3-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.3-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.3-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.3-sqlite">sqlite</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.2">1.4.2</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.2-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.2-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.2-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.2-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.2-postgresql">postgresql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.1">1.4.1</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.1-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.1-orm-declarative">orm declarative</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.1-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.1-mssql">mssql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.1-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0">1.4.0</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0-mypy">mypy</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0-mssql">mssql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b3">1.4.0b3</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b3-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b3-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b3-sql">sql</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2">1.4.0b2</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-general">general</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-platform">platform</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-orm-declarative">orm declarative</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-asyncio">asyncio</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-mysql">mysql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-sqlite">sqlite</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-mssql">mssql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-oracle">oracle</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b2-misc">misc</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1">1.4.0b1</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-general">general</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-platform">platform</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-orm">orm</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-engine">engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-sql">sql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-schema">schema</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-extensions">extensions</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-postgresql">postgresql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-mysql">mysql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-sqlite">sqlite</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-mssql">mssql</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-oracle">oracle</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-firebird">firebird</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-1.4.0b1-misc">misc</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="changelog_13.html">1.3 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_12.html">1.2 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_11.html">1.1 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_10.html">1.0 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_09.html">0.9 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_08.html">0.8 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_07.html">0.7 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_06.html">0.6 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_05.html">0.5 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_04.html">0.4 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_03.html">0.3 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_02.html">0.2 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_01.html">0.1 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_13.html">What’s New in SQLAlchemy 1.3?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_12.html">What’s New in SQLAlchemy 1.2?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_11.html">What’s New in SQLAlchemy 1.1?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_10.html">What’s New in SQLAlchemy 1.0?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_09.html">What’s New in SQLAlchemy 0.9?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_08.html">What’s New in SQLAlchemy 0.8?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_07.html">What’s New in SQLAlchemy 0.7?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_06.html">What’s New in SQLAlchemy 0.6?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html">What’s new in SQLAlchemy 0.5?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html">What’s new in SQLAlchemy 0.4?</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar changelog-changelog_14" >
        
<section id="changelog">
<h1>1.4 Changelog<a class="headerlink" href="#changelog" title="Permalink to this headline">¶</a></h1>
<p>This document details individual issue-level changes made throughout
1.4 releases.  For a narrative overview of what’s new in 1.4, see
<a class="reference internal" href="migration_14.html"><span class="std std-ref">What’s New in SQLAlchemy 1.4?</span></a>.</p>
<section id="change-1.4.23">
<h2 class="release-version">1.4.23<a class="headerlink" href="#change-1.4.23" title="Permalink to this headline">¶</a></h2>
Released: August 18, 2021<section id="change-1.4.23-general">
<h3>general<a class="headerlink" href="#change-1.4.23-general" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.23-0"><span class="target" id="change-882c399737fed96edbdcf27953a8f0ed"><strong>[general] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-882c399737fed96edbdcf27953a8f0ed">¶</a></span><p>The setup requirements have been modified such <code class="docutils literal notranslate"><span class="pre">greenlet</span></code> is a default
requirement only for those platforms that are well known for <code class="docutils literal notranslate"><span class="pre">greenlet</span></code>
to be installable and for which there is already a pre-built binary on
pypi; the current list is <code class="docutils literal notranslate"><span class="pre">x86_64</span> <span class="pre">aarch64</span> <span class="pre">ppc64le</span> <span class="pre">amd64</span> <span class="pre">win32</span></code>. For other
platforms, greenlet will not install by default, which should enable
installation and test suite running of SQLAlchemy 1.4 on platforms that
don’t support <code class="docutils literal notranslate"><span class="pre">greenlet</span></code>, excluding any asyncio features. In order to
install with the <code class="docutils literal notranslate"><span class="pre">greenlet</span></code> dependency included on a machine architecture
outside of the above list, the <code class="docutils literal notranslate"><span class="pre">[asyncio]</span></code> extra may be included by
running <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">sqlalchemy[asyncio]</span></code> which will then attempt to
install <code class="docutils literal notranslate"><span class="pre">greenlet</span></code>.</p>
<p>Additionally, the test suite has been repaired so that tests can complete
fully when greenlet is not installed, with appropriate skips for
asyncio-related tests.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6136">#6136</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.23-orm">
<h3>orm<a class="headerlink" href="#change-1.4.23-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.23-1"><span class="target" id="change-c8df92ab1d9ac8f9312384ccaac0682e"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c8df92ab1d9ac8f9312384ccaac0682e">¶</a></span><p>Added new attribute <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.columns_clause_froms" title="sqlalchemy.sql.expression.Select.columns_clause_froms"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Select.columns_clause_froms</span></code></a> that will
retrieve the FROM list implied by the columns clause of the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> statement. This differs from the old
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.froms" title="sqlalchemy.sql.expression.Select.froms"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Select.froms</span></code></a> collection in that it does not perform any ORM
compilation steps, which necessarily deannotate the FROM elements and do
things like compute joinedloads etc., which makes it not an appropriate
candidate for the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a> method. Additionally adds
a new parameter
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns.params.maintain_column_froms" title="sqlalchemy.sql.expression.Select.with_only_columns"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Select.with_only_columns.maintain_column_froms</span></code></a> that
transfers this collection to <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a> before
replacing the columns collection.</p>
<p>In addition, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.froms" title="sqlalchemy.sql.expression.Select.froms"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Select.froms</span></code></a> is renamed to
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.get_final_froms" title="sqlalchemy.sql.expression.Select.get_final_froms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.get_final_froms()</span></code></a>, to stress that this collection is not
a simple accessor and is instead calculated given the full state of the
object, which can be an expensive call when used in an ORM context.</p>
<p>Additionally fixes a regression involving the
<code class="xref py py-func docutils literal notranslate"><span class="pre">with_only_columns()</span></code> function to support applying criteria to
column elements that were replaced with either
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns" title="sqlalchemy.sql.expression.Select.with_only_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.with_only_columns()</span></code></a> or <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.with_entities" title="sqlalchemy.orm.Query.with_entities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_entities()</span></code></a> ,
which had broken as part of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6503">#6503</a> released in 1.4.19.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6808">#6808</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-2"><span class="target" id="change-18c4e80c7c3ea31b09fcf7aa99032c54"><strong>[orm] [bug] [sql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-18c4e80c7c3ea31b09fcf7aa99032c54">¶</a></span><p>Fixed issue where a bound parameter object that was “cloned” would cause a
name conflict in the compiler, if more than one clone of this parameter
were used at the same time in a single statement. This could occur in
particular with things like ORM single table inheritance queries that
indicated the same “discriminator” value multiple times in one query.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6824">#6824</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-3"><span class="target" id="change-71158ec0eb6cf99d23352436dc4f970f"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-71158ec0eb6cf99d23352436dc4f970f">¶</a></span><p>Fixed issue in loader strategies where the use of the
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.Load.options" title="sqlalchemy.orm.Load.options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Load.options()</span></code></a> method, particularly when nesting multiple calls,
would generate an overly long and more importantly non-deterministic cache
key, leading to very large cache keys which were also not allowing
efficient cache usage, both in terms of total memory used as well as number
of entries used in the cache itself.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6869">#6869</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-4"><span class="target" id="change-6a7d15bb2adb004486b7a408e5e57781"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6a7d15bb2adb004486b7a408e5e57781">¶</a></span><p>Revised the means by which the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.user_defined_options" title="sqlalchemy.orm.ORMExecuteState.user_defined_options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ORMExecuteState.user_defined_options</span></code></a> accessor receives
<code class="xref py py-class docutils literal notranslate"><span class="pre">UserDefinedOption</span></code> and related option objects from the
context, with particular emphasis on the “selectinload” on the loader
strategy where this previously was not working; other strategies did not
have this problem. The objects that are associated with the current query
being executed, and not that of a query being cached, are now propagated
unconditionally. This essentially separates them out from the “loader
strategy” options which are explicitly associated with the compiled state
of a query and need to be used in relation to the cached query.</p>
<p>The effect of this fix is that a user-defined option, such as those used
by the dogpile.caching example as well as for other recipes such as
defining a “shard id” for the horizontal sharing extension, will be
correctly propagated to eager and lazy loaders regardless of whether
a cached query was ultimately invoked.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6887">#6887</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-5"><span class="target" id="change-c91b48bf6f043a7fbaafbeb5ff509d32"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c91b48bf6f043a7fbaafbeb5ff509d32">¶</a></span><p>Fixed issue where the unit of work would internally use a 2.0-deprecated
SQL expression form, emitting a deprecation warning when SQLALCHEMY_WARN_20
were enabled.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6812">#6812</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-6"><span class="target" id="change-97ac7c9d53608714ae4019ee64894906"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-97ac7c9d53608714ae4019ee64894906">¶</a></span><p>Fixed issue in <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> where use of the new
<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.PropComparator.and_" title="sqlalchemy.orm.PropComparator.and_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropComparator.and_()</span></code></a> feature within options that were nested
more than one level deep would fail to update bound parameter values that
were in the nested criteria, as a side effect of SQL statement caching.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6881">#6881</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-7"><span class="target" id="change-60731da1dc67385e8eca941c213c2f17"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-60731da1dc67385e8eca941c213c2f17">¶</a></span><p>Adjusted ORM loader internals to no longer use the “lambda caching” system
that was added in 1.4, as well as repaired one location that was still
using the previous “baked query” system for a query. The lambda caching
system remains an effective way to reduce the overhead of building up
queries that have relatively fixed usage patterns. In the case of loader
strategies, the queries used are responsible for moving through lots of
arbitrary options and criteria, which is both generated and sometimes
consumed by end-user code, that make the lambda cache concept not any more
efficient than not using it, at the cost of more complexity. In particular
the problems noted by <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6881">#6881</a> and <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6887">#6887</a> are made are made
considerably less complicated by removing this feature internally.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6079">#6079</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6889">#6889</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-8"><span class="target" id="change-6d18d1c5a62f6c6b03bec0e83bcedeb8"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6d18d1c5a62f6c6b03bec0e83bcedeb8">¶</a></span><p>Fixed an issue where the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Bundle" title="sqlalchemy.orm.Bundle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bundle</span></code></a> construct would not create
proper cache keys, leading to inefficient use of the query cache.  This
had some impact on the “selectinload” strategy and was identified as
part of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6889">#6889</a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6889">#6889</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.23-sql">
<h3>sql<a class="headerlink" href="#change-1.4.23-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.23-9"><span class="target" id="change-605cf62b042a3eb522e9d196fb19f0bb"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-605cf62b042a3eb522e9d196fb19f0bb">¶</a></span><p>Fix issue in <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> where new <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.HasCTE.add_cte" title="sqlalchemy.sql.expression.HasCTE.add_cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HasCTE.add_cte()</span></code></a> method
added in version 1.4.21 / <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6752">#6752</a> failed to function correctly for
“compound select” structures such as <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union" title="sqlalchemy.sql.expression.union"><code class="xref py py-func docutils literal notranslate"><span class="pre">union()</span></code></a>,
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union_all" title="sqlalchemy.sql.expression.union_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">union_all()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">except()</span></code>, etc. Pull request courtesy
Eric Masseran.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6752">#6752</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-10"><span class="target" id="change-61ae0cdeaf93a6d7a012a73628f3eb47"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-61ae0cdeaf93a6d7a012a73628f3eb47">¶</a></span><p>Fixed an issue in the <code class="docutils literal notranslate"><span class="pre">CacheKey.to_offline_string()</span></code> method used by the
dogpile.caching example where attempting to create a proper cache key from
the special “lambda” query generated by the lazy loader would fail to
include the parameter values, leading to an incorrect cache key.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6858">#6858</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-11"><span class="target" id="change-98a61e38d5622002d93ec43d28ff86fa"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-98a61e38d5622002d93ec43d28ff86fa">¶</a></span><p>Adjusted the “from linter” warning feature to accommodate for a chain of
joins more than one level deep where the ON clauses don’t explicitly match
up the targets, such as an expression such as “ON TRUE”. This mode of use
is intended to cancel the cartesian product warning simply by the fact that
there’s a JOIN from “a to b”, which was not working for the case where the
chain of joins had more than one element.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6886">#6886</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.23-12"><span class="target" id="change-8053c62e672ef90d2fa9d8db343956eb"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8053c62e672ef90d2fa9d8db343956eb">¶</a></span><p>Fixed issue in lambda caching system where an element of a query that
produces no cache key, like a custom option or clause element, would still
populate the expression in the “lambda cache” inappropriately.</p>
<p></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.23-schema">
<h3>schema<a class="headerlink" href="#change-1.4.23-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.23-13"><span class="target" id="change-eb0f84cab79a1756e6d7733665342af2"><strong>[schema] [enum]</strong> <a class="changelog-reference headerlink reference internal" href="#change-eb0f84cab79a1756e6d7733665342af2">¶</a></span><p>Unify behaviour <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code> in native and non-native
implementations regarding the accepted values for an enum with
aliased elements.
When <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.omit_aliases</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> all values,
alias included, are accepted as valid values.
When <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.omit_aliases</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> only non aliased values
are accepted as valid values.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6146">#6146</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.23-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.23-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.23-14"><span class="target" id="change-ef8a93d027430e455ae94639a33df50f"><strong>[mypy] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ef8a93d027430e455ae94639a33df50f">¶</a></span><p>Added support for SQLAlchemy classes to be defined in user code using
“generic class” syntax as defined by <code class="docutils literal notranslate"><span class="pre">sqlalchemy2-stubs</span></code>, e.g.
<code class="docutils literal notranslate"><span class="pre">Column[String]</span></code>, without the need for qualifying these constructs within
a <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> block by implementing the Python special method
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>, which allows this syntax to pass without error at
runtime.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6759">#6759</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6804">#6804</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.23-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.23-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.23-15"><span class="target" id="change-5546e0d0b007cef2296eef08b3c5fdc9"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5546e0d0b007cef2296eef08b3c5fdc9">¶</a></span><p>Added the “is_comparison” flag to the PostgreSQL “overlaps”,
“contained_by”, “contains” operators, so that they work in relevant ORM
contexts as well as in conjunction with the “from linter” feature.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6886">#6886</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.23-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.23-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.23-16"><span class="target" id="change-6f28926fa2299806ae55a1242d67444c"><strong>[mssql] [bug] [sql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6f28926fa2299806ae55a1242d67444c">¶</a></span><p>Fixed issue where the <code class="docutils literal notranslate"><span class="pre">literal_binds</span></code> compiler flag, as used externally
to render bound parameters inline, would fail to work when used with a
certain class of parameters known as “literal_execute”, which covers things
like LIMIT and OFFSET values for dialects where the drivers don’t allow a
bound parameter, such as SQL Server’s “TOP” clause.  The issue locally
seemed to affect only the MSSQL dialect.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6863">#6863</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.23-misc">
<h3>misc<a class="headerlink" href="#change-1.4.23-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.23-17"><span class="target" id="change-d1c2c34732951acdceb4048ed32c027c"><strong>[bug] [ext]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d1c2c34732951acdceb4048ed32c027c">¶</a></span><p>Fixed issue where the horizontal sharding extension would not correctly
accommodate for a plain textual SQL statement passed to
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6816">#6816</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.22">
<h2 class="release-version">1.4.22<a class="headerlink" href="#change-1.4.22" title="Permalink to this headline">¶</a></h2>
Released: July 21, 2021<section id="change-1.4.22-orm">
<h3>orm<a class="headerlink" href="#change-1.4.22-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.22-0"><span class="target" id="change-7722526edba7cff56e98e0b8b16dea4b"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7722526edba7cff56e98e0b8b16dea4b">¶</a></span><p>Fixed issue in new <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.table_valued" title="sqlalchemy.schema.Table.table_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.table_valued()</span></code></a> method where the
resulting <code class="xref py py-class docutils literal notranslate"><span class="pre">TableValuedColumn</span></code> construct would not respond
correctly to alias adaptation as is used throughout the ORM, such as for
eager loading, polymorphic loading, etc.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6775">#6775</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.22-1"><span class="target" id="change-e98af512e775c3904d2652ad9b2ae60b"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e98af512e775c3904d2652ad9b2ae60b">¶</a></span><p>Fixed issue where usage of the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.unique" title="sqlalchemy.engine.Result.unique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.unique()</span></code></a> method with an
ORM result that included column expressions with unhashable types, such as
<code class="docutils literal notranslate"><span class="pre">JSON</span></code> or <code class="docutils literal notranslate"><span class="pre">ARRAY</span></code> using non-tuples would silently fall back to using
the <code class="docutils literal notranslate"><span class="pre">id()</span></code> function, rather than raising an error. This now raises an
error when the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.unique" title="sqlalchemy.engine.Result.unique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.unique()</span></code></a> method is used in a 2.0 style
ORM query. Additionally, hashability is assumed to be True for result
values of unknown type, such as often happens when using SQL functions of
unknown return type; if values are truly not hashable then the <code class="docutils literal notranslate"><span class="pre">hash()</span></code>
itself will raise.</p>
<p>For legacy ORM queries, since the legacy <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object
uniquifies in all cases, the old rules remain in place, which is to use
<code class="docutils literal notranslate"><span class="pre">id()</span></code> for result values of unknown type as this legacy uniquing is
mostly for the purpose of uniquing ORM entities and not column values.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6769">#6769</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.22-2"><span class="target" id="change-87a1fa3652b0775512021ee47b99b261"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-87a1fa3652b0775512021ee47b99b261">¶</a></span><p>Fixed an issue where clearing of mappers during things like test suite
teardowns could cause a “dictionary changed size” warning during garbage
collection, due to iteration of a weak-referencing dictionary. A <code class="docutils literal notranslate"><span class="pre">list()</span></code>
has been applied to prevent concurrent GC from affecting this operation.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6771">#6771</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.22-3"><span class="target" id="change-12a0e1fecff6193c38b0e6942660242a"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-12a0e1fecff6193c38b0e6942660242a">¶</a></span><p>Fixed critical caching issue where the ORM’s persistence feature using
INSERT..RETURNING would cache an incorrect query when mixing the “bulk
save” and standard “flush” forms of INSERT.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6793">#6793</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.22-engine">
<h3>engine<a class="headerlink" href="#change-1.4.22-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.22-4"><span class="target" id="change-4e00174625fb03cc1d9902b61e589172"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4e00174625fb03cc1d9902b61e589172">¶</a></span><p>Added some guards against <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> in the event system to accommodate
the case that the interpreter is shutting down at the same time
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.dispose" title="sqlalchemy.engine.Engine.dispose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.dispose()</span></code></a> is being called, which would cause stack
trace warnings.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6740">#6740</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.22-sql">
<h3>sql<a class="headerlink" href="#change-1.4.22-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.22-5"><span class="target" id="change-60b374492a55cd6eb259f3a4a04a9359"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-60b374492a55cd6eb259f3a4a04a9359">¶</a></span><p>Fixed issue where use of the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.case.params.whens" title="sqlalchemy.sql.expression.case"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">case.whens</span></code></a> parameter passing
a dictionary positionally and not as a keyword argument would emit a 2.0
deprecation warning, referring to the deprecation of passing a list
positionally. The dictionary format of “whens”, passed positionally, is
still supported and was accidentally marked as deprecated.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6786">#6786</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.22-6"><span class="target" id="change-fcb25f2eca6e7695d6209a8c1fb62dba"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-fcb25f2eca6e7695d6209a8c1fb62dba">¶</a></span><p>Fixed issue where type-specific bound parameter handlers would not be
called upon in the case of using the <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert.values" title="sqlalchemy.sql.expression.Insert.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.values()</span></code></a> method with
the Python <code class="docutils literal notranslate"><span class="pre">None</span></code> value; in particular, this would be noticed when using
the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> datatype as well as related PostgreSQL specific
types such as <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB" title="sqlalchemy.dialects.postgresql.JSONB"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONB</span></code></a> which would fail to encode the
Python <code class="docutils literal notranslate"><span class="pre">None</span></code> value into JSON null, however the issue was generalized to
any bound parameter handler in conjunction with this specific method of
<a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6770">#6770</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.21">
<h2 class="release-version">1.4.21<a class="headerlink" href="#change-1.4.21" title="Permalink to this headline">¶</a></h2>
Released: July 14, 2021<section id="change-1.4.21-orm">
<h3>orm<a class="headerlink" href="#change-1.4.21-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.21-0"><span class="target" id="change-eef36903ba8b034f8c868f135475b1c0"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-eef36903ba8b034f8c868f135475b1c0">¶</a></span><p>Modified the approach used for history tracking of scalar object
relationships that are not many-to-one, i.e. one-to-one relationships that
would otherwise be one-to-many. When replacing a one-to-one value, the
“old” value that would be replaced is no longer loaded immediately, and is
instead handled during the flush process. This eliminates an historically
troublesome lazy load that otherwise often occurs when assigning to a
one-to-one attribute, and is particularly troublesome when using
“lazy=’raise’” as well as asyncio use cases.</p>
<p>This change does cause a behavioral change within the
<a class="reference internal" href="../orm/events.html#sqlalchemy.orm.AttributeEvents.set" title="sqlalchemy.orm.AttributeEvents.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AttributeEvents.set()</span></code></a> event, which is nonetheless currently
documented, which is that the event applied to such a one-to-one attribute
will no longer receive the “old” parameter if it is unloaded and the
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.active_history</span></code></a> flag is not set. As is
documented in <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.AttributeEvents.set" title="sqlalchemy.orm.AttributeEvents.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AttributeEvents.set()</span></code></a>, if the event handler needs
to receive the “old” value when the event fires off, the active_history
flag must be established either with the event listener or with the
relationship. This is already the behavior with other kinds of attributes
such as many-to-one and column value references.</p>
<p>The change additionally will defer updating a backref on the “old” value
in the less common case that the “old” value is locally present in the
session, but isn’t loaded on the relationship in question, until the
next flush occurs.  If this causes an issue, again the normal
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.active_history</span></code></a> flag can be set to <code class="docutils literal notranslate"><span class="pre">True</span></code>
on the relationship.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6708">#6708</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.21-1"><span class="target" id="change-2486962d00283068bc64c25c80850da7"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2486962d00283068bc64c25c80850da7">¶</a></span><p>Fixed regression caused in 1.4.19 due to <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6503">#6503</a> and related
involving <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.with_entities" title="sqlalchemy.orm.Query.with_entities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_entities()</span></code></a> where the new structure used
would be inappropriately transferred to an enclosing <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
when making use of set operations such as <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.union" title="sqlalchemy.orm.Query.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.union()</span></code></a>, causing
the JOIN instructions within to be applied to the outside query as well.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6698">#6698</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.21-2"><span class="target" id="change-8f2ae663ce28e6c8e6724fe70d600deb"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8f2ae663ce28e6c8e6724fe70d600deb">¶</a></span><p>Fixed regression which appeared in version 1.4.3 due to <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6060">#6060</a>
where rules that limit ORM adaptation of derived selectables interfered
with other ORM-adaptation based cases, in this case when applying
adaptations for a <a class="reference internal" href="../orm/inheritance_loading.html#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_polymorphic()</span></code></a> against a mapping which
uses a <a class="reference internal" href="../orm/mapping_columns.html#sqlalchemy.orm.column_property" title="sqlalchemy.orm.column_property"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code></a> which in turn makes use of a scalar
select that includes a <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> object of the mapped table.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6762">#6762</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.21-3"><span class="target" id="change-5dd4fd5eb49b9ac49facc71ba885a1ef"><strong>[orm] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5dd4fd5eb49b9ac49facc71ba885a1ef">¶</a></span><p>Fixed ORM regression where ad-hoc label names generated for hybrid
properties and potentially other similar types of ORM-enabled expressions
would usually be propagated outwards through subqueries, allowing the name
to be retained in the final keys of the result set even when selecting from
subqueries. Additional state is now tracked in this case that isn’t lost
when a hybrid is selected out of a Core select / subquery.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6718">#6718</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.21-sql">
<h3>sql<a class="headerlink" href="#change-1.4.21-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.21-4"><span class="target" id="change-4eeb14f28516f22d86fff9beb39ccba1"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4eeb14f28516f22d86fff9beb39ccba1">¶</a></span><p>Added new method <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.HasCTE.add_cte" title="sqlalchemy.sql.expression.HasCTE.add_cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HasCTE.add_cte()</span></code></a> to each of the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>, <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a>, <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.update" title="sqlalchemy.sql.expression.update"><code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code></a> and
<a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.delete" title="sqlalchemy.sql.expression.delete"><code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code></a> constructs. This method will add the given
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> as an “independent” CTE of the statement, meaning it
renders in the WITH clause above the statement unconditionally even if it
is not otherwise referenced in the primary statement. This is a popular use
case on the PostgreSQL database where a CTE is used for a DML statement
that runs against database rows independently of the primary statement.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6752">#6752</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.21-5"><span class="target" id="change-cdebc74cf1838a7ac47525d47b5f0c57"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-cdebc74cf1838a7ac47525d47b5f0c57">¶</a></span><p>Fixed issue in CTE constructs where a recursive CTE that referred to a
SELECT that has duplicate column names, which are typically deduplicated
using labeling logic in 1.4, would fail to refer to the deduplicated label
name correctly within the WITH clause.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6710">#6710</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.21-6"><span class="target" id="change-fb241e1d6aeee03b4087430479a70586"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-fb241e1d6aeee03b4087430479a70586">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.tablesample" title="sqlalchemy.sql.expression.tablesample"><code class="xref py py-func docutils literal notranslate"><span class="pre">tablesample()</span></code></a> construct would fail to
be executable when constructed given a floating-point sampling value not
embedded within a SQL function.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6735">#6735</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.21-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.21-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.21-7"><span class="target" id="change-2325834d284678f009497a717997af59"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2325834d284678f009497a717997af59">¶</a></span><p>Fixed issue in <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing" title="sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.on_conflict_do_nothing()</span></code></a> and
<a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update" title="sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.on_conflict_do_update()</span></code></a> where the name of a unique
constraint passed as the <code class="docutils literal notranslate"><span class="pre">constraint</span></code> parameter would not be properly
truncated for length if it were based on a naming convention that generated
a too-long name for the PostgreSQL max identifier length of 63 characters,
in the same way which occurs within a CREATE TABLE statement.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6755">#6755</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.21-8"><span class="target" id="change-dd0ebb02044e3c7aeb35580570fd40aa"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-dd0ebb02044e3c7aeb35580570fd40aa">¶</a></span><p>Fixed issue where the PostgreSQL <code class="docutils literal notranslate"><span class="pre">ENUM</span></code> datatype as embedded in the
<code class="docutils literal notranslate"><span class="pre">ARRAY</span></code> datatype would fail to emit correctly in create/drop when the
<code class="docutils literal notranslate"><span class="pre">schema_translate_map</span></code> feature were also in use. Additionally repairs a
related issue where the same <code class="docutils literal notranslate"><span class="pre">schema_translate_map</span></code> feature would not
work for the <code class="docutils literal notranslate"><span class="pre">ENUM</span></code> datatype in combination with a <code class="docutils literal notranslate"><span class="pre">CAST</span></code>, that’s also
intrinsic to how the <code class="docutils literal notranslate"><span class="pre">ARRAY(ENUM)</span></code> combination works on the PostgreSQL
dialect.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6739">#6739</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.21-9"><span class="target" id="change-2325834d284678f009497a717997af59"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2325834d284678f009497a717997af59">¶</a></span><p>Fixed issue in <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing" title="sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.on_conflict_do_nothing()</span></code></a> and
<a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update" title="sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.on_conflict_do_update()</span></code></a> where the name of a unique
constraint passed as the <code class="docutils literal notranslate"><span class="pre">constraint</span></code> parameter would not be properly
quoted if it contained characters which required quoting.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6696">#6696</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.21-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.21-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.21-10"><span class="target" id="change-011a427a2ddc58ded27f7555922030f5"><strong>[mssql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-011a427a2ddc58ded27f7555922030f5">¶</a></span><p>Fixed regression where the special dotted-schema name handling for the SQL
Server dialect would not function correctly if the dotted schema name were
used within the <code class="docutils literal notranslate"><span class="pre">schema_translate_map</span></code> feature.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6697">#6697</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.20">
<h2 class="release-version">1.4.20<a class="headerlink" href="#change-1.4.20" title="Permalink to this headline">¶</a></h2>
Released: June 28, 2021<section id="change-1.4.20-orm">
<h3>orm<a class="headerlink" href="#change-1.4.20-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.20-0"><span class="target" id="change-4a5a1b87f4ca3ad73424b376920263ea"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4a5a1b87f4ca3ad73424b376920263ea">¶</a></span><p>Fixed regression in ORM regarding an internal reconstitution step for the
<a class="reference internal" href="../orm/inheritance_loading.html#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_polymorphic()</span></code></a> construct, when the user-facing object is
garbage collected as the query is processed. The reconstitution was not
ensuring the sub-entities for the “polymorphic” case were handled, leading
to an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6680">#6680</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.20-1"><span class="target" id="change-041e41b3d01e1a5ae12ca6a2d475272d"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-041e41b3d01e1a5ae12ca6a2d475272d">¶</a></span><p>Adjusted <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.union" title="sqlalchemy.orm.Query.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.union()</span></code></a> and similar set operations to be
correctly compatible with the new capabilities just added in
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6661">#6661</a>, with SQLAlchemy 1.4.19, such that the SELECT statements
rendered as elements of the UNION or other set operation will include
directly mapped columns that are mapped as deferred; this both fixes a
regression involving unions with multiple levels of nesting that would
produce a column mismatch, and also allows the <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.undefer" title="sqlalchemy.orm.undefer"><code class="xref py py-func docutils literal notranslate"><span class="pre">undefer()</span></code></a> option
to be used at the top level of such a <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> without having to
apply the option to each of the elements within the UNION.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6678">#6678</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.20-2"><span class="target" id="change-c9d0d361fc1a2b2a0d1618370e507503"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c9d0d361fc1a2b2a0d1618370e507503">¶</a></span><p>Adjusted the check in the mapper for a callable object that is used as a
<code class="docutils literal notranslate"><span class="pre">&#64;validates</span></code> validator function or a <code class="docutils literal notranslate"><span class="pre">&#64;reconstructor</span></code> reconstruction
function, to check for “callable” more liberally such as to accommodate
objects based on fundamental attributes like <code class="docutils literal notranslate"><span class="pre">__func__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__call___</span></code>, rather than testing for <code class="docutils literal notranslate"><span class="pre">MethodType</span></code> / <code class="docutils literal notranslate"><span class="pre">FunctionType</span></code>,
allowing things like cython functions to work properly. Pull request
courtesy Miłosz Stypiński.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6538">#6538</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.20-engine">
<h3>engine<a class="headerlink" href="#change-1.4.20-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.20-3"><span class="target" id="change-eabe800d4e52288d754dfeb0bf265c6a"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-eabe800d4e52288d754dfeb0bf265c6a">¶</a></span><p>Fixed an issue in the C extension for the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> class which
could lead to a memory leak in the unlikely case of a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>
object which referred to an ORM object that then was mutated to refer back
to the <code class="docutils literal notranslate"><span class="pre">Row</span></code> itself, creating a cycle. The Python C APIs for tracking GC
cycles has been added to the native <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> implementation to
accommodate for this case.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5348">#5348</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.20-4"><span class="target" id="change-b6301293de12a3c7e2dbb6dd0607a257"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b6301293de12a3c7e2dbb6dd0607a257">¶</a></span><p>Fixed old issue where a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> made against the token “*”,
which then yielded exactly one column, would fail to correctly organize the
<code class="docutils literal notranslate"><span class="pre">cursor.description</span></code> column name into the keys of the result object.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6665">#6665</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.20-sql">
<h3>sql<a class="headerlink" href="#change-1.4.20-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.20-5"><span class="target" id="change-52302932aca0fb1e9fc4dae3cfe576d7"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-52302932aca0fb1e9fc4dae3cfe576d7">¶</a></span><p>Add a impl parameter to <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.PickleType" title="sqlalchemy.types.PickleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleType</span></code></a> constructor, allowing
any arbitary type to be used in place of the default implementation of
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.LargeBinary" title="sqlalchemy.types.LargeBinary"><code class="xref py py-class docutils literal notranslate"><span class="pre">LargeBinary</span></code></a>. Pull request courtesy jason3gb.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6646">#6646</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.20-6"><span class="target" id="change-0eb09089a5bd36a5afdfc737cf6aaf89"><strong>[sql] [bug] [orm]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0eb09089a5bd36a5afdfc737cf6aaf89">¶</a></span><p>Fixed the class hierarchy for the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> and the more
general <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.DefaultGenerator" title="sqlalchemy.schema.DefaultGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefaultGenerator</span></code></a> base, as these are “executable”
as statements they need to include <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Executable" title="sqlalchemy.sql.expression.Executable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executable</span></code></a> in their
hierarchy, not just <code class="xref py py-class docutils literal notranslate"><span class="pre">StatementRole</span></code> as was applied
arbitrarily to <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> previously. The fix allows
<a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> to work in all <code class="docutils literal notranslate"><span class="pre">.execute()</span></code> methods including
with <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> which was not working in the case that a
<a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute" title="sqlalchemy.orm.SessionEvents.do_orm_execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.do_orm_execute()</span></code></a> handler was also established.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6668">#6668</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.20-schema">
<h3>schema<a class="headerlink" href="#change-1.4.20-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.20-7"><span class="target" id="change-0b2a6fcc1bdd3113f730323d1f6321f1"><strong>[schema] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0b2a6fcc1bdd3113f730323d1f6321f1">¶</a></span><p>Fixed issue where passing <code class="docutils literal notranslate"><span class="pre">None</span></code> for the value of
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.prefixes" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.prefixes</span></code></a> would not store an empty list, but
rather the constant <code class="docutils literal notranslate"><span class="pre">None</span></code>, which may be unexpected by third party
dialects. The issue is revealed by a usage in recent versions of Alembic
that are passing <code class="docutils literal notranslate"><span class="pre">None</span></code> for this value. Pull request courtesy Kai
Mueller.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6685">#6685</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.20-mysql">
<h3>mysql<a class="headerlink" href="#change-1.4.20-mysql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.20-8"><span class="target" id="change-25d5a698ba3db36e6235d6b61e7833a4"><strong>[mysql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-25d5a698ba3db36e6235d6b61e7833a4">¶</a></span><p>Made a small adjustment in the table reflection feature of the MySQL
dialect to accommodate for alternate MySQL-oriented databases such as TiDB
which include their own “comment” directives at the end of a constraint
directive within “CREATE TABLE” where the format doesn’t have the
additional space character after the comment, in this case the TiDB
“clustered index” feature. Pull request courtesy Daniël van Eeden.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6659">#6659</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.20-misc">
<h3>misc<a class="headerlink" href="#change-1.4.20-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.20-9"><span class="target" id="change-78a99d702de573a199e400a310adadb5"><strong>[bug] [ext] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-78a99d702de573a199e400a310adadb5">¶</a></span><p>Fixed regression in <a class="reference internal" href="../orm/extensions/automap.html#module-sqlalchemy.ext.automap" title="sqlalchemy.ext.automap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.automap</span></code></a> extension such that the
use case of creating an explicit mapped class to a table that is also the
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code></a> element of a
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> that automap will be generating would emit the
“overlaps” warnings introduced in 1.4 and discussed at <a class="reference internal" href="../errors.html#error-qzyx"><span class="std std-ref">relationship X will copy column Q to column P, which conflicts with relationship(s): ‘Y’</span></a>.
While generating this case from automap is still subject to the same
caveats that the “overlaps” warning refers towards, as automap is intended
for more ad-hoc use cases, the condition which produces the warning is
disabled when a many-to-many relationship with this particular pattern is
generated.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6679">#6679</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.19">
<h2 class="release-version">1.4.19<a class="headerlink" href="#change-1.4.19" title="Permalink to this headline">¶</a></h2>
Released: June 22, 2021<section id="change-1.4.19-orm">
<h3>orm<a class="headerlink" href="#change-1.4.19-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.19-0"><span class="target" id="change-4170fc47b5b904e759f9412acb808572"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4170fc47b5b904e759f9412acb808572">¶</a></span><p>Fixed further regressions in the same area as that of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6052">#6052</a> where
loader options as well as invocations of methods like
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> would fail if the left side of the statement for
which the option/join depends upon were replaced by using the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.with_entities" title="sqlalchemy.orm.Query.with_entities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_entities()</span></code></a> method, or when using 2.0 style queries
when using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns" title="sqlalchemy.sql.expression.Select.with_only_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.with_only_columns()</span></code></a> method. A new set of
state has been added to the objects which tracks the “left” entities that
the options / join were made against which is memoized when the lead
entities are changed.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6253">#6253</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6503">#6503</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.19-1"><span class="target" id="change-462f2ac1050a69b84cf7127ac2f69345"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-462f2ac1050a69b84cf7127ac2f69345">¶</a></span><p>Refined the behavior of ORM subquery rendering with regards to deferred
columns and column properties to be more compatible with that of 1.3 while
also providing for 1.4’s newer features. As a subquery in 1.4 does not make
use of loader options, including <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.undefer" title="sqlalchemy.orm.undefer"><code class="xref py py-func docutils literal notranslate"><span class="pre">undefer()</span></code></a>, a subquery that is
against an ORM entity with deferred attributes will now render those
deferred attributes that refer directly to mapped table columns, as these
are needed in the outer SELECT if that outer SELECT makes use of these
columns; however a deferred attribute that refers to a composed SQL
expression as we normally do with <a class="reference internal" href="../orm/mapping_columns.html#sqlalchemy.orm.column_property" title="sqlalchemy.orm.column_property"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code></a> will not be
part of the subquery, as these can be selected explicitly if needed in the
subquery. If the entity is being SELECTed from this subquery, the column
expression can still render on “the outside” in terms of the derived
subquery columns. This produces essentially the same behavior as when
working with 1.3. However in this case the fix has to also make sure that
the <code class="docutils literal notranslate"><span class="pre">.selected_columns</span></code> collection of an ORM-enabled <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>
also follows these rules, which in particular allows recursive CTEs to
render correctly in this scenario, which were previously failing to render
correctly due to this issue.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6661">#6661</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.19-sql">
<h3>sql<a class="headerlink" href="#change-1.4.19-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.19-2"><span class="target" id="change-ab3baf63af9e81bca03f3f2c6ae43e1c"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ab3baf63af9e81bca03f3f2c6ae43e1c">¶</a></span><p>Fixed issue in CTE constructs mostly relevant to ORM use cases where a
recursive CTE against “anonymous” labels such as those seen in ORM
<code class="docutils literal notranslate"><span class="pre">column_property()</span></code> mappings would render in the
<code class="docutils literal notranslate"><span class="pre">WITH</span> <span class="pre">RECURSIVE</span> <span class="pre">xyz(...)</span></code> section as their raw internal label and not a
cleanly anonymized name.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6663">#6663</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.19-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.19-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.19-3"><span class="target" id="change-a7d45ec4456b3abfaec9dfa5be7deff2"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a7d45ec4456b3abfaec9dfa5be7deff2">¶</a></span><p>Fixed issue in mypy plugin where class info for a custom declarative base
would not be handled correctly on a cached mypy pass, leading to an
AssertionError being raised.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6476">#6476</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.19-asyncio">
<h3>asyncio<a class="headerlink" href="#change-1.4.19-asyncio" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.19-4"><span class="target" id="change-fe5777d131b54b05178cdb5074001a70"><strong>[asyncio] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-fe5777d131b54b05178cdb5074001a70">¶</a></span><p>Implemented <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session" title="sqlalchemy.ext.asyncio.async_scoped_session"><code class="xref py py-class docutils literal notranslate"><span class="pre">async_scoped_session</span></code></a> to address some
asyncio-related incompatibilities between <code class="xref py py-class docutils literal notranslate"><span class="pre">scoped_session</span></code> and
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a>, in which some methods (notably the
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session.remove" title="sqlalchemy.ext.asyncio.async_scoped_session.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">async_scoped_session.remove()</span></code></a> method) should be used with
the <code class="docutils literal notranslate"><span class="pre">await</span></code> keyword.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/extensions/asyncio.html#asyncio-scoped-session"><span class="std std-ref">Using asyncio scoped session</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6583">#6583</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.19-5"><span class="target" id="change-2d552137f1522d84f647516bd6cfc38c"><strong>[asyncio] [bug] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2d552137f1522d84f647516bd6cfc38c">¶</a></span><p>Fixed bug in asyncio implementation where the greenlet adaptation system
failed to propagate <code class="docutils literal notranslate"><span class="pre">BaseException</span></code> subclasses, most notably including
<code class="docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code>, to the exception handling logic used by the
engine to invalidate and clean up the connection, thus preventing
connections from being correctly disposed when a task was cancelled.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6652">#6652</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.19-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.19-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.19-6"><span class="target" id="change-21ebf5455e56ff21cea71ac8aab2d6ff"><strong>[postgresql] [bug] [oracle]</strong> <a class="changelog-reference headerlink reference internal" href="#change-21ebf5455e56ff21cea71ac8aab2d6ff">¶</a></span><p>Fixed issue where the <code class="docutils literal notranslate"><span class="pre">INTERVAL</span></code> datatype on PostgreSQL and Oracle would
produce an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> when used in the context of a comparison
operation against a <code class="docutils literal notranslate"><span class="pre">timedelta()</span></code> object. Pull request courtesy
MajorDallas.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6649">#6649</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.19-7"><span class="target" id="change-049a56ef669b62f77ae2e706931820c0"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-049a56ef669b62f77ae2e706931820c0">¶</a></span><p>Fixed issue where the pool “pre ping” feature would implicitly start a
transaction, which would then interfere with custom transactional flags
such as PostgreSQL’s “read only” mode when used with the psycopg2 driver.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6621">#6621</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.19-mysql">
<h3>mysql<a class="headerlink" href="#change-1.4.19-mysql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.19-8"><span class="target" id="change-24eda54d536acc790f8f7568dc046f8c"><strong>[mysql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-24eda54d536acc790f8f7568dc046f8c">¶</a></span><p>Added new construct <a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.match" title="sqlalchemy.dialects.mysql.match"><code class="xref py py-class docutils literal notranslate"><span class="pre">match</span></code></a>, which provides for the full
range of MySQL’s MATCH operator including multiple column support and
modifiers. Pull request courtesy Anton Kovalevich.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.match" title="sqlalchemy.dialects.mysql.match"><code class="xref py py-class docutils literal notranslate"><span class="pre">match</span></code></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6132">#6132</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.19-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.19-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.19-9"><span class="target" id="change-653c3f14400ff10ece05c6747f223a81"><strong>[mssql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-653c3f14400ff10ece05c6747f223a81">¶</a></span><p>Made improvements to the server version regexp used by the pymssql dialect
to prevent a regexp overflow in case of an invalid version string.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6253">#6253</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6503">#6503</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.19-10"><span class="target" id="change-19fd79df5f822cca78978cc86c0285a8"><strong>[mssql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-19fd79df5f822cca78978cc86c0285a8">¶</a></span><p>Fixed bug where the “schema_translate_map” feature would fail to function
correctly in conjunction with an INSERT into a table that has an IDENTITY
column, where the value of the IDENTITY column were specified in the values
of the INSERT thus triggering SQLAlchemy’s feature of setting IDENTITY
INSERT to “on”; it’s in this directive where the schema translate map would
fail to be honored.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6658">#6658</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.18">
<h2 class="release-version">1.4.18<a class="headerlink" href="#change-1.4.18" title="Permalink to this headline">¶</a></h2>
Released: June 10, 2021<section id="change-1.4.18-orm">
<h3>orm<a class="headerlink" href="#change-1.4.18-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.18-0"><span class="target" id="change-c44bef7c81e356405fc8438d62ed6fb2"><strong>[orm] [performance] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c44bef7c81e356405fc8438d62ed6fb2">¶</a></span><p>Fixed regression involving how the ORM would resolve a given mapped column
to a result row, where under cases such as joined eager loading, a slightly
more expensive “fallback” could take place to set up this resolution due to
some logic that was removed since 1.3. The issue could also cause
deprecation warnings involving column resolution to be emitted when using a
1.4 style query with joined eager loading.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6596">#6596</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.18-1"><span class="target" id="change-bbc62687df1511016980bc3701009b8b"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-bbc62687df1511016980bc3701009b8b">¶</a></span><p>Clarified the current purpose of the
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.bake_queries" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.bake_queries</span></code></a> flag, which in 1.4 is to enable
or disable “lambda caching” of statements within the “lazyload” and
“selectinload” loader strategies; this is separate from the more
foundational SQL query cache that is used for most statements.
Additionally, the lazy loader no longer uses its own cache for many-to-one
SQL queries, which was an implementation quirk that doesn’t exist for any
other loader scenario. Finally, the “lru cache” warning that the lazyloader
and selectinloader strategies could emit when handling a wide array of
class/relationship combinations has been removed; based on analysis of some
end-user cases, this warning doesn’t suggest any significant issue. While
setting <code class="docutils literal notranslate"><span class="pre">bake_queries=False</span></code> for such a relationship will remove this
cache from being used, there’s no particular performance gain in this case
as using no caching vs. using a cache that needs to refresh often likely
still wins out on the caching being used side.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6072">#6072</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6487">#6487</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.18-2"><span class="target" id="change-d2695c12943f278ad9d30faa9fb3f801"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d2695c12943f278ad9d30faa9fb3f801">¶</a></span><p>Adjusted the means by which classes such as <code class="xref py py-class docutils literal notranslate"><span class="pre">scoped_session</span></code>
and <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a> are generated from the base
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> class, such that custom <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>
subclasses such as that used by Flask-SQLAlchemy don’t need to implement
positional arguments when they call into the superclass method, and can
continue using the same argument styles as in previous releases.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6285">#6285</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.18-3"><span class="target" id="change-f63c401b2709ae6721b787d7eda1a013"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f63c401b2709ae6721b787d7eda1a013">¶</a></span><p>Fixed issue where query production for joinedload against a complex left
hand side involving joined-table inheritance could fail to produce a
correct query, due to a clause adaption issue.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6595">#6595</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.18-4"><span class="target" id="change-1695ae48e5e4dad141529f1476931402"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-1695ae48e5e4dad141529f1476931402">¶</a></span><p>Fixed issue in experimental “select ORM objects from INSERT/UPDATE” use
case where an error was raised if the statement were against a
single-table-inheritance subclass.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6591">#6591</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.18-5"><span class="target" id="change-25ff9a8e87b9a1a7c9ad8cefe9c95e05"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-25ff9a8e87b9a1a7c9ad8cefe9c95e05">¶</a></span><p>The warning that’s emitted for <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> when multiple
relationships would overlap with each other as far as foreign key
attributes written towards, now includes the specific “overlaps” argument
to use for each warning in order to silence the warning without changing
the mapping.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6400">#6400</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.18-asyncio">
<h3>asyncio<a class="headerlink" href="#change-1.4.18-asyncio" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.18-6"><span class="target" id="change-0c6e0cc67dfe6fac5164720e57ef307d"><strong>[asyncio] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0c6e0cc67dfe6fac5164720e57ef307d">¶</a></span><p>Implemented a new registry architecture that allows the <code class="docutils literal notranslate"><span class="pre">Async</span></code> version
of an object, like <code class="docutils literal notranslate"><span class="pre">AsyncSession</span></code>, <code class="docutils literal notranslate"><span class="pre">AsyncConnection</span></code>, etc., to be
locatable given the proxied “sync” object, i.e. <code class="docutils literal notranslate"><span class="pre">Session</span></code>,
<code class="docutils literal notranslate"><span class="pre">Connection</span></code>. Previously, to the degree such lookup functions were used,
an <code class="docutils literal notranslate"><span class="pre">Async</span></code> object would be re-created each time, which was less than
ideal as the identity and state of the “async” object would not be
preserved across calls.</p>
<p>From there, new helper functions <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_object_session" title="sqlalchemy.ext.asyncio.async_object_session"><code class="xref py py-func docutils literal notranslate"><span class="pre">async_object_session()</span></code></a>,
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.async_session" title="sqlalchemy.ext.asyncio.async_session"><code class="xref py py-func docutils literal notranslate"><span class="pre">async_session()</span></code></a> as well as a new <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstanceState" title="sqlalchemy.orm.InstanceState"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstanceState</span></code></a>
attribute <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstanceState.async_session" title="sqlalchemy.orm.InstanceState.async_session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InstanceState.async_session</span></code></a> have been added, which
are used to retrieve the original <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a> associated
with an ORM mapped object, a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> associated with an
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a>, and an <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a>
associated with an <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstanceState" title="sqlalchemy.orm.InstanceState"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstanceState</span></code></a>, respectively.</p>
<p>This patch also implements new methods
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.in_nested_transaction" title="sqlalchemy.ext.asyncio.AsyncSession.in_nested_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.in_nested_transaction()</span></code></a>,
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.get_transaction" title="sqlalchemy.ext.asyncio.AsyncSession.get_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.get_transaction()</span></code></a>,
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.get_nested_transaction" title="sqlalchemy.ext.asyncio.AsyncSession.get_nested_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.get_nested_transaction()</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6319">#6319</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.18-7"><span class="target" id="change-9eadb198af07f2c35c4ee65276d82073"><strong>[asyncio] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9eadb198af07f2c35c4ee65276d82073">¶</a></span><p>Fixed an issue that presented itself when using the <a class="reference internal" href="../core/pooling.html#sqlalchemy.pool.NullPool" title="sqlalchemy.pool.NullPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullPool</span></code></a>
or the <a class="reference internal" href="../core/pooling.html#sqlalchemy.pool.StaticPool" title="sqlalchemy.pool.StaticPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">StaticPool</span></code></a> with an async engine. This mostly affected
the aiosqlite dialect.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6575">#6575</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.18-8"><span class="target" id="change-aa02fde5ac472d52e7f83cb253728ac5"><strong>[asyncio] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-aa02fde5ac472d52e7f83cb253728ac5">¶</a></span><p>Added <code class="docutils literal notranslate"><span class="pre">asyncio.exceptions.TimeoutError</span></code>,
<code class="docutils literal notranslate"><span class="pre">asyncio.exceptions.CancelledError</span></code> as so-called “exit exceptions”, a
class of exceptions that include things like <code class="docutils literal notranslate"><span class="pre">GreenletExit</span></code> and
<code class="docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code>, which are considered to be events that warrant
considering a DBAPI connection to be in an unusable state where it should
be recycled.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6592">#6592</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.18-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.18-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.18-9"><span class="target" id="change-c4b77eb636cfe7e5032d80803b86c06b"><strong>[postgresql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c4b77eb636cfe7e5032d80803b86c06b">¶</a></span><p>Fixed regression where using the PostgreSQL “INSERT..ON CONFLICT” structure
would fail to work with the psycopg2 driver if it were used in an
“executemany” context along with bound parameters in the “SET” clause, due
to the implicit use of the psycopg2 fast execution helpers which are not
appropriate for this style of INSERT statement; as these helpers are the
default in 1.4 this is effectively a regression.  Additional checks to
exclude this kind of statement from that particular extension have been
added.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6581">#6581</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.18-sqlite">
<h3>sqlite<a class="headerlink" href="#change-1.4.18-sqlite" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.18-10"><span class="target" id="change-893bb331fdb6d9284cf55f1c2f05050a"><strong>[sqlite] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-893bb331fdb6d9284cf55f1c2f05050a">¶</a></span><p>Add note regarding encryption-related pragmas for pysqlcipher passed in the
url.</p>
<p>This change is also <strong>backported</strong> to: 1.3.25</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6589">#6589</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.18-11"><span class="target" id="change-e8c51e89e51b1cea83b45492e140962f"><strong>[sqlite] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e8c51e89e51b1cea83b45492e140962f">¶</a></span><p>The fix for pysqlcipher released in version 1.4.3 <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5848">#5848</a> was
unfortunately non-working, in that the new <code class="docutils literal notranslate"><span class="pre">on_connect_url</span></code> hook was
erroneously not receiving a <code class="docutils literal notranslate"><span class="pre">URL</span></code> object under normal usage of
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> and instead received a string that was unhandled;
the test suite failed to fully set up the actual conditions under which
this hook is called. This has been fixed.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6586">#6586</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.17">
<h2 class="release-version">1.4.17<a class="headerlink" href="#change-1.4.17" title="Permalink to this headline">¶</a></h2>
Released: May 29, 2021<section id="change-1.4.17-orm">
<h3>orm<a class="headerlink" href="#change-1.4.17-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.17-0"><span class="target" id="change-3d91f98c5f1802abb3bb4d59bce0a49f"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3d91f98c5f1802abb3bb4d59bce0a49f">¶</a></span><p>Fixed regression caused by just-released performance fix mentioned in #6550
where a query.join() to a relationship could produce an AttributeError if
the query were made against non-ORM structures only, a fairly unusual
calling pattern.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6558">#6558</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.16">
<h2 class="release-version">1.4.16<a class="headerlink" href="#change-1.4.16" title="Permalink to this headline">¶</a></h2>
Released: May 28, 2021<section id="change-1.4.16-general">
<h3>general<a class="headerlink" href="#change-1.4.16-general" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.16-0"><span class="target" id="change-26b972a33b586542bc80507730cf74af"><strong>[general] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-26b972a33b586542bc80507730cf74af">¶</a></span><p>Resolved various deprecation warnings which were appearing as of Python
version 3.10.0b1.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6540">#6540</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6543">#6543</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.16-orm">
<h3>orm<a class="headerlink" href="#change-1.4.16-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.16-1"><span class="target" id="change-d64179829f4cb479ee30af2624a91cd1"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d64179829f4cb479ee30af2624a91cd1">¶</a></span><p>Fixed issue when using <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade_backrefs</span></code></a>
parameter set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, which per <a class="reference internal" href="migration_14.html#change-5150"><span class="std std-ref">cascade_backrefs behavior deprecated for removal in 2.0</span></a> is set to become
the standard behavior in SQLAlchemy 2.0, where adding the item to a
collection that uniquifies, such as <code class="docutils literal notranslate"><span class="pre">set</span></code> or <code class="docutils literal notranslate"><span class="pre">dict</span></code> would fail to fire
a cascade event if the object were already associated in that collection
via the backref. This fix represents a fundamental change in the collection
mechanics by introducing a new event state which can fire off for a
collection mutation even if there is no net change on the collection; the
action is now suited using a new event hook
<a class="reference internal" href="../orm/events.html#sqlalchemy.orm.AttributeEvents.append_wo_mutation" title="sqlalchemy.orm.AttributeEvents.append_wo_mutation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AttributeEvents.append_wo_mutation()</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6471">#6471</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.16-2"><span class="target" id="change-dce7f5182fc635a88055f6fae9ca6ad9"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-dce7f5182fc635a88055f6fae9ca6ad9">¶</a></span><p>Fixed regression involving clause adaption of labeled ORM compound
elements, such as single-table inheritance discriminator expressions with
conditionals or CASE expressions, which could cause aliased expressions
such as those used in ORM join / joinedload operations to not be adapted
correctly, such as referring to the wrong table in the ON clause in a join.</p>
<p>This change also improves a performance bump that was located within the
process of invoking <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> given an ORM attribute
as a target.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6550">#6550</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.16-3"><span class="target" id="change-a9ff5477fc06c4f2dca909caad0d6cd2"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a9ff5477fc06c4f2dca909caad0d6cd2">¶</a></span><p>Fixed regression where the full combination of joined inheritance, global
with_polymorphic, self-referential relationship and joined loading would
fail to be able to produce a query with the scope of lazy loads and object
refresh operations that also attempted to render the joined loader.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6495">#6495</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.16-4"><span class="target" id="change-64c7750c1db8563ab605d2194c3f4174"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-64c7750c1db8563ab605d2194c3f4174">¶</a></span><p>Enhanced the bind resolution rules for <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> so that
when a non-ORM statement such as an <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a> construct
nonetheless is built against ORM objects, to the greatest degree possible
the ORM entity will be used to resolve the bind, such as for a
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> that has a bind map set up on a common superclass
without specific mappers or tables named in the map.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6484">#6484</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.16-engine">
<h3>engine<a class="headerlink" href="#change-1.4.16-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.16-5"><span class="target" id="change-23315fd04baaccf6b767f0ce31733ce3"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-23315fd04baaccf6b767f0ce31733ce3">¶</a></span><p>Fixed issue where an <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> sign in the database portion of a URL would not
be interpreted correctly if the URL also had a username:password section.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6482">#6482</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.16-6"><span class="target" id="change-3a7d33d7440ebc5ccbf8a38a300a4186"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3a7d33d7440ebc5ccbf8a38a300a4186">¶</a></span><p>Fixed a long-standing issue with <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> where query parameters
following the question mark would not be parsed correctly if the URL did
not contain a database portion with a backslash.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6329">#6329</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.16-sql">
<h3>sql<a class="headerlink" href="#change-1.4.16-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.16-7"><span class="target" id="change-736a3cefd3bf32ae9b878a3169bf2d9e"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-736a3cefd3bf32ae9b878a3169bf2d9e">¶</a></span><p>Fixed regression in dynamic loader strategy and <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>
overall where the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.order_by" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.order_by</span></code></a> parameter were
stored as a mutable list, which could then be mutated when combined with
additional “order_by” methods used against the dynamic query object,
causing the ORDER BY criteria to continue to grow repetitively.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6549">#6549</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.16-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.16-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.16-8"><span class="target" id="change-b045a0fe54cf05a1f6c6fb8d123a5b74"><strong>[mssql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b045a0fe54cf05a1f6c6fb8d123a5b74">¶</a></span><p>Implemented support for a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> construct to be used directly
as the target of a <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.delete" title="sqlalchemy.sql.expression.delete"><code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code></a> construct, i.e. “WITH … AS cte
DELETE FROM cte”. This appears to be a useful feature of SQL Server.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6464">#6464</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.16-misc">
<h3>misc<a class="headerlink" href="#change-1.4.16-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.16-9"><span class="target" id="change-c6b34eb8a0e12b220393b32aa4ab09a5"><strong>[bug] [ext]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c6b34eb8a0e12b220393b32aa4ab09a5">¶</a></span><p>Fixed a deprecation warning that was emitted when using
<a class="reference internal" href="../orm/extensions/automap.html#sqlalchemy.ext.automap.automap_base" title="sqlalchemy.ext.automap.automap_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">automap_base()</span></code></a> without passing an existing
<code class="docutils literal notranslate"><span class="pre">Base</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6529">#6529</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.16-10"><span class="target" id="change-ada6fea84654724d167cf72756e59e6f"><strong>[bug] [pep484]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ada6fea84654724d167cf72756e59e6f">¶</a></span><p>Remove pep484 types from the code.
Current effort is around the stub package, and having typing in
two places makes thing worse, since the types in the SQLAlchemy
source were usually outdated compared to the version in the stubs.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6461">#6461</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.16-11"><span class="target" id="change-9a2049e2fdd7259aeac4525e05864592"><strong>[bug] [ext] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9a2049e2fdd7259aeac4525e05864592">¶</a></span><p>Fixed regression in the <code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.instrumentation</span></code> extension that
prevented instrumentation disposal from working completely. This fix
includes both a 1.4 regression fix as well as a fix for a related issue
that existed in 1.3 also.   As part of this change, the
<a class="reference internal" href="../orm/extensions/instrumentation.html#sqlalchemy.ext.instrumentation.InstrumentationManager" title="sqlalchemy.ext.instrumentation.InstrumentationManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.ext.instrumentation.InstrumentationManager</span></code></a> class now
has a new method <code class="docutils literal notranslate"><span class="pre">unregister()</span></code>, which replaces the previous method
<code class="docutils literal notranslate"><span class="pre">dispose()</span></code>, which was not called as of version 1.4.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6390">#6390</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.15">
<h2 class="release-version">1.4.15<a class="headerlink" href="#change-1.4.15" title="Permalink to this headline">¶</a></h2>
Released: May 11, 2021<section id="change-1.4.15-general">
<h3>general<a class="headerlink" href="#change-1.4.15-general" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.15-0"><span class="target" id="change-13d69b29a6f6ddc586fd1d7ae830dcca"><strong>[general] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-13d69b29a6f6ddc586fd1d7ae830dcca">¶</a></span><p>A new approach has been applied to the warnings system in SQLAlchemy to
accurately predict the appropriate stack level for each warning
dynamically. This allows evaluating the source of SQLAlchemy-generated
warnings and deprecation warnings to be more straightforward as the warning
will indicate the source line within end-user code, rather than from an
arbitrary level within SQLAlchemy’s own source code.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6241">#6241</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.15-orm">
<h3>orm<a class="headerlink" href="#change-1.4.15-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.15-1"><span class="target" id="change-51b4f964dd24a4aeb19a6e901c78805e"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-51b4f964dd24a4aeb19a6e901c78805e">¶</a></span><p>Fixed additional regression caused by “eager loaders run on unexpire”
feature <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1763">#1763</a> where the feature would run for a
<code class="docutils literal notranslate"><span class="pre">contains_eager()</span></code> eagerload option in the case that the
<code class="docutils literal notranslate"><span class="pre">contains_eager()</span></code> were chained to an additional eager loader option,
which would then produce an incorrect query as the original query-bound
join criteria were no longer present.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6449">#6449</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.15-2"><span class="target" id="change-8cdeace3479107147da7c39c69dd7a20"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8cdeace3479107147da7c39c69dd7a20">¶</a></span><p>Fixed issue in subquery loader strategy which prevented caching from
working correctly. This would have been seen in the logs as a “generated”
message instead of “cached” for all subqueryload SQL emitted, which by
saturating the cache with new keys would degrade overall performance; it
also would produce “LRU size alert” warnings.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6459">#6459</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.15-sql">
<h3>sql<a class="headerlink" href="#change-1.4.15-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.15-3"><span class="target" id="change-4e1b89db8abc4067d4f2ea31a7b06e28"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4e1b89db8abc4067d4f2ea31a7b06e28">¶</a></span><p>Adjusted the logic added as part of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6397">#6397</a> in 1.4.12 so that
internal mutation of the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BindParameter</span></code></a> object occurs within the
clause construction phase as it did before, rather than in the compilation
phase. In the latter case, the mutation still produced side effects against
the incoming construct and additionally could potentially interfere with
other internal mutation routines.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6460">#6460</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.15-mysql">
<h3>mysql<a class="headerlink" href="#change-1.4.15-mysql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.15-4"><span class="target" id="change-6b360f6438317b1c28ede996aa286ce0"><strong>[mysql] [bug] [documentation]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6b360f6438317b1c28ede996aa286ce0">¶</a></span><p>Added support for the <code class="docutils literal notranslate"><span class="pre">ssl_check_hostname=</span></code> parameter in mysql connection
URIs and updated the mysql dialect documentation regarding secure
connections. Original pull request courtesy of Jerry Zhao.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5397">#5397</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.14">
<h2 class="release-version">1.4.14<a class="headerlink" href="#change-1.4.14" title="Permalink to this headline">¶</a></h2>
Released: May 6, 2021<section id="change-1.4.14-orm">
<h3>orm<a class="headerlink" href="#change-1.4.14-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.14-0"><span class="target" id="change-7b8fc812bf1a733d7d0d4187d5ecfd51"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7b8fc812bf1a733d7d0d4187d5ecfd51">¶</a></span><p>Fixed regression involving <code class="docutils literal notranslate"><span class="pre">lazy='dynamic'</span></code> loader in conjunction with a
detached object. The previous behavior was that the dynamic loader upon
calling methods like <code class="docutils literal notranslate"><span class="pre">.all()</span></code> returns empty lists for detached objects
without error, this has been restored; however a warning is now emitted as
this is not the correct result. Other dynamic loader scenarios correctly
raise <code class="docutils literal notranslate"><span class="pre">DetachedInstanceError</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6426">#6426</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.14-engine">
<h3>engine<a class="headerlink" href="#change-1.4.14-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.14-1"><span class="target" id="change-c9b480d1b8f1e38fb84587f9aff0f76c"><strong>[engine] [usecase] [orm]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c9b480d1b8f1e38fb84587f9aff0f76c">¶</a></span><p>Applied consistent behavior to the use case of
calling <code class="docutils literal notranslate"><span class="pre">.commit()</span></code> or <code class="docutils literal notranslate"><span class="pre">.rollback()</span></code> inside of an existing
<code class="docutils literal notranslate"><span class="pre">.begin()</span></code> context manager, with the addition of potentially
emitting SQL within the block subsequent to the commit or rollback.
This change continues upon the change first added in
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6155">#6155</a> where the use case of calling “rollback” inside of
a <code class="docutils literal notranslate"><span class="pre">.begin()</span></code> contextmanager block was proposed:</p>
<ul>
<li><p>calling <code class="docutils literal notranslate"><span class="pre">.commit()</span></code> or <code class="docutils literal notranslate"><span class="pre">.rollback()</span></code> will now be allowed
without error or warning within all scopes, including
that of legacy and future <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>, ORM
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, asyncio <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine" title="sqlalchemy.ext.asyncio.AsyncEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncEngine</span></code></a>.  Previously,
the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> disallowed this.</p></li>
<li><p>The remaining scope of the context manager is then closed;
when the block ends, a check is emitted to see if the transaction
was already ended, and if so the block returns without action.</p></li>
<li><p>It will now raise <strong>an error</strong> if subsequent SQL of any kind
is emitted within the block, <strong>after</strong> <code class="docutils literal notranslate"><span class="pre">.commit()</span></code> or
<code class="docutils literal notranslate"><span class="pre">.rollback()</span></code> is called.   The block should be closed as
the state of the executable object would otherwise be undefined
in this state.</p></li>
</ul>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6288">#6288</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.14-2"><span class="target" id="change-dba623123d27dce2beec2728261ecec0"><strong>[engine] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-dba623123d27dce2beec2728261ecec0">¶</a></span><p>Established a deprecation path for calling upon the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">CursorResult.keys()</span></code> method for a statement that returns no
rows to provide support for legacy patterns used by the “records” package
as well as any other non-migrated applications. Previously, this would
raise <code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceClosedException</span></code> unconditionally in the same way as
it does when attempting to fetch rows. While this is the correct behavior
going forward, the <code class="xref py py-class docutils literal notranslate"><span class="pre">_cursor.LegacyCursorResult</span></code> object will now in
this case return an empty list for <code class="docutils literal notranslate"><span class="pre">.keys()</span></code> as it did in 1.3, while also
emitting a 2.0 deprecation warning. The <code class="xref py py-class docutils literal notranslate"><span class="pre">_cursor.CursorResult</span></code>, used
when using a 2.0-style “future” engine, will continue to raise as it does
now.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6427">#6427</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.14-sql">
<h3>sql<a class="headerlink" href="#change-1.4.14-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.14-3"><span class="target" id="change-a3c4f11e9286b62ccebe558a30c9e2b7"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a3c4f11e9286b62ccebe558a30c9e2b7">¶</a></span><p>Fixed regression caused by the “empty in” change just made in
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6397">#6397</a> 1.4.12 where the expression needs to be parenthesized for
the “not in” use case, otherwise the condition will interfere with the
other filtering criteria.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6428">#6428</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.14-4"><span class="target" id="change-6d2362213d53c20f6f886d6b7ed5dfe7"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6d2362213d53c20f6f886d6b7ed5dfe7">¶</a></span><p>The <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a> class will now emit a warning when used in SQL
compilation with caching unless the <code class="docutils literal notranslate"><span class="pre">.cache_ok</span></code> flag is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>
or <code class="docutils literal notranslate"><span class="pre">False</span></code>. A new class-level attribute <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator.cache_ok" title="sqlalchemy.types.TypeDecorator.cache_ok"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TypeDecorator.cache_ok</span></code></a>
may be set which will be used as an indication that all the parameters
passed to the object are safe to be used as a cache key if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
<code class="docutils literal notranslate"><span class="pre">False</span></code> means they are not.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6436">#6436</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.13">
<h2 class="release-version">1.4.13<a class="headerlink" href="#change-1.4.13" title="Permalink to this headline">¶</a></h2>
Released: May 3, 2021<section id="change-1.4.13-orm">
<h3>orm<a class="headerlink" href="#change-1.4.13-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.13-0"><span class="target" id="change-ecb43e94028bcc0ca076957ce3b02f41"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ecb43e94028bcc0ca076957ce3b02f41">¶</a></span><p>Fixed regression in <code class="docutils literal notranslate"><span class="pre">selectinload</span></code> loader strategy that would cause it to
cache its internal state incorrectly when handling relationships that join
across more than one column, such as when using a composite foreign key.
The invalid caching would then cause other unrelated loader operations to
fail.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6410">#6410</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.13-1"><span class="target" id="change-e2ce3fff5595dc65c5269347e3677753"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e2ce3fff5595dc65c5269347e3677753">¶</a></span><p>Fixed regression where <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.filter_by" title="sqlalchemy.orm.Query.filter_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.filter_by()</span></code></a> would not work if the
lead entity were a SQL function or other expression derived from the
primary entity in question, rather than a simple entity or column of that
entity. Additionally, improved the behavior of
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by" title="sqlalchemy.sql.expression.Select.filter_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.filter_by()</span></code></a> overall to work with column expressions even
in a non-ORM context.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6414">#6414</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.13-2"><span class="target" id="change-d8cc40fcbd1385493f007354c2afef7f"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d8cc40fcbd1385493f007354c2afef7f">¶</a></span><p>Fixed regression where using <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> and
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.subqueryload" title="sqlalchemy.orm.subqueryload"><code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code></a> to load a two-level-deep path would lead to an
attribute error.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6419">#6419</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.13-3"><span class="target" id="change-b667fb5766da1e7db0a88c95f62fcdb2"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b667fb5766da1e7db0a88c95f62fcdb2">¶</a></span><p>Fixed regression where using the <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.noload" title="sqlalchemy.orm.noload"><code class="xref py py-func docutils literal notranslate"><span class="pre">noload()</span></code></a> loader strategy in
conjunction with a “dynamic” relationship would lead to an attribute error
as the noload strategy would attempt to apply itself to the dynamic loader.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6420">#6420</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.13-engine">
<h3>engine<a class="headerlink" href="#change-1.4.13-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.13-4"><span class="target" id="change-c9c96d6dcf5f77e0ef0b48638f7eb25e"><strong>[engine] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c9c96d6dcf5f77e0ef0b48638f7eb25e">¶</a></span><p>Restored a legacy transactional behavior that was inadvertently removed
from the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> as it was never tested as a known use
case in previous versions, where calling upon the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.begin_nested" title="sqlalchemy.engine.Connection.begin_nested"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.begin_nested()</span></code></a> method, when no transaction is
present, does not create a SAVEPOINT at all and instead starts an outer
transaction, returning a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.RootTransaction" title="sqlalchemy.engine.RootTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootTransaction</span></code></a> object instead of a
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.NestedTransaction" title="sqlalchemy.engine.NestedTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedTransaction</span></code></a> object.  This <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.RootTransaction" title="sqlalchemy.engine.RootTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootTransaction</span></code></a> then
will emit a real COMMIT on the database connection when committed.
Previously, the 2.0 style behavior was present in all cases that would
autobegin a transaction but not commit it, which is a behavioral change.</p>
<p>When using a <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> connection object, the behavior is unchanged
from previous 1.4 versions; calling <a class="reference internal" href="../core/future.html#sqlalchemy.future.Connection.begin_nested" title="sqlalchemy.future.Connection.begin_nested"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.begin_nested()</span></code></a>
will “autobegin” the outer transaction if not already present, and then as
instructed emit a SAVEPOINT, returning the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.NestedTransaction" title="sqlalchemy.engine.NestedTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedTransaction</span></code></a>
object. The outer transaction is committed by calling upon
<a class="reference internal" href="../core/future.html#sqlalchemy.future.Connection.commit" title="sqlalchemy.future.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.commit()</span></code></a>, as is “commit-as-you-go” style usage.</p>
<p>In non-“future” mode, while the old behavior is restored, it also
emits a 2.0 deprecation warning as this is a legacy behavior.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6408">#6408</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.13-asyncio">
<h3>asyncio<a class="headerlink" href="#change-1.4.13-asyncio" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.13-5"><span class="target" id="change-699c2bcc29f6f2506d5456b06784befc"><strong>[asyncio] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-699c2bcc29f6f2506d5456b06784befc">¶</a></span><p>Fixed a regression introduced by <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6337">#6337</a> that would create an
<code class="docutils literal notranslate"><span class="pre">asyncio.Lock</span></code> which could be attached to the wrong loop when
instantiating the async engine before any asyncio loop was started, leading
to an asyncio error message when attempting to use the engine under certain
circumstances.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6409">#6409</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.13-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.13-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.13-6"><span class="target" id="change-f7fe807330448d935a8397f06e155ebc"><strong>[postgresql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f7fe807330448d935a8397f06e155ebc">¶</a></span><p>Add support for server side cursors in the pg8000 dialect for PostgreSQL.
This allows use of the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Connection.execution_options.stream_results</span></code></a> option.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6198">#6198</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.12">
<h2 class="release-version">1.4.12<a class="headerlink" href="#change-1.4.12" title="Permalink to this headline">¶</a></h2>
Released: April 29, 2021<section id="change-1.4.12-orm">
<h3>orm<a class="headerlink" href="#change-1.4.12-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.12-0"><span class="target" id="change-07e8e84ba997707d94d88046aa699560"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-07e8e84ba997707d94d88046aa699560">¶</a></span><p>Fixed issue in <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects" title="sqlalchemy.orm.Session.bulk_save_objects"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.bulk_save_objects()</span></code></a> when used with persistent
objects which would fail to track the primary key of mappings where the
column name of the primary key were different than the attribute name.</p>
<p>This change is also <strong>backported</strong> to: 1.3.25</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6392">#6392</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-1"><span class="target" id="change-c825af633656f98865b750d5d349e5ae"><strong>[orm] [bug] [caching] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c825af633656f98865b750d5d349e5ae">¶</a></span><p>Fixed critical regression where bound parameter tracking as used in the SQL
caching system could fail to track all parameters for the case where the
same SQL expression containing a parameter were used in an ORM-related
query using a feature such as class inheritance, which was then embedded in
an enclosing expression which would make use of that same expression
multiple times, such as a UNION. The ORM would individually copy the
individual SELECT statements as part of compilation with class inheritance,
which then embedded in the enclosing statement would fail to accommodate
for all parameters. The logic that tracks this condition has been adjusted
to work for multiple copies of a parameter.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6391">#6391</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-2"><span class="target" id="change-2047ee7bbdf8e5f905ab399aa5db9fcd"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2047ee7bbdf8e5f905ab399aa5db9fcd">¶</a></span><p>Fixed two distinct issues mostly affecting
<a class="reference internal" href="../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property" title="sqlalchemy.ext.hybrid.hybrid_property"><code class="xref py py-class docutils literal notranslate"><span class="pre">hybrid_property</span></code></a>, which would come into play under common
mis-configuration scenarios that were silently ignored in 1.3, and now
failed in 1.4, where the “expression” implementation would return a non
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a> such as a boolean value. For both issues, 1.3’s
behavior was to silently ignore the mis-configuration and ultimately
attempt to interpret the value as a SQL expression, which would lead to an
incorrect query.</p>
<ul>
<li><p>Fixed issue regarding interaction of the attribute system with
hybrid_property, where if the <code class="docutils literal notranslate"><span class="pre">__clause_element__()</span></code> method of the
attribute returned a non-<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a> object, an internal
<code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> would lead the attribute to return the <code class="docutils literal notranslate"><span class="pre">expression</span></code>
function on the hybrid_property itself, as the attribute error was
against the name <code class="docutils literal notranslate"><span class="pre">.expression</span></code> which would invoke the <code class="docutils literal notranslate"><span class="pre">__getattr__()</span></code>
method as a fallback. This now raises explicitly. In 1.3 the
non-<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a> was returned directly.</p></li>
<li><p>Fixed issue in SQL argument coercions system where passing the wrong
kind of object to methods that expect column expressions would fail if
the object were altogether not a SQLAlchemy object, such as a Python
function, in cases where the object were not just coerced into a bound
value. Again 1.3 did not have a comprehensive argument coercion system
so this case would also pass silently.</p></li>
</ul>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6350">#6350</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-3"><span class="target" id="change-d486b8c0bbb179c9f7e76b8b151b0334"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d486b8c0bbb179c9f7e76b8b151b0334">¶</a></span><p>Fixed issue where using a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> as a subquery in an ORM
context would modify the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> in place to disable
eagerloads on that object, which would then cause that same
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> to not eagerload if it were then re-used in a
top-level execution context.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6378">#6378</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-4"><span class="target" id="change-612e2d1693aad5baa6faf5bc4594e9dd"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-612e2d1693aad5baa6faf5bc4594e9dd">¶</a></span><p>Fixed issue where the new <a class="reference internal" href="../orm/session_basics.html#session-autobegin"><span class="std std-ref">autobegin</span></a> behavior
failed to “autobegin” in the case where an existing persistent object has
an attribute change, which would then impact the behavior of
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.rollback" title="sqlalchemy.orm.Session.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code></a> in that no snapshot was created to be rolled
back. The “attribute modify” mechanics have been updated to ensure
“autobegin”, which does not perform any database work, does occur when
persistent attributes change in the same manner as when
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.add" title="sqlalchemy.orm.Session.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add()</span></code></a> is called. This is a regression as in 1.3, the
rollback() method always had a transaction to roll back and would expire
every time.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6359">#6359</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6360">#6360</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-5"><span class="target" id="change-312abd0f26c3dd1d8210112c6ff438ef"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-312abd0f26c3dd1d8210112c6ff438ef">¶</a></span><p>Fixed regression in ORM where using hybrid property to indicate an
expression from a different entity would confuse the column-labeling logic
in the ORM and attempt to derive the name of the hybrid from that other
class, leading to an attribute error. The owning class of the hybrid
attribute is now tracked along with the name.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6386">#6386</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-6"><span class="target" id="change-d21cf4f143d0f1acc476d5a8cbe064eb"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d21cf4f143d0f1acc476d5a8cbe064eb">¶</a></span><p>Fixed regression in hybrid_property where a hybrid against a SQL function
would generate an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> when attempting to generate an entry
for the <code class="docutils literal notranslate"><span class="pre">.c</span></code> collection of a subquery in some cases; among other things
this would impact its use in cases like that of <code class="docutils literal notranslate"><span class="pre">Query.count()</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6401">#6401</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-7"><span class="target" id="change-b21c07efd7b50ed2ef7b4105fe0fa57a"><strong>[orm] [bug] [dataclasses]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b21c07efd7b50ed2ef7b4105fe0fa57a">¶</a></span><p>Adjusted the declarative scan for dataclasses so that the inheritance
behavior of <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declared_attr" title="sqlalchemy.orm.declared_attr"><code class="xref py py-func docutils literal notranslate"><span class="pre">declared_attr()</span></code></a> established on a mixin, when using
the new form of having it inside of a <code class="docutils literal notranslate"><span class="pre">dataclasses.field()</span></code> construct and
not actually a descriptor attribute on the class, correctly accommodates
the case when the target class to be mapped is a subclass of an existing
mapped class which has already mapped that <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declared_attr" title="sqlalchemy.orm.declared_attr"><code class="xref py py-func docutils literal notranslate"><span class="pre">declared_attr()</span></code></a>, and
therefore should not be re-applied to this class.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6346">#6346</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-8"><span class="target" id="change-4d1a1b20329e769903fece37e2371770"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4d1a1b20329e769903fece37e2371770">¶</a></span><p>Fixed an issue with the (deprecated in 1.4)
<a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.copy" title="sqlalchemy.schema.ForeignKeyConstraint.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ForeignKeyConstraint.copy()</span></code></a> method that caused an error when
invoked with the <code class="docutils literal notranslate"><span class="pre">schema</span></code> argument.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6353">#6353</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.12-engine">
<h3>engine<a class="headerlink" href="#change-1.4.12-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.12-9"><span class="target" id="change-2363a8dcad39fcd7f9e05513c456e44d"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2363a8dcad39fcd7f9e05513c456e44d">¶</a></span><p>Fixed issue where usage of an explicit <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> would produce
inconsistent “inline” behavior for an <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a> construct that
includes multiple values phrases; the first seq would be inline but
subsequent ones would be “pre-execute”, leading to inconsistent sequence
ordering. The sequence expressions are now fully inline.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6361">#6361</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.12-sql">
<h3>sql<a class="headerlink" href="#change-1.4.12-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.12-10"><span class="target" id="change-20dd07034cce4f2c57956b9eb3a5846f"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-20dd07034cce4f2c57956b9eb3a5846f">¶</a></span><p>Revised the “EMPTY IN” expression to no longer rely upon using a subquery,
as this was causing some compatibility and performance problems. The new
approach for selected databases takes advantage of using a NULL-returning
IN expression combined with the usual “1 != 1” or “1 = 1” expression
appended by AND or OR. The expression is now the default for all backends
other than SQLite, which still had some compatibility issues regarding
tuple “IN” for older SQLite versions.</p>
<p>Third party dialects can still override how the “empty set” expression
renders by implementing a new compiler method
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">visit_empty_set_op_expr(self,</span> <span class="pre">type_,</span> <span class="pre">expand_op)</span></code>, which takes
precedence over the existing
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">visit_empty_set_expr(self,</span> <span class="pre">element_types)</span></code> which remains in place.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6258">#6258</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6397">#6397</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-11"><span class="target" id="change-c3b1c6a69db1d0f18b68ff5503eefc31"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c3b1c6a69db1d0f18b68ff5503eefc31">¶</a></span><p>Fixed regression where usage of the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> construct inside the
columns clause of a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> construct, which is better handled
by using a <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a> construct, would nonetheless prevent
constructs like <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union" title="sqlalchemy.sql.expression.union"><code class="xref py py-func docutils literal notranslate"><span class="pre">union()</span></code></a> from working correctly. Other use cases,
such as constructing subuqeries, continue to work the same as in prior
versions where the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> construct is silently omitted from the
collection of exported columns.   Also repairs similar use within the
ORM.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6343">#6343</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-12"><span class="target" id="change-76bbd36da2e14f93d0bd5182a40f056b"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-76bbd36da2e14f93d0bd5182a40f056b">¶</a></span><p>Fixed regression involving legacy methods such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.append_column()</span></code> where internal assertions would fail.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6261">#6261</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-13"><span class="target" id="change-609bab1f6e5481c6557236ec1e7ebc72"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-609bab1f6e5481c6557236ec1e7ebc72">¶</a></span><p>Fixed regression caused by <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5395">#5395</a> where tuning back the check for
sequences in <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> now caused failures when doing 2.0-style
querying with a mapped class that also happens to have an <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code>
method. Tuned the check some more to accommodate this as well as some other
interesting <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code> scenarios.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6300">#6300</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.12-schema">
<h3>schema<a class="headerlink" href="#change-1.4.12-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.12-14"><span class="target" id="change-f64dfb86a65c743179d26f5e167c1be8"><strong>[schema] [bug] [mariadb] [mysql] [oracle] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f64dfb86a65c743179d26f5e167c1be8">¶</a></span><p>Ensure that the MySQL and MariaDB dialect ignore the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code> construct while rendering the <code class="docutils literal notranslate"><span class="pre">AUTO_INCREMENT</span></code>
keyword in a create table.</p>
<p>The Oracle and PostgreSQL compiler was updated to not render
<code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code> if the database version does not support it
(Oracle &lt; 12 and PostgreSQL &lt; 10). Previously it was rendered regardless
of the database version.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6338">#6338</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.12-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.12-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.12-15"><span class="target" id="change-cae2973d444d1d132325d63a23f0f853"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-cae2973d444d1d132325d63a23f0f853">¶</a></span><p>Fixed very old issue where the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a> datatype would not
inherit the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.params.schema" title="sqlalchemy.schema.MetaData"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">MetaData.schema</span></code></a> parameter of a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object when that object were passed to the
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a> using <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.metadata" title="sqlalchemy.types.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.metadata</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6373">#6373</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.12-sqlite">
<h3>sqlite<a class="headerlink" href="#change-1.4.12-sqlite" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.12-16"><span class="target" id="change-06c2b0a2ec8439c231c8ea9603ad042c"><strong>[sqlite] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-06c2b0a2ec8439c231c8ea9603ad042c">¶</a></span><p>Default to using <code class="docutils literal notranslate"><span class="pre">SingletonThreadPool</span></code> for in-memory SQLite databases
created using URI filenames. Previously the default pool used was the
<code class="docutils literal notranslate"><span class="pre">NullPool</span></code> that precented sharing the same database between multiple
engines.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6379">#6379</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.12-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.12-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.12-17"><span class="target" id="change-ca6e8dc440b8fceacfcd3bd8c912f1e9"><strong>[mssql] [bug] [schema]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ca6e8dc440b8fceacfcd3bd8c912f1e9">¶</a></span><p>Add <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine.as_generic" title="sqlalchemy.types.TypeEngine.as_generic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.as_generic()</span></code></a> support for
<a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.BIT" title="sqlalchemy.dialects.mysql.BIT"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.mysql.BIT</span></code></a> columns, mapping
them to <code class="xref py py-class docutils literal notranslate"><span class="pre">Boolean</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6345">#6345</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.12-18"><span class="target" id="change-07a3bb586f97f1e5b30915584d98ddac"><strong>[mssql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-07a3bb586f97f1e5b30915584d98ddac">¶</a></span><p>Fixed regression caused by <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6306">#6306</a> which added support for
<code class="docutils literal notranslate"><span class="pre">DateTime(timezone=True)</span></code>, where the previous behavior of the pyodbc
driver of implicitly dropping the tzinfo from a timezone-aware date when
INSERTing into a timezone-naive DATETIME column were lost, leading to a SQL
Server error when inserting timezone-aware datetime objects into
timezone-native database columns.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6366">#6366</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.11">
<h2 class="release-version">1.4.11<a class="headerlink" href="#change-1.4.11" title="Permalink to this headline">¶</a></h2>
Released: April 21, 2021<section id="change-1.4.11-orm-declarative">
<h3>orm declarative<a class="headerlink" href="#change-1.4.11-orm-declarative" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.11-0"><span class="target" id="change-4e9cb9f4a38f52b42d2c74ad82311c31"><strong>[orm] [declarative] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4e9cb9f4a38f52b42d2c74ad82311c31">¶</a></span><p>Fixed regression where recent changes to support Python dataclasses had the
inadvertent effect that an ORM mapped class could not successfully override
the <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> method.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6331">#6331</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.11-engine">
<h3>engine<a class="headerlink" href="#change-1.4.11-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.11-1"><span class="target" id="change-b66c758696824e8c13b276de752ff474"><strong>[engine] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b66c758696824e8c13b276de752ff474">¶</a></span><p>Fixed critical regression caused by the change in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5497">#5497</a> where the
connection pool “init” phase no longer occurred within mutexed isolation,
allowing other threads to proceed with the dialect uninitialized, which
could then impact the compilation of SQL statements.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6337">#6337</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.10">
<h2 class="release-version">1.4.10<a class="headerlink" href="#change-1.4.10" title="Permalink to this headline">¶</a></h2>
Released: April 20, 2021<section id="change-1.4.10-orm">
<h3>orm<a class="headerlink" href="#change-1.4.10-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.10-0"><span class="target" id="change-744adabcc2bbee8440f15588d40810c1"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-744adabcc2bbee8440f15588d40810c1">¶</a></span><p>Altered some of the behavior repaired in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6232">#6232</a> where the
<code class="docutils literal notranslate"><span class="pre">immediateload</span></code> loader strategy no longer goes into recursive loops; the
modification is that an eager load (joinedload, selectinload, or
subqueryload) from A-&gt;bs-&gt;B which then states <code class="docutils literal notranslate"><span class="pre">immediateload</span></code> for a
simple manytoone B-&gt;a-&gt;A that’s in the identity map will populate the B-&gt;A,
so that this attribute is back-populated when the collection of A/A.bs are
loaded. This allows the objects to be functional when detached.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.10-1"><span class="target" id="change-1517cdbf92820d3071b5dc845459e91a"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-1517cdbf92820d3071b5dc845459e91a">¶</a></span><p>Fixed bug in new <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_loader_criteria" title="sqlalchemy.orm.with_loader_criteria"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_loader_criteria()</span></code></a> feature where using a
mixin class with <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declared_attr" title="sqlalchemy.orm.declared_attr"><code class="xref py py-func docutils literal notranslate"><span class="pre">declared_attr()</span></code></a> on an attribute that were
accessed inside the custom lambda would emit a warning regarding using an
unmapped declared attr, when the lambda callable were first initialized.
This warning is now prevented using special instrumentation for this
lambda initialization step.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6320">#6320</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.10-2"><span class="target" id="change-8e4c6e98437c10a54d6e00217c35bf4f"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8e4c6e98437c10a54d6e00217c35bf4f">¶</a></span><p>Fixed additional regression caused by the “eagerloaders on refresh” feature
added in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1763">#1763</a> where the refresh operation historically would set
<code class="docutils literal notranslate"><span class="pre">populate_existing</span></code>, which given the new feature now overwrites pending
changes on eagerly loaded objects when autoflush is false. The
populate_existing flag has been turned off for this case and a more
specific method used to ensure the correct attributes refreshed.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6326">#6326</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.10-3"><span class="target" id="change-d369509b3f243f8d4e09677636955c0d"><strong>[orm] [bug] [result]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d369509b3f243f8d4e09677636955c0d">¶</a></span><p>Fixed an issue when using 2.0 style execution that prevented using
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.scalar_one" title="sqlalchemy.engine.Result.scalar_one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.scalar_one()</span></code></a> or
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.scalar_one_or_none" title="sqlalchemy.engine.Result.scalar_one_or_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.scalar_one_or_none()</span></code></a> after calling
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.unique" title="sqlalchemy.engine.Result.unique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.unique()</span></code></a>, for the case where the ORM is returning a
single-element row in any case.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6299">#6299</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.10-sql">
<h3>sql<a class="headerlink" href="#change-1.4.10-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.10-4"><span class="target" id="change-2b9668455cf1d8230626801d1c85878d"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2b9668455cf1d8230626801d1c85878d">¶</a></span><p>Fixed issue in SQL compiler where the bound parameters set up for a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Values" title="sqlalchemy.sql.expression.Values"><code class="xref py py-class docutils literal notranslate"><span class="pre">Values</span></code></a> construct wouldn’t be positionally tracked correctly if
inside of a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a>, affecting database drivers that support
VALUES + ctes and use positional parameters such as SQL Server in
particular as well as asyncpg.   The fix also repairs support for
compiler flags such as <code class="docutils literal notranslate"><span class="pre">literal_binds</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6327">#6327</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.10-5"><span class="target" id="change-5b7734b496bc9146ff1734d4001f6681"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5b7734b496bc9146ff1734d4001f6681">¶</a></span><p>Repaired and solidified issues regarding custom functions and other
arbitrary expression constructs which within SQLAlchemy’s column labeling
mechanics would seek to use <code class="docutils literal notranslate"><span class="pre">str(obj)</span></code> to get a string representation to
use as an anonymous column name in the <code class="docutils literal notranslate"><span class="pre">.c</span></code> collection of a subquery.
This is a very legacy behavior that performs poorly and leads to lots of
issues, so has been revised to no longer perform any compilation by
establishing specific methods on <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement" title="sqlalchemy.sql.functions.FunctionElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionElement</span></code></a> to handle this
case, as SQL functions are the only use case that it came into play. An
effect of this behavior is that an unlabeled column expression with no
derivable name will be given an arbitrary label starting with the prefix
<code class="docutils literal notranslate"><span class="pre">&quot;_no_label&quot;</span></code> in the <code class="docutils literal notranslate"><span class="pre">.c</span></code> collection of a subquery; these were
previously being represented either as the generic stringification of that
expression, or as an internal symbol.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6256">#6256</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.10-schema">
<h3>schema<a class="headerlink" href="#change-1.4.10-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.10-6"><span class="target" id="change-c32b5ed6b9b1f719d65c0cede62e951b"><strong>[schema] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c32b5ed6b9b1f719d65c0cede62e951b">¶</a></span><p>Fixed issue where <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.next_value" title="sqlalchemy.sql.functions.next_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">next_value()</span></code></a> was not deriving its type
from the corresponding <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>, instead hardcoded to
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>. The specific numeric type is now used.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6287">#6287</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.10-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.10-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.10-7"><span class="target" id="change-2f8a55a47eaf3a726ec852800d816280"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2f8a55a47eaf3a726ec852800d816280">¶</a></span><p>Fixed issue where mypy plugin would not correctly interpret an explicit
<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> annotation in conjunction with a
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> that refers to a class by string name; the
correct annotation would be downgraded to a less specific one leading to
typing errors.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6255">#6255</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.10-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.10-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.10-8"><span class="target" id="change-c0cd2c4244bed1636709705a06d0912b"><strong>[mssql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c0cd2c4244bed1636709705a06d0912b">¶</a></span><p>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime.params.timezone" title="sqlalchemy.types.DateTime"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">DateTime.timezone</span></code></a> parameter when set to <code class="docutils literal notranslate"><span class="pre">True</span></code>
will now make use of the <code class="docutils literal notranslate"><span class="pre">DATETIMEOFFSET</span></code> column type with SQL Server
when used to emit DDL, rather than <code class="docutils literal notranslate"><span class="pre">DATETIME</span></code> where the flag was silently
ignored.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6306">#6306</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.10-misc">
<h3>misc<a class="headerlink" href="#change-1.4.10-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.10-9"><span class="target" id="change-f56f0e30b8c30ca63ee5bc6ef0a84b5b"><strong>[bug] [declarative] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f56f0e30b8c30ca63ee5bc6ef0a84b5b">¶</a></span><p>Fixed <code class="xref py py-func docutils literal notranslate"><span class="pre">instrument_declarative()</span></code> that called
a non existing registry method.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6291">#6291</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.9">
<h2 class="release-version">1.4.9<a class="headerlink" href="#change-1.4.9" title="Permalink to this headline">¶</a></h2>
Released: April 17, 2021<section id="change-1.4.9-orm">
<h3>orm<a class="headerlink" href="#change-1.4.9-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.9-0"><span class="target" id="change-70278fa4ea933a43fb657c346369a0ba"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-70278fa4ea933a43fb657c346369a0ba">¶</a></span><p>Established support for <code class="xref py py-func docutils literal notranslate"><span class="pre">synoynm()</span></code> in conjunction with
hybrid property, assocaitionproxy is set up completely, including that
synonyms can be established linking to these constructs which work
fully.   This is a behavior that was semi-explicitly disallowed previously,
however since it did not fail in every scenario, explicit support
for assoc proxy and hybrids has been added.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6267">#6267</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.9-1"><span class="target" id="change-eea89cfd38e08bf30c339cd6c6831dec"><strong>[orm] [performance] [bug] [regression] [sql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-eea89cfd38e08bf30c339cd6c6831dec">¶</a></span><p>Fixed a critical performance issue where the traversal of a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct would traverse a repetitive product of the
represented FROM clauses as they were each referred towards by columns in
the columns clause; for a series of nested subqueries with lots of columns
this could cause a large delay and significant memory growth. This
traversal is used by a wide variety of SQL and ORM functions, including by
the ORM <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> when it’s configured to have
“table-per-bind”, which while this is not a common use case, it seems to be
what Flask-SQLAlchemy is hardcoded as using, so the issue impacts
Flask-SQLAlchemy users. The traversal has been repaired to uniqify on FROM
clauses which was effectively what would happen implicitly with the pre-1.4
architecture.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6304">#6304</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.9-2"><span class="target" id="change-c9efb26f264624d7e2ca308136a2fba7"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c9efb26f264624d7e2ca308136a2fba7">¶</a></span><p>Fixed regression where an attribute that is mapped to a
<a class="reference internal" href="../orm/mapped_attributes.html#sqlalchemy.orm.synonym" title="sqlalchemy.orm.synonym"><code class="xref py py-func docutils literal notranslate"><span class="pre">synonym()</span></code></a> could not be used in column loader options such as
<a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.load_only" title="sqlalchemy.orm.load_only"><code class="xref py py-func docutils literal notranslate"><span class="pre">load_only()</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6272">#6272</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.9-sql">
<h3>sql<a class="headerlink" href="#change-1.4.9-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.9-3"><span class="target" id="change-9cd7db1662dae9d54444bbcdd65a0b1e"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9cd7db1662dae9d54444bbcdd65a0b1e">¶</a></span><p>Fixed regression where an empty in statement on a tuple would result
in an error when compiled with the option <code class="docutils literal notranslate"><span class="pre">literal_binds=True</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6290">#6290</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.9-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.9-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.9-4"><span class="target" id="change-42837785149fd97078f3c31df8689031"><strong>[postgresql] [bug] [regression] [sql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-42837785149fd97078f3c31df8689031">¶</a></span><p>Fixed an argument error in the default and PostgreSQL compilers that
would interfere with an UPDATE..FROM or DELETE..FROM..USING statement
that was then SELECTed from as a CTE.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6303">#6303</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.8">
<h2 class="release-version">1.4.8<a class="headerlink" href="#change-1.4.8" title="Permalink to this headline">¶</a></h2>
Released: April 15, 2021<section id="change-1.4.8-orm">
<h3>orm<a class="headerlink" href="#change-1.4.8-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.8-0"><span class="target" id="change-b736d632b5a661182c467752f40ddeb1"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b736d632b5a661182c467752f40ddeb1">¶</a></span><p>Fixed a cache leak involving the <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.with_expression" title="sqlalchemy.orm.with_expression"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_expression()</span></code></a> loader
option, where the given SQL expression would not be correctly considered as
part of the cache key.</p>
<p>Additionally, fixed regression involving the corresponding
<a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.query_expression" title="sqlalchemy.orm.query_expression"><code class="xref py py-func docutils literal notranslate"><span class="pre">query_expression()</span></code></a> feature. While the bug technically exists in
1.3 as well, it was not exposed until 1.4. The “default expr” value of
<code class="docutils literal notranslate"><span class="pre">null()</span></code> would be rendered when not needed, and additionally was also not
adapted correctly when the ORM rewrites statements such as when using
joined eager loading. The fix ensures “singleton” expressions like <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
and <code class="docutils literal notranslate"><span class="pre">true</span></code> aren’t “adapted” to refer to columns in ORM statements, and
additionally ensures that a <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.query_expression" title="sqlalchemy.orm.query_expression"><code class="xref py py-func docutils literal notranslate"><span class="pre">query_expression()</span></code></a> with no default
expression doesn’t render in the statement if a
<a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.with_expression" title="sqlalchemy.orm.with_expression"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_expression()</span></code></a> isn’t used.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6259">#6259</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.8-1"><span class="target" id="change-46dc8180e255715bab89e939bd1783df"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-46dc8180e255715bab89e939bd1783df">¶</a></span><p>Fixed issue in the new feature of <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.refresh" title="sqlalchemy.orm.Session.refresh"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.refresh()</span></code></a> introduced
by <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1763">#1763</a> where eagerly loaded relationships are also refreshed,
where the <code class="docutils literal notranslate"><span class="pre">lazy=&quot;raise&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">lazy=&quot;raise_on_sql&quot;</span></code> loader strategies
would interfere with the <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.immediateload" title="sqlalchemy.orm.immediateload"><code class="xref py py-func docutils literal notranslate"><span class="pre">immediateload()</span></code></a> loader strategy, thus
breaking the feature for relationships that were loaded with
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a>, <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.subqueryload" title="sqlalchemy.orm.subqueryload"><code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code></a> as well.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6252">#6252</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.8-engine">
<h3>engine<a class="headerlink" href="#change-1.4.8-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.8-2"><span class="target" id="change-80d8fab2614090c6f7e1304727917693"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-80d8fab2614090c6f7e1304727917693">¶</a></span><p>The <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect.has_table" title="sqlalchemy.engine.Dialect.has_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Dialect.has_table()</span></code></a> method now raises an informative
exception if a non-Connection is passed to it, as this incorrect behavior
seems to be common.  This method is not intended for external use outside
of a dialect.  Please use the <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table" title="sqlalchemy.engine.reflection.Inspector.has_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.has_table()</span></code></a> method
or for cross-compatibility with older SQLAlchemy versions, the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.has_table" title="sqlalchemy.engine.Engine.has_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.has_table()</span></code></a> method.</p>
<p></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.8-sql">
<h3>sql<a class="headerlink" href="#change-1.4.8-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.8-3"><span class="target" id="change-861664210593775bea48edbc8e8acbc0"><strong>[sql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-861664210593775bea48edbc8e8acbc0">¶</a></span><p>The tuple returned by <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key" title="sqlalchemy.engine.CursorResult.inserted_primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CursorResult.inserted_primary_key</span></code></a> is now a
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> object with a named tuple interface on top of the
existing tuple interface.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/3314">#3314</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.8-4"><span class="target" id="change-0b5c8fce5573b358d4e1e6dd8d1c53a8"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0b5c8fce5573b358d4e1e6dd8d1c53a8">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BindParameter</span></code></a> object would not
properly render for an IN expression (i.e. using the “post compile” feature
in 1.4) if the object were copied from either an internal cloning
operation, or from a pickle operation, and the parameter name contained
spaces or other special characters.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6249">#6249</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.8-5"><span class="target" id="change-6d9543d25ff8aa5b0b813bfcea32d1f9"><strong>[sql] [bug] [regression] [sqlite]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6d9543d25ff8aa5b0b813bfcea32d1f9">¶</a></span><p>Fixed regression where the introduction of the INSERT syntax “INSERT…
VALUES (DEFAULT)” was not supported on some backends that do however
support “INSERT..DEFAULT VALUES”, including SQLite. The two syntaxes are
now each individually supported or non-supported for each dialect, for
example MySQL supports “VALUES (DEFAULT)” but not “DEFAULT VALUES”.
Support for Oracle has also been enabled.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6254">#6254</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.8-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.8-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.8-6"><span class="target" id="change-9baf5d305497d74783b9a61a9ce7ced0"><strong>[mypy] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9baf5d305497d74783b9a61a9ce7ced0">¶</a></span><p>Updated Mypy plugin to only use the public plugin interface of the
semantic analyzer.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.8-7"><span class="target" id="change-15f40d24a121bc6a2dcfa6e3b55f52c8"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-15f40d24a121bc6a2dcfa6e3b55f52c8">¶</a></span><p>Revised the fix for <code class="docutils literal notranslate"><span class="pre">OrderingList</span></code> from version 1.4.7 which was testing
against the incorrect API.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6205">#6205</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.8-asyncio">
<h3>asyncio<a class="headerlink" href="#change-1.4.8-asyncio" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.8-8"><span class="target" id="change-ffc180861bc63a693378f61d8c3e1b85"><strong>[asyncio] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ffc180861bc63a693378f61d8c3e1b85">¶</a></span><p>Fix typo that prevented setting the <code class="docutils literal notranslate"><span class="pre">bind</span></code> attribute of an
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a> to the correct value.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6220">#6220</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.8-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.8-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.8-9"><span class="target" id="change-44db5a89323070d5168796139e28cf8c"><strong>[mssql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-44db5a89323070d5168796139e28cf8c">¶</a></span><p>Fixed an additional regression in the same area as that of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6173">#6173</a>,
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6184">#6184</a>, where using a value of 0 for OFFSET in conjunction with
LIMIT with SQL Server would create a statement using “TOP”, as was the
behavior in 1.3, however due to caching would then fail to respond
accordingly to other values of OFFSET. If the “0” wasn’t first, then it
would be fine. For the fix, the “TOP” syntax is now only emitted if the
OFFSET value is omitted entirely, that is, <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.offset" title="sqlalchemy.sql.expression.Select.offset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.offset()</span></code></a> is
not used. Note that this change now requires that if the “with_ties” or
“percent” modifiers are used, the statement can’t specify an OFFSET of
zero, it now needs to be omitted entirely.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6265">#6265</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.7">
<h2 class="release-version">1.4.7<a class="headerlink" href="#change-1.4.7" title="Permalink to this headline">¶</a></h2>
Released: April 9, 2021<section id="change-1.4.7-orm">
<h3>orm<a class="headerlink" href="#change-1.4.7-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.7-0"><span class="target" id="change-8d9f08cb734969b3d4893b6019c1603a"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8d9f08cb734969b3d4893b6019c1603a">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.subqueryload" title="sqlalchemy.orm.subqueryload"><code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code></a> loader strategy would
fail to correctly accommodate sub-options, such as a <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.defer" title="sqlalchemy.orm.defer"><code class="xref py py-func docutils literal notranslate"><span class="pre">defer()</span></code></a>
option on a column, if the “path” of the subqueryload were more than one
level deep.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6221">#6221</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.7-1"><span class="target" id="change-e75779a916bf7b8adba4b6eafa79be47"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e75779a916bf7b8adba4b6eafa79be47">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.merge_frozen_result" title="sqlalchemy.orm.merge_frozen_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">merge_frozen_result()</span></code></a> function relied
upon by the dogpile.caching example was not included in tests and began
failing due to incorrect internal arguments.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6211">#6211</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.7-2"><span class="target" id="change-2124200943121ab7dc8c8838a8233677"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2124200943121ab7dc8c8838a8233677">¶</a></span><p>Fixed critical regression where the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> could fail to
“autobegin” a new transaction when a flush occurred without an existing
transaction in place, implicitly placing the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> into
legacy autocommit mode which commit the transaction. The
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> now has a check that will prevent this condition from
occurring, in addition to repairing the flush issue.</p>
<p>Additionally, scaled back part of the change made as part of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5226">#5226</a>
which can run autoflush during an unexpire operation, to not actually
do this in the case of a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> using legacy
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.params.autocommit" title="sqlalchemy.orm.Session"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.autocommit</span></code></a> mode, as this incurs a commit within
a refresh operation.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6233">#6233</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.7-3"><span class="target" id="change-897490105a82435201a18d53d10bc7ef"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-897490105a82435201a18d53d10bc7ef">¶</a></span><p>Fixed regression where the ORM compilation scheme would assume the function
name of a hybrid property would be the same as the attribute name in such a
way that an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> would be raised, when it would attempt to
determine the correct name for each element in a result tuple. A similar
issue exists in 1.3 but only impacts the names of tuple rows. The fix here
adds a check that the hybrid’s function name is actually present in the
<code class="docutils literal notranslate"><span class="pre">__dict__</span></code> of the class or its superclasses before assigning this name;
otherwise, the hybrid is considered to be “unnamed” and ORM result tuples
will use the naming scheme of the underlying expression.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6215">#6215</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.7-4"><span class="target" id="change-f85dccf7855902af81b6fdada9764f44"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f85dccf7855902af81b6fdada9764f44">¶</a></span><p>Fixed critical regression caused by the new feature added as part of
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1763">#1763</a>, eager loaders are invoked on unexpire operations. The new
feature makes use of the “immediateload” eager loader strategy as a
substitute for a collection loading strategy, which unlike the other
“post-load” strategies was not accommodating for recursive invocations
between mutually-dependent relationships, leading to recursion overflow
errors.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6232">#6232</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.7-engine">
<h3>engine<a class="headerlink" href="#change-1.4.7-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.7-5"><span class="target" id="change-23b812477c7ab29dfe6cd58cced58700"><strong>[engine] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-23b812477c7ab29dfe6cd58cced58700">¶</a></span><p>Fixed up the behavior of the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> object when dictionary
access is used upon it, meaning converting to a dict via <code class="docutils literal notranslate"><span class="pre">dict(row)</span></code> or
accessing members using strings or other objects i.e. <code class="docutils literal notranslate"><span class="pre">row[&quot;some_key&quot;]</span></code>
works as it would with a dictionary, rather than raising <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> as
would be the case with a tuple, whether or not the C extensions are in
place. This was originally supposed to emit a 2.0 deprecation warning for
the “non-future” case using <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a>, and was to raise
<code class="docutils literal notranslate"><span class="pre">TypeError</span></code> for the “future” <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> class. However, the C
version of <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> was failing to raise this <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>,
and to complicate matters, the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> method now
returns <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> in all cases to maintain consistency with the
ORM result case, so users who didn’t have C extensions installed would
see different behavior in this one case for existing pre-1.4 style
code.</p>
<p>Therefore, in order to soften the overall upgrade scheme as most users have
not been exposed to the more strict behavior of <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> up
through 1.4.6, <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a> and <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> both
provide for string-key access as well as support for <code class="docutils literal notranslate"><span class="pre">dict(row)</span></code>, in all
cases emitting the 2.0 deprecation warning when <code class="docutils literal notranslate"><span class="pre">SQLALCHEMY_WARN_20</span></code> is
enabled. The <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> object still uses tuple-like behavior for
<code class="docutils literal notranslate"><span class="pre">__contains__</span></code>, which is probably the only noticeable behavioral change
compared to <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a>, other than the removal of
dictionary-style methods <code class="docutils literal notranslate"><span class="pre">values()</span></code> and <code class="docutils literal notranslate"><span class="pre">items()</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6218">#6218</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.7-sql">
<h3>sql<a class="headerlink" href="#change-1.4.7-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.7-6"><span class="target" id="change-cd65baa507a6981df95d59b013edd692"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-cd65baa507a6981df95d59b013edd692">¶</a></span><p>Enhanced the “expanding” feature used for <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_" title="sqlalchemy.sql.expression.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.in_()</span></code></a>
operations to infer the type of expression from the right hand list of
elements, if the left hand side does not have any explicit type set up.
This allows the expression to support stringification among other things.
In 1.3, “expanding” was not automatically used for
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_" title="sqlalchemy.sql.expression.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.in_()</span></code></a> expressions, so in that sense this change
fixes a behavioral regression.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6222">#6222</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.7-7"><span class="target" id="change-cf61fa9612374a8b80f54d1812857284"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-cf61fa9612374a8b80f54d1812857284">¶</a></span><p>Fixed the “stringify” compiler to support a basic stringification
of a “multirow” INSERT statement, i.e. one with multiple tuples
following the VALUES keyword.</p>
<p></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.7-schema">
<h3>schema<a class="headerlink" href="#change-1.4.7-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.7-8"><span class="target" id="change-eda4d34e49f87cc7ecf359b9e08f4235"><strong>[schema] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-eda4d34e49f87cc7ecf359b9e08f4235">¶</a></span><p>Fixed regression where usage of a token in the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Connection.execution_options.schema_translate_map</span></code></a>
dictionary which contained special characters such as braces would fail to
be substituted properly. Use of square bracket characters <code class="docutils literal notranslate"><span class="pre">[]</span></code> is now
explicitly disallowed as these are used as a delimiter character in the
current implementation.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6216">#6216</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.7-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.7-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.7-9"><span class="target" id="change-376029703e33e28ac7558c8210cd47ae"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-376029703e33e28ac7558c8210cd47ae">¶</a></span><p>Fixed issue in Mypy plugin where the plugin wasn’t inferring the correct
type for columns of subclasses that don’t directly descend from
<code class="docutils literal notranslate"><span class="pre">TypeEngine</span></code>, in particular that of  <code class="docutils literal notranslate"><span class="pre">TypeDecorator</span></code> and
<code class="docutils literal notranslate"><span class="pre">UserDefinedType</span></code>.</p>
<p></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.7-misc">
<h3>misc<a class="headerlink" href="#change-1.4.7-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.7-10"><span class="target" id="change-acb9059278e48bf60aa9c20889b4f1bd"><strong>[change] [tests]</strong> <a class="changelog-reference headerlink reference internal" href="#change-acb9059278e48bf60aa9c20889b4f1bd">¶</a></span><p>Added a new flag to <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.default.DefaultDialect" title="sqlalchemy.engine.default.DefaultDialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefaultDialect</span></code></a> called <code class="docutils literal notranslate"><span class="pre">supports_schemas</span></code>;
third party dialects may set this flag to <code class="docutils literal notranslate"><span class="pre">False</span></code> to disable SQLAlchemy’s
schema-level tests when running the test suite for a third party dialect.</p>
<p></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.6">
<h2 class="release-version">1.4.6<a class="headerlink" href="#change-1.4.6" title="Permalink to this headline">¶</a></h2>
Released: April 6, 2021<section id="change-1.4.6-orm">
<h3>orm<a class="headerlink" href="#change-1.4.6-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.6-0"><span class="target" id="change-7a735957b3977c6848fd56e9b85f6e50"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7a735957b3977c6848fd56e9b85f6e50">¶</a></span><p>Fixed regression where a deprecated form of <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> were
used, passing a series of entities to join from without any ON clause in a
single <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> call, would fail to function correctly.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6203">#6203</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.6-1"><span class="target" id="change-c35af6377ae0b844729f99381ddd5996"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c35af6377ae0b844729f99381ddd5996">¶</a></span><p>Fixed critical regression where the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.yield_per" title="sqlalchemy.orm.Query.yield_per"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.yield_per()</span></code></a> method in
the ORM would set up the internal <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> to yield chunks
at a time, however made use of the new <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.unique" title="sqlalchemy.engine.Result.unique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.unique()</span></code></a> method
which uniques across the entire result. This would lead to lost rows since
the ORM is using <code class="docutils literal notranslate"><span class="pre">id(obj)</span></code> as the uniquing function, which leads to
repeated identifiers for new objects as already-seen objects are garbage
collected. 1.3’s behavior here was to “unique” across each chunk, which
does not actually produce “uniqued” results when results are yielded in
chunks. As the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.yield_per" title="sqlalchemy.orm.Query.yield_per"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.yield_per()</span></code></a> method is already explicitly
disallowed when joined eager loading is in place, which is the primary
rationale for the “uniquing” feature, the “uniquing” feature is now turned
off entirely when <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.yield_per" title="sqlalchemy.orm.Query.yield_per"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.yield_per()</span></code></a> is used.</p>
<p>This regression only applies to the legacy <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object; when
using <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> execution, “uniquing” is not automatically applied.
To prevent the issue from arising from explicit use of
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.unique" title="sqlalchemy.engine.Result.unique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.unique()</span></code></a>, an error is now raised if rows are fetched
from a “uniqued” ORM-level <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> if any
<a class="reference internal" href="../orm/queryguide.html#orm-queryguide-yield-per"><span class="std std-ref">yield per</span></a> API is also in use, as the
purpose of <code class="docutils literal notranslate"><span class="pre">yield_per</span></code> is to allow for arbitrarily large numbers of rows,
which cannot be uniqued in memory without growing the number of entries to
fit the complete result size.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6206">#6206</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.6-sql">
<h3>sql<a class="headerlink" href="#change-1.4.6-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.6-2"><span class="target" id="change-a190cecea721ab24edf35f7a1562d2ef"><strong>[sql] [bug] [mssql] [oracle] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a190cecea721ab24edf35f7a1562d2ef">¶</a></span><p>Fixed further regressions in the same area as that of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6173">#6173</a> released in
1.4.5, where a “postcompile” parameter, again most typically those used for
LIMIT/OFFSET rendering in Oracle and SQL Server, would fail to be processed
correctly if the same parameter rendered in multiple places in the
statement.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6202">#6202</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.6-3"><span class="target" id="change-0b0312c190c7b291e61b9c03f47e4d91"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0b0312c190c7b291e61b9c03f47e4d91">¶</a></span><p>Executing a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> using <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a>
is deprecated and will emit a deprecation warning; this use case was an
oversight that should have been removed from 1.4. The operation will now
execute the underlying <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object directly for backwards
compatibility. Similarly, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> class is also not
appropriate for execution. In 1.3, attempting to execute a CTE would result
in an invalid “blank” SQL statement being executed; since this use case was
not working it now raises <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.ObjectNotExecutableError" title="sqlalchemy.exc.ObjectNotExecutableError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ObjectNotExecutableError</span></code></a>.
Previously, 1.4 was attempting to execute the CTE as a statement however it
was working only erratically.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6204">#6204</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.6-schema">
<h3>schema<a class="headerlink" href="#change-1.4.6-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.6-4"><span class="target" id="change-7f5782877b73d16130d631c855ce5497"><strong>[schema] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7f5782877b73d16130d631c855ce5497">¶</a></span><p>The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object now raises an informative error message if
it is instantiated without passing at least the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.name" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.name</span></code></a>
and <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.metadata" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.metadata</span></code></a> arguments positionally. Previously, if
these were passed as keyword arguments, the object would silently fail to
initialize correctly.</p>
<p>This change is also <strong>backported</strong> to: 1.3.25</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6135">#6135</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.6-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.6-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.6-5"><span class="target" id="change-c9d1ae0bc5be45b8807a362d7638fd21"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c9d1ae0bc5be45b8807a362d7638fd21">¶</a></span><p>Applied a series of refactorings and fixes to accommodate for Mypy
“incremental” mode across multiple files, which previously was not taken
into account. In this mode the Mypy plugin has to accommodate Python
datatypes expressed in other files coming in with less information than
they have on a direct run.</p>
<p>Additionally, a new decorator <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declarative_mixin" title="sqlalchemy.orm.declarative_mixin"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_mixin()</span></code></a> is added,
which is necessary for the Mypy plugin to be able to definifitely identify
a Declarative mixin class that is otherwise not used inside a particular
Python file.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/extensions/mypy.html#mypy-declarative-mixins"><span class="std std-ref">Using &#64;declared_attr and Declarative Mixins</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6147">#6147</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.6-6"><span class="target" id="change-18b835e164d14c70a87f972061b043fe"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-18b835e164d14c70a87f972061b043fe">¶</a></span><p>Fixed issue where the Mypy plugin would fail to interpret the
“collection_class” of a relationship if it were a callable and not a class.
Also improved type matching and error reporting for collection-oriented
relationships.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6205">#6205</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.6-asyncio">
<h3>asyncio<a class="headerlink" href="#change-1.4.6-asyncio" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.6-7"><span class="target" id="change-23a0257a86ccc996fa797a446f07de6c"><strong>[asyncio] [usecase] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-23a0257a86ccc996fa797a446f07de6c">¶</a></span><p>Added accessors <code class="docutils literal notranslate"><span class="pre">.sqlstate</span></code> and synonym <code class="docutils literal notranslate"><span class="pre">.pgcode</span></code> to the <code class="docutils literal notranslate"><span class="pre">.orig</span></code>
attribute of the SQLAlchemy exception class raised by the asyncpg DBAPI
adapter, that is, the intermediary exception object that wraps on top of
that raised by the asyncpg library itself, but below the level of the
SQLAlchemy dialect.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6199">#6199</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.5">
<h2 class="release-version">1.4.5<a class="headerlink" href="#change-1.4.5" title="Permalink to this headline">¶</a></h2>
Released: April 2, 2021<section id="change-1.4.5-orm">
<h3>orm<a class="headerlink" href="#change-1.4.5-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-0"><span class="target" id="change-9c864f0cedb47b654f9befab4882df99"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9c864f0cedb47b654f9befab4882df99">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> loader strategy would
not successfully joinedload to a mapper that is mapper against a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> construct.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6172">#6172</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.5-1"><span class="target" id="change-365bc21feb65cfc39d9bb67778ea6230"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-365bc21feb65cfc39d9bb67778ea6230">¶</a></span><p>Scaled back the warning message added in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5171">#5171</a> to not warn for
overlapping columns in an inheritance scenario where a particular
relationship is local to a subclass and therefore does not represent an
overlap.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6171">#6171</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.5-sql">
<h3>sql<a class="headerlink" href="#change-1.4.5-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-2"><span class="target" id="change-a9a767c79ebcb0e4bfb34de22370320e"><strong>[sql] [bug] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a9a767c79ebcb0e4bfb34de22370320e">¶</a></span><p>Fixed bug in new <code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.render_derived()</span></code> feature
where column names rendered out explicitly in the alias SQL would not have
proper quoting applied for case sensitive names and other non-alphanumeric
names.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6183">#6183</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.5-3"><span class="target" id="change-f57fd5087b0d09d8ee7cd68cfb4e127a"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f57fd5087b0d09d8ee7cd68cfb4e127a">¶</a></span><p>Fixed regression where use of the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.in_()</span></code> method with a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object against a non-table-bound column would produce
an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>, or more generally using a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect" title="sqlalchemy.sql.expression.ScalarSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarSelect</span></code></a>
that has no datatype in a binary expression would produce invalid state.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6181">#6181</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.5-4"><span class="target" id="change-c2d7d8b0f49a391154c1d7c5d16b7094"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c2d7d8b0f49a391154c1d7c5d16b7094">¶</a></span><p>Added a new flag to the <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a> class called
<a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache" title="sqlalchemy.engine.Dialect.supports_statement_cache"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Dialect.supports_statement_cache</span></code></a>. This flag now needs to be present
directly on a dialect class in order for SQLAlchemy’s
<a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">query cache</span></a> to take effect for that dialect. The
rationale is based on discovered issues such as <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6173">#6173</a> revealing
that dialects which hardcode literal values from the compiled statement,
often the numerical parameters used for LIMIT / OFFSET, will not be
compatible with caching until these dialects are revised to use the
parameters present in the statement only. For third party dialects where
this flag is not applied, the SQL logging will show the message “dialect
does not support caching”, indicating the dialect should seek to apply this
flag once they have verified that no per-statement literal values are being
rendered within the compilation phase.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#engine-thirdparty-caching"><span class="std std-ref">Caching for Third Party Dialects</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6184">#6184</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.5-schema">
<h3>schema<a class="headerlink" href="#change-1.4.5-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-5"><span class="target" id="change-dc7948c973a07693a84c546aed858087"><strong>[schema] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-dc7948c973a07693a84c546aed858087">¶</a></span><p>Introduce a new parameter <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.omit_aliases" title="sqlalchemy.types.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.omit_aliases</span></code></a> in
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a> type allow filtering aliases when using a pep435 Enum.
Previous versions of SQLAlchemy kept aliases in all cases, creating
database enum type with additional states, meaning that they were treated
as different values in the db. For backward compatibility this flag
defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code> in the 1.4 series, but will be switched to <code class="docutils literal notranslate"><span class="pre">True</span></code>
in a future version. A deprecation warning is raise if this flag is not
specified and the passed enum contains aliases.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6146">#6146</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.5-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.5-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-6"><span class="target" id="change-4268f7ce47eddf26d1de81ebb443cc3b"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4268f7ce47eddf26d1de81ebb443cc3b">¶</a></span><p>Fixed issue in mypy plugin where newly added support for
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.as_declarative" title="sqlalchemy.orm.as_declarative"><code class="xref py py-func docutils literal notranslate"><span class="pre">as_declarative()</span></code></a> needed to more fully add the
<code class="docutils literal notranslate"><span class="pre">DeclarativeMeta</span></code> class to the mypy interpreter’s state so that it does
not result in a name not found error; additionally improves how global
names are setup for the plugin including the <code class="docutils literal notranslate"><span class="pre">Mapped</span></code> name.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/sqlalchemy/sqlalchemy2-stubs/#14">#sqlalchemy/sqlalchemy2-stubs/#14</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.5-asyncio">
<h3>asyncio<a class="headerlink" href="#change-1.4.5-asyncio" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-7"><span class="target" id="change-b75492ddd751588d0001e5986041ee2a"><strong>[asyncio] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b75492ddd751588d0001e5986041ee2a">¶</a></span><p>Fixed issue where the asyncio extension could not be loaded
if running Python 3.6 with the backport library of
<code class="docutils literal notranslate"><span class="pre">contextvars</span></code> installed.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6166">#6166</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.5-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.5-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-8"><span class="target" id="change-8f7db0ebbcbc87c0ff648402bc7cd8d2"><strong>[postgresql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8f7db0ebbcbc87c0ff648402bc7cd8d2">¶</a></span><p>Fixed regression caused by <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6023">#6023</a> where the PostgreSQL cast
operator applied to elements within an <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> when using
psycopg2 would fail to use the correct type in the case that the datatype
were also embedded within an instance of the <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.Variant" title="sqlalchemy.types.Variant"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variant</span></code></a>
adapter.</p>
<p>Additionally, repairs support for the correct CREATE TYPE to be emitted
when using a <code class="docutils literal notranslate"><span class="pre">Variant(ARRAY(some_schema_type))</span></code>.</p>
<p>This change is also <strong>backported</strong> to: 1.3.25</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6182">#6182</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.5-9"><span class="target" id="change-9c778b98b4680f806939781a3e4e5fa5"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9c778b98b4680f806939781a3e4e5fa5">¶</a></span><p>Fixed typo in the fix for <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6099">#6099</a> released in 1.4.4 that completely
prevented this change from working correctly, i.e. the error message did not match
what was actually emitted by pg8000.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6099">#6099</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.5-10"><span class="target" id="change-19c3163e20acb002d8941adbc922b3b9"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-19c3163e20acb002d8941adbc922b3b9">¶</a></span><p>Fixed issue where the PostgreSQL <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector" title="sqlalchemy.dialects.postgresql.base.PGInspector"><code class="xref py py-class docutils literal notranslate"><span class="pre">PGInspector</span></code></a>, when generated
against an <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>, would fail for <code class="docutils literal notranslate"><span class="pre">.get_enums()</span></code>,
<code class="docutils literal notranslate"><span class="pre">.get_view_names()</span></code>, <code class="docutils literal notranslate"><span class="pre">.get_foreign_table_names()</span></code> and
<code class="docutils literal notranslate"><span class="pre">.get_table_oid()</span></code> when used against a “future” style engine and not the
connection directly.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6170">#6170</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.5-mysql">
<h3>mysql<a class="headerlink" href="#change-1.4.5-mysql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-11"><span class="target" id="change-1b89ffe66e9bea9693c1d99643cb6628"><strong>[mysql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-1b89ffe66e9bea9693c1d99643cb6628">¶</a></span><p>Fixed regression in the MySQL dialect where the reflection query used to
detect if a table exists would fail on very old MySQL 5.0 and 5.1 versions.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6163">#6163</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.5-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.5-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-12"><span class="target" id="change-2046359da8c16275b74ddeea2c407bf9"><strong>[mssql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2046359da8c16275b74ddeea2c407bf9">¶</a></span><p>Fixed a regression in MSSQL 2012+ that prevented the order by clause
to be rendered when <code class="docutils literal notranslate"><span class="pre">offset=0</span></code> is used in a subquery.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6163">#6163</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.5-oracle">
<h3>oracle<a class="headerlink" href="#change-1.4.5-oracle" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.5-13"><span class="target" id="change-43a0de18a589a343c34cd494bf7257bd"><strong>[oracle] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-43a0de18a589a343c34cd494bf7257bd">¶</a></span><p>Fixed critical regression where the Oracle compiler would not maintain the
correct parameter values in the LIMIT/OFFSET for a select due to a caching
issue.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6173">#6173</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.4">
<h2 class="release-version">1.4.4<a class="headerlink" href="#change-1.4.4" title="Permalink to this headline">¶</a></h2>
Released: March 30, 2021<section id="change-1.4.4-orm">
<h3>orm<a class="headerlink" href="#change-1.4.4-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.4-0"><span class="target" id="change-91f2865a667228b42a477704ade54ca8"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-91f2865a667228b42a477704ade54ca8">¶</a></span><p>Fixed critical issue in the new <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.PropComparator.and_" title="sqlalchemy.orm.PropComparator.and_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropComparator.and_()</span></code></a> feature
where loader strategies that emit secondary SELECT statements such as
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> and <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.lazyload" title="sqlalchemy.orm.lazyload"><code class="xref py py-func docutils literal notranslate"><span class="pre">lazyload()</span></code></a> would fail to
accommodate for bound parameters in the user-defined criteria in terms of
the current statement being executed, as opposed to the cached statement,
causing stale bound values to be used.</p>
<p>This also adds a warning for the case where an object that uses
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.lazyload" title="sqlalchemy.orm.lazyload"><code class="xref py py-func docutils literal notranslate"><span class="pre">lazyload()</span></code></a> in conjunction with <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.PropComparator.and_" title="sqlalchemy.orm.PropComparator.and_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropComparator.and_()</span></code></a>
is attempted to be serialized; the loader criteria cannot reliably
be serialized and deserialized and eager loading should be used for this
case.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6139">#6139</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.4-1"><span class="target" id="change-46cce51a8c23f9f4decabd7f79632ae6"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-46cce51a8c23f9f4decabd7f79632ae6">¶</a></span><p>Fixed missing method <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.get" title="sqlalchemy.orm.Session.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.get()</span></code></a> from the
<code class="xref py py-class docutils literal notranslate"><span class="pre">ScopedSession</span></code> interface.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6144">#6144</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.4-engine">
<h3>engine<a class="headerlink" href="#change-1.4.4-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.4-2"><span class="target" id="change-bd2f7f738a5a8a8def02917d55c3f80c"><strong>[engine] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-bd2f7f738a5a8a8def02917d55c3f80c">¶</a></span><p>Modified the context manager used by <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Transaction" title="sqlalchemy.engine.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a> so that
an “already detached” warning is not emitted by the ending of the context
manager itself, if the transaction were already manually rolled back inside
the block. This applies to regular transactions, savepoint transactions,
and legacy “marker” transactions. A warning is still emitted if the
<code class="docutils literal notranslate"><span class="pre">.rollback()</span></code> method is called explicitly more than once.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6155">#6155</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.4-3"><span class="target" id="change-1aa6fa207a703e5a113ec4886e954849"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-1aa6fa207a703e5a113ec4886e954849">¶</a></span><p>Repair wrong arguments to exception handling method
in CursorResult.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6138">#6138</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.4-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.4-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.4-4"><span class="target" id="change-7932fc6f56d5f5b0a89dc6d87bb7bf1d"><strong>[postgresql] [bug] [reflection]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7932fc6f56d5f5b0a89dc6d87bb7bf1d">¶</a></span><p>Fixed issue in PostgreSQL reflection where a column expressing “NOT NULL”
will supersede the nullability of a corresponding domain.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6161">#6161</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.4-5"><span class="target" id="change-2f2c13225b8f091d2e7393f4a719ebc5"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2f2c13225b8f091d2e7393f4a719ebc5">¶</a></span><p>Modified the <code class="docutils literal notranslate"><span class="pre">is_disconnect()</span></code> handler for the pg8000 dialect, which now
accommodates for a new <code class="docutils literal notranslate"><span class="pre">InterfaceError</span></code> emitted by pg8000 1.19.0. Pull
request courtesy Hamdi Burak Usul.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6099">#6099</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.4-misc">
<h3>misc<a class="headerlink" href="#change-1.4.4-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.4-6"><span class="target" id="change-28df5c3281b54873eac3c7b06c366cdc"><strong>[misc] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-28df5c3281b54873eac3c7b06c366cdc">¶</a></span><p>Adjusted the usage of the <code class="docutils literal notranslate"><span class="pre">importlib_metadata</span></code> library for loading
setuptools entrypoints in order to accommodate for some deprecation
changes.</p>
<p></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.3">
<h2 class="release-version">1.4.3<a class="headerlink" href="#change-1.4.3" title="Permalink to this headline">¶</a></h2>
Released: March 25, 2021<section id="change-1.4.3-orm">
<h3>orm<a class="headerlink" href="#change-1.4.3-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.3-0"><span class="target" id="change-7d3e5b3833756d340a44a041a451b0cf"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7d3e5b3833756d340a44a041a451b0cf">¶</a></span><p>Fixed a bug where python 2.7.5 (default on CentOS 7) wasn’t able to import
sqlalchemy, because on this version of Python <code class="docutils literal notranslate"><span class="pre">exec</span> <span class="pre">&quot;statement&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">exec(&quot;statement&quot;)</span></code> do not behave the same way.  The compatibility
<code class="docutils literal notranslate"><span class="pre">exec_()</span></code> function was used instead.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6069">#6069</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.3-1"><span class="target" id="change-3700c952d665216099ef916257c37584"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3700c952d665216099ef916257c37584">¶</a></span><p>Fixed bug where ORM queries using a correlated subquery in conjunction with
<a class="reference internal" href="../orm/mapping_columns.html#sqlalchemy.orm.column_property" title="sqlalchemy.orm.column_property"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code></a> would fail to correlate correctly to an
enclosing subquery or to a CTE when <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a>
were used in the property to control correlation, in cases where the
subquery contained the same selectables as ones within the correlated
subquery that were intended to not be correlated.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6060">#6060</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.3-2"><span class="target" id="change-29b027fa8623b049d835db99db01b242"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-29b027fa8623b049d835db99db01b242">¶</a></span><p>Fixed bug where combinations of the new “relationship with criteria”
feature could fail in conjunction with features that make use of the new
“lambda SQL” feature, including loader strategies such as selectinload and
lazyload, for more complicated scenarios such as polymorphic loading.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6131">#6131</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.3-3"><span class="target" id="change-47d6578963c4386df96fcbfb87dd51e5"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-47d6578963c4386df96fcbfb87dd51e5">¶</a></span><p>Repaired support so that the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ClauseElement.params" title="sqlalchemy.sql.expression.ClauseElement.params"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ClauseElement.params()</span></code></a> method can
work correctly with a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object that includes joins
across ORM relationship structures, which is a new feature in 1.4.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6124">#6124</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.3-4"><span class="target" id="change-251691305b3c10d96fc9be8f4744407b"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-251691305b3c10d96fc9be8f4744407b">¶</a></span><p>Fixed issue where a “removed in 2.0” warning were generated internally by
the relationship loader mechanics.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6115">#6115</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.3-orm-declarative">
<h3>orm declarative<a class="headerlink" href="#change-1.4.3-orm-declarative" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.3-5"><span class="target" id="change-81dd129c9320cd0848ddae2c4727838b"><strong>[orm] [declarative] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-81dd129c9320cd0848ddae2c4727838b">¶</a></span><p>Fixed regression where the <code class="docutils literal notranslate"><span class="pre">.metadata</span></code> attribute on a per class level
would not be honored, breaking the use case of per-class-hierarchy
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> for abstract declarative classes and mixins.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/declarative_config.html#declarative-metadata"><span class="std std-ref">metadata</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6128">#6128</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.3-engine">
<h3>engine<a class="headerlink" href="#change-1.4.3-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.3-6"><span class="target" id="change-d4109de7b4e085474d8376a7b4fb31a1"><strong>[engine] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d4109de7b4e085474d8376a7b4fb31a1">¶</a></span><p>Restored the <code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code> name back to the
<code class="docutils literal notranslate"><span class="pre">sqlalchemy.engine</span></code> namespace. This name refers to the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyCursorResult" title="sqlalchemy.engine.LegacyCursorResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyCursorResult</span></code></a> object.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6119">#6119</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.3-schema">
<h3>schema<a class="headerlink" href="#change-1.4.3-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.3-7"><span class="target" id="change-9d54a1748de981f506a6c1ae3db29a46"><strong>[schema] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9d54a1748de981f506a6c1ae3db29a46">¶</a></span><p>Adjusted the logic that emits DROP statements for <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>
objects among the dropping of multiple tables, such that all
<a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> objects are dropped after all tables, even if the
given <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> is related only to a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
object and not directly to the overall <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object.
The use case supports the same <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> being associated
with more than one <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> at a time.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6071">#6071</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.3-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.3-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.3-8"><span class="target" id="change-369675269c7477f4ed40aeb0565771db"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-369675269c7477f4ed40aeb0565771db">¶</a></span><p>Added support for the Mypy extension to correctly interpret a declarative
base class that’s generated using the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.as_declarative" title="sqlalchemy.orm.as_declarative"><code class="xref py py-func docutils literal notranslate"><span class="pre">as_declarative()</span></code></a> function
as well as the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.as_declarative_base" title="sqlalchemy.orm.registry.as_declarative_base"><code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.as_declarative_base()</span></code></a> method.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.3-9"><span class="target" id="change-a6b3de8f17e8bec170f7716cac95c8d7"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a6b3de8f17e8bec170f7716cac95c8d7">¶</a></span><p>Fixed bug in Mypy plugin where the Python type detection
for the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Boolean" title="sqlalchemy.types.Boolean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Boolean</span></code></a> column type would produce
an exception; additionally implemented support for <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>,
including detection of a string-based enum vs. use of Python <code class="docutils literal notranslate"><span class="pre">enum.Enum</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6109">#6109</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.3-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.3-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.3-10"><span class="target" id="change-ee903343a097a62d99e0045ef3e85c91"><strong>[postgresql] [bug] [types]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ee903343a097a62d99e0045ef3e85c91">¶</a></span><p>Adjusted the psycopg2 dialect to emit an explicit PostgreSQL-style cast for
bound parameters that contain ARRAY elements. This allows the full range of
datatypes to function correctly within arrays. The asyncpg dialect already
generated these internal casts in the final statement. This also includes
support for array slice updates as well as the PostgreSQL-specific
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ARRAY.contains()</span></code> method.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6023">#6023</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.3-11"><span class="target" id="change-ca6bb49de13fb87aa6a551d146a230ac"><strong>[postgresql] [bug] [reflection]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ca6bb49de13fb87aa6a551d146a230ac">¶</a></span><p>Fixed reflection of identity columns in tables with mixed case names
in PostgreSQL.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6129">#6129</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.3-sqlite">
<h3>sqlite<a class="headerlink" href="#change-1.4.3-sqlite" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.3-12"><span class="target" id="change-9de355a3510108c1e0e5c6de64ebafc7"><strong>[sqlite] [feature] [asyncio]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9de355a3510108c1e0e5c6de64ebafc7">¶</a></span><p>Added support for the aiosqlite database driver for use with the
SQLAlchemy asyncio extension.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/sqlite.html#aiosqlite"><span class="std std-ref">Aiosqlite</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5920">#5920</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.3-13"><span class="target" id="change-0e9d903a60892ce28f8bad81ec7afeaa"><strong>[sqlite] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0e9d903a60892ce28f8bad81ec7afeaa">¶</a></span><p>Repaired the <code class="docutils literal notranslate"><span class="pre">pysqlcipher</span></code> dialect to connect correctly which had
regressed in 1.4, and added test + CI support to maintain the driver
in working condition.  The dialect now imports the <code class="docutils literal notranslate"><span class="pre">sqlcipher3</span></code> module
for Python 3 by default before falling back to <code class="docutils literal notranslate"><span class="pre">pysqlcipher3</span></code> which
is documented as now being unmaintained.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/sqlite.html#pysqlcipher"><span class="std std-ref">Pysqlcipher</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5848">#5848</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.2">
<h2 class="release-version">1.4.2<a class="headerlink" href="#change-1.4.2" title="Permalink to this headline">¶</a></h2>
Released: March 19, 2021<section id="change-1.4.2-orm">
<h3>orm<a class="headerlink" href="#change-1.4.2-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.2-0"><span class="target" id="change-2453c5928361d9f61996e0829319306a"><strong>[orm] [usecase] [dataclasses]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2453c5928361d9f61996e0829319306a">¶</a></span><p>Added support for the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declared_attr" title="sqlalchemy.orm.declared_attr"><code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code></a> object to work in the
context of dataclass fields.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/mapping_styles.html#orm-declarative-dataclasses-mixin"><span class="std std-ref">Using Declarative Mixins with Dataclasses</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6100">#6100</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.2-1"><span class="target" id="change-5d3e43f809cc76a8a757ef7c59f6a002"><strong>[orm] [bug] [dataclasses]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5d3e43f809cc76a8a757ef7c59f6a002">¶</a></span><p>Fixed issue in new ORM dataclasses functionality where dataclass fields on
an abstract base or mixin that contained column or other mapping constructs
would not be mapped if they also included a “default” key within the
dataclasses.field() object.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6093">#6093</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.2-2"><span class="target" id="change-9917b16bf20c61a9a425d1b3508b4706"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9917b16bf20c61a9a425d1b3508b4706">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.selectable" title="sqlalchemy.orm.Query.selectable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Query.selectable</span></code></a> accessor, which is
a synonym for <code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.__clause_element__()</span></code>, got removed, it’s now
restored.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6088">#6088</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.2-3"><span class="target" id="change-215c0efba063b07b4b1e42cc4637b224"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-215c0efba063b07b4b1e42cc4637b224">¶</a></span><p>Fixed regression where use of an unnamed SQL expression such as a SQL
function would raise a column targeting error if the query itself were
using joinedload for an entity and was also being wrapped in a subquery by
the joinedload eager loading process.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6086">#6086</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.2-4"><span class="target" id="change-24023c48c548a956f379edb23951cda0"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-24023c48c548a956f379edb23951cda0">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.filter_by" title="sqlalchemy.orm.Query.filter_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.filter_by()</span></code></a> method would fail
to locate the correct source entity if the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> method
had been used targeting an entity without any kind of ON clause.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6092">#6092</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.2-5"><span class="target" id="change-90aafdde1a44a019398dc85215da3302"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-90aafdde1a44a019398dc85215da3302">¶</a></span><p>Fixed regression where the SQL compilation of a <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> would
not work correctly if the object had been “annotated”, which is an internal
memoization process used mostly by the ORM. In particular it could affect
ORM lazy loads which make greater use of this feature in 1.4.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6095">#6095</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.2-6"><span class="target" id="change-cdc0b1972cdf79000aacb0c95169849b"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-cdc0b1972cdf79000aacb0c95169849b">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase" title="sqlalchemy.ext.declarative.ConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteBase</span></code></a> would fail to map at all
when a mapped column name overlapped with the discriminator column name,
producing an assertion error. The use case here did not function correctly
in 1.3 as the polymorphic union would produce a query that ignored the
discriminator column entirely, while emitting duplicate column warnings. As
1.4’s architecture cannot easily reproduce this essentially broken behavior
of 1.3 at the <code class="docutils literal notranslate"><span class="pre">select()</span></code> level right now, the use case now raises an
informative error message instructing the user to use the
<code class="docutils literal notranslate"><span class="pre">.ConcreteBase._concrete_discriminator_name</span></code> attribute to resolve the
conflict. To assist with this configuration,
<code class="docutils literal notranslate"><span class="pre">.ConcreteBase._concrete_discriminator_name</span></code> may be placed on the base
class only where it will be automatically used by subclasses; previously
this was not the case.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6090">#6090</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.2-engine">
<h3>engine<a class="headerlink" href="#change-1.4.2-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.2-7"><span class="target" id="change-863c116f799e36414eb3dd783215d3d9"><strong>[engine] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-863c116f799e36414eb3dd783215d3d9">¶</a></span><p>Restored top level import for <code class="docutils literal notranslate"><span class="pre">sqlalchemy.engine.reflection</span></code>. This
ensures that the base <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector" title="sqlalchemy.engine.reflection.Inspector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code></a> class is properly
registered so that <a class="reference internal" href="../core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a> works for third party dialects that
don’t otherwise import this package.</p>
<p></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.2-sql">
<h3>sql<a class="headerlink" href="#change-1.4.2-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.2-8"><span class="target" id="change-d3e0ec0afd161a7a61ab2a5403505624"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d3e0ec0afd161a7a61ab2a5403505624">¶</a></span><p>Fixed issue where using a <code class="docutils literal notranslate"><span class="pre">func</span></code> that includes dotted packagenames would
fail to be cacheable by the SQL caching system due to a Python list of
names that needed to be a tuple.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6101">#6101</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.2-9"><span class="target" id="change-396553a78676fd74b65449f89de8dbc0"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-396553a78676fd74b65449f89de8dbc0">¶</a></span><p>Fixed regression in the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.case" title="sqlalchemy.sql.expression.case"><code class="xref py py-func docutils literal notranslate"><span class="pre">case()</span></code></a> construct, where the “dictionary”
form of argument specification failed to work correctly if it were passed
positionally, rather than as a “whens” keyword argument.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6097">#6097</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.2-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.2-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.2-10"><span class="target" id="change-c30945aa0a9aaebcecb15d33c79c00f3"><strong>[mypy] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c30945aa0a9aaebcecb15d33c79c00f3">¶</a></span><p>Fixed issue in MyPy extension which crashed on detecting the type of a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> if the type were given with a module prefix like
<code class="docutils literal notranslate"><span class="pre">sa.Integer()</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/sqlalchemy/sqlalchemy2-stubs/2">#sqlalchemy/sqlalchemy2-stubs/2</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.2-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.2-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.2-11"><span class="target" id="change-9158b0d5e5420ad3d089e15f9bd57e95"><strong>[postgresql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9158b0d5e5420ad3d089e15f9bd57e95">¶</a></span><p>Rename the column name used by a reflection query that used
a reserved word in some postgresql compatible databases.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6982">#6982</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.1">
<h2 class="release-version">1.4.1<a class="headerlink" href="#change-1.4.1" title="Permalink to this headline">¶</a></h2>
Released: March 17, 2021<section id="change-1.4.1-orm">
<h3>orm<a class="headerlink" href="#change-1.4.1-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.1-0"><span class="target" id="change-d583e32983678010f0173c30c745f874"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d583e32983678010f0173c30c745f874">¶</a></span><p>Fixed regression where producing a Core expression construct such as
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> using ORM entities would eagerly configure the mappers,
in an effort to maintain compatibility with the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object
which necessarily does this to support many backref-related legacy cases.
However, core <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> constructs are also used in mapper
configurations and such, and to that degree this eager configuration is
more of an inconvenience, so eager configure has been disabled for the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> and other Core constructs in the absence of ORM loading
types of functions such as <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.Load" title="sqlalchemy.orm.Load"><code class="xref py py-class docutils literal notranslate"><span class="pre">Load</span></code></a>.</p>
<p>The change maintains the behavior of <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> so that backwards
compatibility is maintained. However, when using a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> in
conjunction with ORM entities, a “backref” that isn’t explicitly placed on
one of the classes until mapper configure time won’t be available unless
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal notranslate"><span class="pre">configure_mappers()</span></code></a> or the newer <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.configure" title="sqlalchemy.orm.registry.configure"><code class="xref py py-func docutils literal notranslate"><span class="pre">configure()</span></code></a>
has been called elsewhere. Prefer using
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a> for more explicit relationship
configuration which does not have the eager configure requirement.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6066">#6066</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.1-1"><span class="target" id="change-9a3ddf85025e0eb85d9496805cf22057"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9a3ddf85025e0eb85d9496805cf22057">¶</a></span><p>Fixed a critical regression in the relationship lazy loader where the SQL
criteria used to fetch a related many-to-one object could go stale in
relation to other memoized structures within the loader if the mapper had
configuration changes, such as can occur when mappers are late configured
or configured on demand, producing a comparison to None and returning no
object. Huge thanks to Alan Hamlett for their help tracking this down late
into the night.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6055">#6055</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.1-2"><span class="target" id="change-caa3e523760cee2d09619a1e3d8c89d5"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-caa3e523760cee2d09619a1e3d8c89d5">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.exists" title="sqlalchemy.orm.Query.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.exists()</span></code></a> method would fail to
create an expression if the entity list of the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> were
an arbitrary SQL column expression.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6076">#6076</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.1-3"><span class="target" id="change-b50e42253df6cbbb2ce797c69ef5aa1a"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b50e42253df6cbbb2ce797c69ef5aa1a">¶</a></span><p>Fixed regression where calling upon <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.count" title="sqlalchemy.orm.Query.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.count()</span></code></a> in conjunction
with a loader option such as <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> would fail to ignore
the loader option. This is a behavior that has always been very specific to
the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.count" title="sqlalchemy.orm.Query.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.count()</span></code></a> method; an error is normally raised if a given
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> has options that don’t apply to what it is returning.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6052">#6052</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.1-4"><span class="target" id="change-cd684043e4816c6181501efb062d6207"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-cd684043e4816c6181501efb062d6207">¶</a></span><p>Fixed regression in <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.identity_key" title="sqlalchemy.orm.Session.identity_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.identity_key()</span></code></a>, including that the
method and related methods were not covered by any unit test as well as
that the method contained a typo preventing it from functioning correctly.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6067">#6067</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.1-orm-declarative">
<h3>orm declarative<a class="headerlink" href="#change-1.4.1-orm-declarative" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.1-5"><span class="target" id="change-66d3a0e884fde905ca469edda1fc9542"><strong>[orm] [declarative] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-66d3a0e884fde905ca469edda1fc9542">¶</a></span><p>Fixed bug where user-mapped classes that contained an attribute named
“registry” would cause conflicts with the new registry-based mapping system
when using <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeMeta</span></code>. While the attribute remains
something that can be set explicitly on a declarative base to be
consumed by the metaclass, once located it is placed under a private
class variable so it does not conflict with future subclasses that use
the same name for other purposes.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6054">#6054</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.1-engine">
<h3>engine<a class="headerlink" href="#change-1.4.1-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.1-6"><span class="target" id="change-f5fa3ea3974c26ba4e03e763e8baea85"><strong>[engine] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f5fa3ea3974c26ba4e03e763e8baea85">¶</a></span><p>The Python <code class="docutils literal notranslate"><span class="pre">namedtuple()</span></code> has the behavior such that the names <code class="docutils literal notranslate"><span class="pre">count</span></code>
and <code class="docutils literal notranslate"><span class="pre">index</span></code> will be served as tuple values if the named tuple includes
those names; if they are absent, then their behavior as methods of
<code class="docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code> is maintained. Therefore the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> and <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a> classes have been fixed
so that they work in this same way, maintaining the expected behavior for
database rows that have columns named “index” or “count”.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6074">#6074</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.1-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.1-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.1-7"><span class="target" id="change-cf34ce20a6e6e5c5efb3ed7ef1b857d5"><strong>[mssql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-cf34ce20a6e6e5c5efb3ed7ef1b857d5">¶</a></span><p>Fixed regression where a new setinputsizes() API that’s available for
pyodbc was enabled, which is apparently incompatible with pyodbc’s
fast_executemany() mode in the absence of more accurate typing information,
which as of yet is not fully implemented or tested. The pyodbc dialect and
connector has been modified so that setinputsizes() is not used at all
unless the parameter <code class="docutils literal notranslate"><span class="pre">use_setinputsizes</span></code> is passed to the dialect, e.g.
via <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>, at which point its behavior can be
customized using the <a class="reference internal" href="../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes" title="sqlalchemy.events.DialectEvents.do_setinputsizes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DialectEvents.do_setinputsizes()</span></code></a> hook.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/mssql.html#mssql-pyodbc-setinputsizes"><span class="std std-ref">Setinputsizes Support</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6058">#6058</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.1-misc">
<h3>misc<a class="headerlink" href="#change-1.4.1-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.1-8"><span class="target" id="change-2ece43068e5ea7aef38ef069da0f3818"><strong>[bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2ece43068e5ea7aef38ef069da0f3818">¶</a></span><p>Added back <code class="docutils literal notranslate"><span class="pre">items</span></code> and <code class="docutils literal notranslate"><span class="pre">values</span></code> to <code class="docutils literal notranslate"><span class="pre">ColumnCollection</span></code> class.
The regression was introduced while adding support for duplicate
columns in from clauses and selectable in ticket #4753.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6068">#6068</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.0">
<h2 class="release-version">1.4.0<a class="headerlink" href="#change-1.4.0" title="Permalink to this headline">¶</a></h2>
Released: March 15, 2021<section id="change-1.4.0-orm">
<h3>orm<a class="headerlink" href="#change-1.4.0-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0-0"><span class="target" id="change-6be181e40cd6ad87f2a10c1bd352e12f"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6be181e40cd6ad87f2a10c1bd352e12f">¶</a></span><p>Removed very old warning that states that passive_deletes is not intended
for many-to-one relationships. While it is likely that in many cases
placing this parameter on a many-to-one relationship is not what was
intended, there are use cases where delete cascade may want to be
disallowed following from such a relationship.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5983">#5983</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-1"><span class="target" id="change-5b6ec011806327f1fbde3d233ecf59e0"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5b6ec011806327f1fbde3d233ecf59e0">¶</a></span><p>Fixed issue where the process of joining two tables could fail if one of
the tables had an unrelated, unresolvable foreign key constraint which
would raise <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.NoReferenceError" title="sqlalchemy.exc.NoReferenceError"><code class="xref py py-class docutils literal notranslate"><span class="pre">NoReferenceError</span></code></a> within the join process, which
nonetheless could be bypassed to allow the join to complete. The logic
which tested the exception for significance within the process would make
assumptions about the construct which would fail.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5952">#5952</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-2"><span class="target" id="change-55b7b25d0a7444287b3f53cedf4ab935"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-55b7b25d0a7444287b3f53cedf4ab935">¶</a></span><p>Fixed issue where the <a class="reference internal" href="../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite" title="sqlalchemy.ext.mutable.MutableComposite"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableComposite</span></code></a> construct could be
placed into an invalid state when the parent object was already loaded, and
then covered by a subsequent query, due to the composite properties’
refresh handler replacing the object with a new one not handled by the
mutable extension.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6001">#6001</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-3"><span class="target" id="change-f594317b88899f72a3575dce87a195fe"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f594317b88899f72a3575dce87a195fe">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.query_class" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.query_class</span></code></a>
parameter stopped being functional for “dynamic” relationships.  The
<code class="docutils literal notranslate"><span class="pre">AppenderQuery</span></code> remains dependent on the legacy <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
class; users are encouraged to migrate from the use of “dynamic”
relationships to using <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_parent" title="sqlalchemy.orm.with_parent"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_parent()</span></code></a> instead.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5981">#5981</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-4"><span class="target" id="change-e9ba08932995e7ede55dd7e207e229af"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e9ba08932995e7ede55dd7e207e229af">¶</a></span><p>Fixed regression where <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> would produce no effect if
the query itself as well as the join target were against a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object, rather than a mapped class. This was part of
a more systemic issue where the legacy ORM query compiler would not be
correctly used from a <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> if the statement produced had not
ORM entities present within it.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6003">#6003</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-5"><span class="target" id="change-a380be3661efe49958ae8a2771c61941"><strong>[orm] [bug] [asyncio]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a380be3661efe49958ae8a2771c61941">¶</a></span><p>The API for <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.delete" title="sqlalchemy.ext.asyncio.AsyncSession.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.delete()</span></code></a> is now an awaitable;
this method cascades along relationships which must be loaded in a
similar manner as the <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.merge" title="sqlalchemy.ext.asyncio.AsyncSession.merge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.merge()</span></code></a> method.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5998">#5998</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-6"><span class="target" id="change-144102834928263ad58ae4cd52849d53"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-144102834928263ad58ae4cd52849d53">¶</a></span><p>The unit of work process now turns off all “lazy=’raise’” behavior
altogether when a flush is proceeding.  While there are areas where the UOW
is sometimes loading things that aren’t ultimately needed, the lazy=”raise”
strategy is not helpful here as the user often does not have much control
or visibility into the flush process.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5984">#5984</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0-engine">
<h3>engine<a class="headerlink" href="#change-1.4.0-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0-7"><span class="target" id="change-639bb19b97ea36f5ab737ca51c917417"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-639bb19b97ea36f5ab737ca51c917417">¶</a></span><p>Fixed bug where the “schema_translate_map” feature failed to be taken into
account for the use case of direct execution of
<a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.DefaultGenerator" title="sqlalchemy.schema.DefaultGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefaultGenerator</span></code></a> objects such as sequences, which included
the case where they were “pre-executed” in order to generate primary key
values when implicit_returning was disabled.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5929">#5929</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-8"><span class="target" id="change-5c1f3cfaf55352c5b979e22b4d2a35a8"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5c1f3cfaf55352c5b979e22b4d2a35a8">¶</a></span><p>Improved engine logging to note ROLLBACK and COMMIT which is logged while
the DBAPI driver is in AUTOCOMMIT mode. These ROLLBACK/COMMIT are library
level and do not have any effect when AUTOCOMMIT is in effect, however it’s
still worthwhile to log as these indicate where SQLAlchemy sees the
“transaction” demarcation.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6002">#6002</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-9"><span class="target" id="change-42b8d7df7747e65613e7a9263bd96c52"><strong>[engine] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-42b8d7df7747e65613e7a9263bd96c52">¶</a></span><p>Fixed a regression where the “reset agent” of the connection pool wasn’t
really being utilized by the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> when it were
closed, and also leading to a double-rollback scenario that was somewhat
wasteful.   The newer architecture of the engine has been updated so that
the connection pool “reset-on-return” logic will be skipped when the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> explicitly closes out the transaction before
returning the pool to the connection.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6004">#6004</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0-sql">
<h3>sql<a class="headerlink" href="#change-1.4.0-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0-10"><span class="target" id="change-00b271c6a9bd726da5dad137328d6f2a"><strong>[sql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-00b271c6a9bd726da5dad137328d6f2a">¶</a></span><p>Altered the compilation for the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> construct so that a string is
returned representing the inner SELECT statement if the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> is
stringified directly, outside of the context of an enclosing SELECT; This
is the same behavior of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a> and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a>. Previously, a blank string would be
returned as the CTE is normally placed above a SELECT after that SELECT has
been generated, which is generally misleading when debugging.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-11"><span class="target" id="change-82b8efe8dcb1e055a06fdfa5d1fc3d0a"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-82b8efe8dcb1e055a06fdfa5d1fc3d0a">¶</a></span><p>Fixed bug where the “percent escaping” feature that occurs with dialects
that use the “format” or “pyformat” bound parameter styles was not enabled
for the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op" title="sqlalchemy.sql.expression.Operators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.op()</span></code></a> and <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.custom_op" title="sqlalchemy.sql.expression.custom_op"><code class="xref py py-class docutils literal notranslate"><span class="pre">custom_op</span></code></a> constructs,
for custom operators that use percent signs. The percent sign will now be
automatically doubled based on the paramstyle as necessary.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6016">#6016</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-12"><span class="target" id="change-127c0c6c41f2a4536d040aeb5a8d3873"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-127c0c6c41f2a4536d040aeb5a8d3873">¶</a></span><p>Fixed regression where the “unsupported compilation error” for unknown
datatypes would fail to raise correctly.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5979">#5979</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-13"><span class="target" id="change-84c4accf7ece2512cfc030e399ebd205"><strong>[sql] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-84c4accf7ece2512cfc030e399ebd205">¶</a></span><p>Fixed regression where usage of the standalone <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.distinct" title="sqlalchemy.sql.expression.distinct"><code class="xref py py-func docutils literal notranslate"><span class="pre">distinct()</span></code></a> used
in the form of being directly SELECTed would fail to be locatable in the
result set by column identity, which is how the ORM locates columns. While
standalone <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.distinct" title="sqlalchemy.sql.expression.distinct"><code class="xref py py-func docutils literal notranslate"><span class="pre">distinct()</span></code></a> is not oriented towards being directly
SELECTed (use <code class="xref py py-meth docutils literal notranslate"><span class="pre">select.distinct()</span></code> for a regular
<code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">DISTINCT..</span></code>) , it was usable to a limited extent in this way
previously (but wouldn’t work in subqueries, for example). The column
targeting for unary expressions such as “DISTINCT &lt;col&gt;” has been improved
so that this case works again, and an additional improvement has been made
so that usage of this form in a subquery at least generates valid SQL which
was not the case previously.</p>
<p>The change additionally enhances the ability to target elements in
<code class="docutils literal notranslate"><span class="pre">row._mapping</span></code> based on SQL expression objects in ORM-enabled
SELECT statements, including whether the statement was invoked by
<code class="docutils literal notranslate"><span class="pre">connection.execute()</span></code> or <code class="docutils literal notranslate"><span class="pre">session.execute()</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6008">#6008</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0-schema">
<h3>schema<a class="headerlink" href="#change-1.4.0-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0-14"><span class="target" id="change-9914f9a6e1bd51ec04c336ee24e329ba"><strong>[schema] [bug] [sqlite]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9914f9a6e1bd51ec04c336ee24e329ba">¶</a></span><p>Fixed issue where the CHECK constraint generated by <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Boolean" title="sqlalchemy.types.Boolean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Boolean</span></code></a>
or <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a> would fail to render the naming convention
correctly after the first compilation, due to an unintended change of state
within the name given to the constraint. This issue was first introduced in
0.9 in the fix for issue #3067, and the fix revises the approach taken at
that time which appears to have been more involved than what was needed.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6007">#6007</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-15"><span class="target" id="change-20285e9c14fd33603c6c0b2247f6be08"><strong>[schema] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-20285e9c14fd33603c6c0b2247f6be08">¶</a></span><p>Repaired / implemented support for primary key constraint naming
conventions that use column names/keys/etc as part of the convention. In
particular, this includes that the <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint" title="sqlalchemy.schema.PrimaryKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrimaryKeyConstraint</span></code></a> object
that’s automatically associated with a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> will update
its name as new primary key <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects are added to
the table and then to the constraint. Internal failure modes related to
this constraint construction process including no columns present, no name
present or blank name present are now accommodated.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5919">#5919</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-16"><span class="target" id="change-4835edbe9953b4005da244bb252da030"><strong>[schema] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4835edbe9953b4005da244bb252da030">¶</a></span><p>Deprecated all schema-level <code class="docutils literal notranslate"><span class="pre">.copy()</span></code> methods and renamed to
<code class="docutils literal notranslate"><span class="pre">_copy()</span></code>.  These are not standard Python “copy()” methods as they
typically rely upon being instantiated within particular contexts
which are passed to the method as optional keyword arguments.   The
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.tometadata" title="sqlalchemy.schema.Table.tometadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.tometadata()</span></code></a> method is the public API that provides
copying for <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5953">#5953</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0-mypy">
<h3>mypy<a class="headerlink" href="#change-1.4.0-mypy" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0-17"><span class="target" id="change-591bbdd76b8c2bd63d918a4607e00c7e"><strong>[mypy] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-591bbdd76b8c2bd63d918a4607e00c7e">¶</a></span><p>Rudimentary and experimental support for Mypy has been added in the form of
a new plugin, which itself depends on new typing stubs for SQLAlchemy. The
plugin allows declarative mappings in their standard form to both be
compatible with Mypy as well as to provide typing support for mapped
classes and instances.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/extensions/mypy.html"><span class="std std-ref">Mypy  / Pep-484 Support for ORM Mappings</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4609">#4609</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.0-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0-18"><span class="target" id="change-0c001ea0cd1e7ca9ca63a7d98b30058e"><strong>[postgresql] [usecase] [asyncio] [mysql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0c001ea0cd1e7ca9ca63a7d98b30058e">¶</a></span><p>Added an <code class="docutils literal notranslate"><span class="pre">asyncio.Lock()</span></code> within SQLAlchemy’s emulated DBAPI cursor,
local to the connection, for the asyncpg and aiomysql dialects for the
scope of the <code class="docutils literal notranslate"><span class="pre">cursor.execute()</span></code> and <code class="docutils literal notranslate"><span class="pre">cursor.executemany()</span></code> methods. The
rationale is to prevent failures and corruption for the case where the
connection is used in multiple awaitables at once.</p>
<p>While this use case can also occur with threaded code and non-asyncio
dialects, we anticipate this kind of use will be more common under asyncio,
as the asyncio API is encouraging of such use. It’s definitely better to
use a distinct connection per concurrent awaitable however as concurrency
will not be achieved otherwise.</p>
<p>For the asyncpg dialect, this is so that the space between
the call to <code class="docutils literal notranslate"><span class="pre">prepare()</span></code> and <code class="docutils literal notranslate"><span class="pre">fetch()</span></code> is prevented from allowing
concurrent executions on the connection from causing interface error
exceptions, as well as preventing race conditions when starting a new
transaction. Other PostgreSQL DBAPIs are threadsafe at the connection level
so this intends to provide a similar behavior, outside the realm of server
side cursors.</p>
<p>For the aiomysql dialect, the mutex will provide safety such that
the statement execution and the result set fetch, which are two distinct
steps at the connection level, won’t get corrupted by concurrent
executions on the same connection.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5967">#5967</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-19"><span class="target" id="change-61b7de908cdae0792cb03d2646aadc58"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-61b7de908cdae0792cb03d2646aadc58">¶</a></span><p>Fixed issue where using <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by" title="sqlalchemy.dialects.postgresql.aggregate_order_by"><code class="xref py py-class docutils literal notranslate"><span class="pre">aggregate_order_by</span></code></a> would
return ARRAY(NullType) under certain conditions, interfering with
the ability of the result object to return data correctly.</p>
<p>This change is also <strong>backported</strong> to: 1.3.24</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5989">#5989</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.0-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0-20"><span class="target" id="change-955e4e7032fa1d6c704efa430c822dad"><strong>[mssql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-955e4e7032fa1d6c704efa430c822dad">¶</a></span><p>Fix a reflection error for MSSQL 2005 introduced by the reflection of
filtered indexes.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5919">#5919</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0-misc">
<h3>misc<a class="headerlink" href="#change-1.4.0-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0-21"><span class="target" id="change-8c6da0e271f95aa3749187ff8ff39a44"><strong>[usecase] [ext]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8c6da0e271f95aa3749187ff8ff39a44">¶</a></span><p>Add new parameter
<a class="reference internal" href="../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflection_options" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.reflection_options</span></code></a>
to allow passing of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.reflect" title="sqlalchemy.schema.MetaData.reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code></a> options like <code class="docutils literal notranslate"><span class="pre">only</span></code>
or dialect-specific reflection options like <code class="docutils literal notranslate"><span class="pre">oracle_resolve_synonyms</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5942">#5942</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0-22"><span class="target" id="change-7a3136a2de848154d32b761c31f15554"><strong>[bug] [ext]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7a3136a2de848154d32b761c31f15554">¶</a></span><p>The <code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.mutable</span></code> extension now tracks the “parents”
collection using the <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstanceState" title="sqlalchemy.orm.InstanceState"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstanceState</span></code></a> associated with objects,
rather than the object itself. The latter approach required that the object
be hashable so that it can be inside of a <code class="docutils literal notranslate"><span class="pre">WeakKeyDictionary</span></code>, which goes
against the behavioral contract of the ORM overall which is that ORM mapped
objects do not need to provide any particular kind of <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> method
and that unhashable objects are supported.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/6020">#6020</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.0b3">
<h2 class="release-version">1.4.0b3<a class="headerlink" href="#change-1.4.0b3" title="Permalink to this headline">¶</a></h2>
Released: February 15, 2021<section id="change-1.4.0b3-orm">
<h3>orm<a class="headerlink" href="#change-1.4.0b3-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b3-0"><span class="target" id="change-db7a8709c4a5fd93e4f387cd1706fa0e"><strong>[orm] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-db7a8709c4a5fd93e4f387cd1706fa0e">¶</a></span><p>The ORM used in <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> can now return ORM objects from the rows
returned by an UPDATE..RETURNING or INSERT..RETURNING statement, by
supplying the construct to <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement" title="sqlalchemy.sql.expression.Select.from_statement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.from_statement()</span></code></a> in an ORM
context.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/session_basics.html#orm-dml-returning-objects"><span class="std std-ref">Selecting ORM Objects Inline with UPDATE.. RETURNING or INSERT..RETURNING</span></a></p>
</div>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b3-1"><span class="target" id="change-d655779c578ca220cb30800a2c2c3192"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d655779c578ca220cb30800a2c2c3192">¶</a></span><p>Fixed issue in new 1.4/2.0 style ORM queries where a statement-level label
style would not be preserved in the keys used by result rows; this has been
applied to all combinations of Core/ORM columns / session vs. connection
etc. so that the linkage from statement to result row is the same in all
cases.   As part of this change, the labeling of column expressions
in rows has been improved to retain the original name of the ORM
attribute even if used in a subquery.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5933">#5933</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b3-engine">
<h3>engine<a class="headerlink" href="#change-1.4.0b3-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b3-2"><span class="target" id="change-4700a62788134e657be0cd702c412997"><strong>[engine] [bug] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4700a62788134e657be0cd702c412997">¶</a></span><p>Continued with the improvement made as part of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5653">#5653</a> to further
support bound parameter names, including those generated against column
names, for names that include colons, parenthesis, and question marks, as
well as improved test support, so that bound parameter names even if they
are auto-derived from column names should have no problem including for
parenthesis in psycopg2’s “pyformat” style.</p>
<p>As part of this change, the format used by the asyncpg DBAPI adapter (which
is local to SQLAlchemy’s asyncpg dialect) has been changed from using
“qmark” paramstyle to “format”, as there is a standard and internally
supported SQL string escaping style for names that use percent signs with
“format” style (i.e. to double percent signs), as opposed to names that use
question marks with “qmark” style (where an escaping system is not defined
by pep-249 or Python).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5941"><span class="std std-ref">psycopg2 dialect no longer has limitations regarding bound parameter names</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5941">#5941</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b3-sql">
<h3>sql<a class="headerlink" href="#change-1.4.0b3-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b3-3"><span class="target" id="change-f926acc6dc8d325fdf42a7f004cd0afc"><strong>[sql] [usecase] [postgresql] [sqlite]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f926acc6dc8d325fdf42a7f004cd0afc">¶</a></span><p>Enhance <code class="docutils literal notranslate"><span class="pre">set_</span></code> keyword of <code class="xref py py-class docutils literal notranslate"><span class="pre">OnConflictDoUpdate</span></code> to accept a
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection" title="sqlalchemy.sql.expression.ColumnCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnCollection</span></code></a>, such as the <code class="docutils literal notranslate"><span class="pre">.c.</span></code> collection from a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Selectable</span></code>, or the <code class="docutils literal notranslate"><span class="pre">.excluded</span></code> contextual object.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5939">#5939</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b3-4"><span class="target" id="change-d3979a6dace942e4e72dcdeab091deaa"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d3979a6dace942e4e72dcdeab091deaa">¶</a></span><p>Fixed bug where the “cartesian product” assertion was not correctly
accommodating for joins between tables that relied upon the use of LATERAL
to connect from a subquery to another subquery in the enclosing context.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5924">#5924</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b3-5"><span class="target" id="change-93af0ed299749003f683d259d928a4f3"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-93af0ed299749003f683d259d928a4f3">¶</a></span><p>Fixed 1.4 regression where the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Function.in_()</span></code> method was
not covered by tests and failed to function properly in all cases.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5934">#5934</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b3-6"><span class="target" id="change-9247248f5b058f075cda0dbae9129571"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9247248f5b058f075cda0dbae9129571">¶</a></span><p>Fixed regression where use of an arbitrary iterable with the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> function was not working, outside of plain lists. The
forwards/backwards compatibility logic here now checks for a wider range of
incoming “iterable” types including that a <code class="docutils literal notranslate"><span class="pre">.c</span></code> collection from a
selectable can be passed directly. Pull request compliments of Oliver Rice.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5935">#5935</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.0b2">
<h2 class="release-version">1.4.0b2<a class="headerlink" href="#change-1.4.0b2" title="Permalink to this headline">¶</a></h2>
Released: February 3, 2021<section id="change-1.4.0b2-general">
<h3>general<a class="headerlink" href="#change-1.4.0b2-general" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-0"><span class="target" id="change-2bb7238272ab88a73986df37e9b4e9c0"><strong>[general] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2bb7238272ab88a73986df37e9b4e9c0">¶</a></span><p>Fixed a SQLite source file that had non-ascii characters inside of its
docstring without a source encoding, introduced within the “INSERT..ON
CONFLICT” feature, which would cause failures under Python 2.</p>
<p></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-platform">
<h3>platform<a class="headerlink" href="#change-1.4.0b2-platform" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-1"><span class="target" id="change-c7638d0b34e1bfc3faf62805dcbc6439"><strong>[platform] [performance]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c7638d0b34e1bfc3faf62805dcbc6439">¶</a></span><p>Adjusted some elements related to internal class production at import time
which added significant latency to the time spent to import the library vs.
that of 1.3.   The time is now about 20-30% slower than 1.3 instead of
200%.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5681">#5681</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-orm">
<h3>orm<a class="headerlink" href="#change-1.4.0b2-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-2"><span class="target" id="change-89fc99a023277e8a871da64befcf7990"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-89fc99a023277e8a871da64befcf7990">¶</a></span><p>Added <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.bind_mapper" title="sqlalchemy.orm.ORMExecuteState.bind_mapper"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ORMExecuteState.bind_mapper</span></code></a> and
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.all_mappers" title="sqlalchemy.orm.ORMExecuteState.all_mappers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ORMExecuteState.all_mappers</span></code></a> accessors to
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.ORMExecuteState" title="sqlalchemy.orm.ORMExecuteState"><code class="xref py py-class docutils literal notranslate"><span class="pre">ORMExecuteState</span></code></a> event object, so that handlers can respond to
the target mapper and/or mapped class or classes involved in an ORM
statement execution.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-3"><span class="target" id="change-0b14e24aaf837d9d11a7a5cec72f5fa5"><strong>[orm] [usecase] [asyncio]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0b14e24aaf837d9d11a7a5cec72f5fa5">¶</a></span><p>Added <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.scalar" title="sqlalchemy.ext.asyncio.AsyncSession.scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.scalar()</span></code></a>,
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.get" title="sqlalchemy.ext.asyncio.AsyncSession.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.get()</span></code></a> as well as support for
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.sessionmaker.begin" title="sqlalchemy.orm.sessionmaker.begin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sessionmaker.begin()</span></code></a> to work as an async context manager with
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a>.  Also added
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.in_transaction" title="sqlalchemy.ext.asyncio.AsyncSession.in_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.in_transaction()</span></code></a> accessor.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5796">#5796</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5797">#5797</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5802">#5802</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-4"><span class="target" id="change-862f181a4a02c182ae2fc772e70a4ba9"><strong>[orm] [changed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-862f181a4a02c182ae2fc772e70a4ba9">¶</a></span><p>Mapper “configuration”, which occurs within the
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal notranslate"><span class="pre">configure_mappers()</span></code></a> function, is now organized to be on a
per-registry basis. This allows for example the mappers within a certain
declarative base to be configured, but not those of another base that is
also present in memory. The goal is to provide a means of reducing
application startup time by only running the “configure” process for sets
of mappers that are needed. This also adds the
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.configure" title="sqlalchemy.orm.registry.configure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.configure()</span></code></a> method that will run configure for the
mappers local in a particular registry only.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5897">#5897</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-5"><span class="target" id="change-3e8dad56d2705ce4915a5b653440dd86"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3e8dad56d2705ce4915a5b653440dd86">¶</a></span><p>Added a comprehensive check and an informative error message for the case
where a mapped class, or a string mapped class name, is passed to
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code></a>.  This is an extremely common error
which warrants a clear message.</p>
<p>Additionally, added a new rule to the class registry resolution such that
with regards to the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code></a> parameter, if a
mapped class and its table are of the identical string name, the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> will be favored when resolving this parameter.   In all
other cases, the class continues to be favored if a class and table
share the identical name.</p>
<p>This change is also <strong>backported</strong> to: 1.3.21</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5774">#5774</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-6"><span class="target" id="change-5f1efd433135173d6a86c7b0d58b1e1d"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5f1efd433135173d6a86c7b0d58b1e1d">¶</a></span><p>Fixed bug involving the <code class="docutils literal notranslate"><span class="pre">restore_load_context</span></code> option of ORM events such
as <code class="xref py py-meth docutils literal notranslate"><span class="pre">InstanceEvents.load()</span></code> such that the flag would not be
carried along to subclasses which were mapped after the event handler were
first established.</p>
<p>This change is also <strong>backported</strong> to: 1.3.21</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5737">#5737</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-7"><span class="target" id="change-f5e47e4c225dc50ec26bf3f1a2906fdc"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f5e47e4c225dc50ec26bf3f1a2906fdc">¶</a></span><p>Fixed issue in new <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> similar to that of the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> where the new “autobegin” logic could be
tripped into a re-entrant (recursive) state if SQL were executed within the
<a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create" title="sqlalchemy.orm.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.after_transaction_create()</span></code></a> event hook.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5845">#5845</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-8"><span class="target" id="change-da5fa57b99dc48295cf71c7ca19a5c8c"><strong>[orm] [bug] [unitofwork]</strong> <a class="changelog-reference headerlink reference internal" href="#change-da5fa57b99dc48295cf71c7ca19a5c8c">¶</a></span><p>Improved the unit of work topological sorting system such that the
toplogical sort is now deterministic based on the sorting of the input set,
which itself is now sorted at the level of mappers, so that the same inputs
of affected mappers should produce the same output every time, among
mappers / tables that don’t have any dependency on each other. This further
reduces the chance of deadlocks as can be observed in a flush that UPDATEs
among multiple, unrelated tables such that row locks are generated.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5735">#5735</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-9"><span class="target" id="change-ac50717b91c651e2b9eb12b49e227c25"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ac50717b91c651e2b9eb12b49e227c25">¶</a></span><p>Fixed regression where the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Bundle.params.single_entity" title="sqlalchemy.orm.Bundle"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Bundle.single_entity</span></code></a> flag would
take effect for a <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Bundle" title="sqlalchemy.orm.Bundle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bundle</span></code></a> even though it were not set.
Additionally, this flag is legacy as it only makes sense for the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object and not 2.0 style execution.  a deprecation
warning is emitted when used with new-style execution.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5702">#5702</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-10"><span class="target" id="change-ea6e4003e985b4d4396e1edafd6bf982"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ea6e4003e985b4d4396e1edafd6bf982">¶</a></span><p>Fixed regression where creating an <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-class docutils literal notranslate"><span class="pre">aliased</span></code></a> construct against
a plain selectable and including a name would raise an assertionerror.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5750">#5750</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-11"><span class="target" id="change-07f4e6914adf7db1a89949ea9fbe60f7"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-07f4e6914adf7db1a89949ea9fbe60f7">¶</a></span><p>Related to the fixes for the lambda criteria system within Core, within the
ORM implemented a variety of fixes for the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_loader_criteria" title="sqlalchemy.orm.with_loader_criteria"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_loader_criteria()</span></code></a> feature as well as the
<a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute" title="sqlalchemy.orm.SessionEvents.do_orm_execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.do_orm_execute()</span></code></a> event handler that is often
used in conjunction [ticket:5760]:</p>
<ul>
<li><p>fixed issue where <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_loader_criteria" title="sqlalchemy.orm.with_loader_criteria"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_loader_criteria()</span></code></a> function would fail
if the given entity or base included non-mapped mixins in its descending
class hierarchy [ticket:5766]</p></li>
<li><p>The <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_loader_criteria" title="sqlalchemy.orm.with_loader_criteria"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_loader_criteria()</span></code></a> feature is now unconditionally
disabled for the case of ORM “refresh” operations, including loads
of deferred or expired column attributes as well as for explicit
operations like <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.refresh" title="sqlalchemy.orm.Session.refresh"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.refresh()</span></code></a>.  These loads are necessarily
based on primary key identity where addiional WHERE criteria is
never appropriate.  [ticket:5762]</p></li>
<li><p>Added new attribute <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.is_column_load" title="sqlalchemy.orm.ORMExecuteState.is_column_load"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ORMExecuteState.is_column_load</span></code></a> to indicate
that a <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute" title="sqlalchemy.orm.SessionEvents.do_orm_execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.do_orm_execute()</span></code></a> handler that a particular
operation is a primary-key-directed column attribute load, where additional
criteria should not be added.  The <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_loader_criteria" title="sqlalchemy.orm.with_loader_criteria"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_loader_criteria()</span></code></a>
function as above ignores these in any case now.  [ticket:5761]</p></li>
<li><p>Fixed issue where the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.ORMExecuteState.is_relationship_load" title="sqlalchemy.orm.ORMExecuteState.is_relationship_load"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ORMExecuteState.is_relationship_load</span></code></a>
attribute would not be set correctly for many lazy loads as well as all
selectinloads.  The flag is essential in order to test if options should
be added to statements or if they would already have been propagated via
relationship loads.  [ticket:5764]</p></li>
</ul>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5760">#5760</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5761">#5761</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5762">#5762</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5764">#5764</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5766">#5766</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-12"><span class="target" id="change-bdd60c16271a5993174ea1886e87b0c9"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-bdd60c16271a5993174ea1886e87b0c9">¶</a></span><p>Fixed 1.4 regression where the use of <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.having" title="sqlalchemy.orm.Query.having"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.having()</span></code></a> in
conjunction with queries with internally adapted SQL elements (common in
inheritance scenarios) would fail due to an incorrect function call. Pull
request courtesy esoh.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5781">#5781</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-13"><span class="target" id="change-91ddb3ca84a9f93dae47c3241b6772ce"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-91ddb3ca84a9f93dae47c3241b6772ce">¶</a></span><p>Fixed an issue where the API to create a custom executable SQL construct
using the <code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.compiles</span></code> extension according to the
documentation that’s been up for many years would no longer function if
only <code class="docutils literal notranslate"><span class="pre">Executable,</span> <span class="pre">ClauseElement</span></code> were used as the base classes,
additional classes were needed if wanting to use
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>. This has been resolved so that those extra
classes aren’t needed.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-14"><span class="target" id="change-77a3c407c3bce2bc4c55e89a7b7f515a"><strong>[orm] [bug] [regression]</strong> <a class="changelog-reference headerlink reference internal" href="#change-77a3c407c3bce2bc4c55e89a7b7f515a">¶</a></span><p>Fixed ORM unit of work regression where an errant “assert primary_key”
statement interferes with primary key generation sequences that don’t
actually consider the columns in the table to use a real primary key
constraint, instead using <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapper.params.primary_key" title="sqlalchemy.orm.mapper"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.primary_key</span></code></a> to establish
certain columns as “primary”.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5867">#5867</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-orm-declarative">
<h3>orm declarative<a class="headerlink" href="#change-1.4.0b2-orm-declarative" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-15"><span class="target" id="change-624c434b8ec8396c2e97192d0b64acf8"><strong>[orm] [declarative] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-624c434b8ec8396c2e97192d0b64acf8">¶</a></span><p>Added an alternate resolution scheme to Declarative that will extract the
SQLAlchemy column or mapped property from the “metadata” dictionary of a
dataclasses.Field object.  This allows full declarative mappings to be
combined with dataclass fields.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/mapping_styles.html#orm-declarative-dataclasses-declarative-table"><span class="std std-ref">Example Two - Dataclasses with Declarative Table</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5745">#5745</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-engine">
<h3>engine<a class="headerlink" href="#change-1.4.0b2-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-16"><span class="target" id="change-c7468db4e134ddecd005dfac7d4d959b"><strong>[engine] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c7468db4e134ddecd005dfac7d4d959b">¶</a></span><p>Dialect-specific constructs such as
<a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update" title="sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.on_conflict_do_update()</span></code></a> can now stringify in-place
without the need to specify an explicit dialect object.  The constructs,
when called upon for <code class="docutils literal notranslate"><span class="pre">str()</span></code>, <code class="docutils literal notranslate"><span class="pre">print()</span></code>, etc. now have internal
direction to call upon their appropriate dialect rather than the
“default”dialect which doesn’t know how to stringify these.   The approach
is also adapted to generic schema-level create/drop such as
<a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.AddConstraint" title="sqlalchemy.schema.AddConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">AddConstraint</span></code></a>, which will adapt its stringify dialect to
one indicated by the element within it, such as the
<a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint" title="sqlalchemy.dialects.postgresql.ExcludeConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExcludeConstraint</span></code></a> object.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-17"><span class="target" id="change-bfbd8f66d538b133e695984da786f546"><strong>[engine] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-bfbd8f66d538b133e695984da786f546">¶</a></span><p>Added new execution option
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.logging_token" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Connection.execution_options.logging_token</span></code></a>. This option
will add an additional per-message token to log messages generated by the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> as it executes statements. This token is not
part of the logger name itself (that part can be affected using the
existing <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.logging_name" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.logging_name</span></code></a> parameter), so is
appropriate for ad-hoc connection use without the side effect of creating
many new loggers. The option can be set at the level of
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> or <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/engines.html#dbengine-logging-tokens"><span class="std std-ref">Setting Per-Connection / Sub-Engine Tokens</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5911">#5911</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-18"><span class="target" id="change-f4c53dd6eec64c28854b50a6bf985e3d"><strong>[engine] [bug] [sqlite]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f4c53dd6eec64c28854b50a6bf985e3d">¶</a></span><p>Fixed bug in the 2.0 “future” version of <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> where emitting
SQL during the <code class="xref py py-meth docutils literal notranslate"><span class="pre">EngineEvents.begin()</span></code> event hook would cause a
re-entrant (recursive) condition due to autobegin, affecting among other
things the recipe documented for SQLite to allow for savepoints and
serializable isolation support.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5845">#5845</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-19"><span class="target" id="change-b227afa7869d0985479e4f6b60c29f43"><strong>[engine] [bug] [oracle] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b227afa7869d0985479e4f6b60c29f43">¶</a></span><p>Adjusted the “setinputsizes” logic relied upon by the cx_Oracle, asyncpg
and pg8000 dialects to support a <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a> that includes
an override the <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator.get_dbapi_type" title="sqlalchemy.types.TypeDecorator.get_dbapi_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeDecorator.get_dbapi_type()</span></code></a> method.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-20"><span class="target" id="change-0a03d3b52dd174de8a6f725f3334fef0"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0a03d3b52dd174de8a6f725f3334fef0">¶</a></span><p>Added the “future” keyword to the list of words that are known by the
<a class="reference internal" href="../core/engines.html#sqlalchemy.engine_from_config" title="sqlalchemy.engine_from_config"><code class="xref py py-func docutils literal notranslate"><span class="pre">engine_from_config()</span></code></a> function, so that the values “true” and
“false” may be configured as “boolean” values when using a key such
as <code class="docutils literal notranslate"><span class="pre">sqlalchemy.future</span> <span class="pre">=</span> <span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">sqlalchemy.future</span> <span class="pre">=</span> <span class="pre">false</span></code>.</p>
<p></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-sql">
<h3>sql<a class="headerlink" href="#change-1.4.0b2-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-21"><span class="target" id="change-fbf4118b3c85611f404a683fcb487c20"><strong>[sql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-fbf4118b3c85611f404a683fcb487c20">¶</a></span><p>Implemented support for “table valued functions” along with additional
syntaxes supported by PostgreSQL, one of the most commonly requested
features. Table valued functions are SQL functions that return lists of
values or rows, and are prevalent in PostgreSQL in the area of JSON
functions, where the “table value” is commonly referred towards as the
“record” datatype. Table valued functions are also supported by Oracle and
SQL Server.</p>
<p>Features added include:</p>
<ul>
<li><p>the <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued" title="sqlalchemy.sql.functions.FunctionElement.table_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.table_valued()</span></code></a> modifier that creates a table-like
selectable object from a SQL function</p></li>
<li><p>A <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias" title="sqlalchemy.sql.expression.TableValuedAlias"><code class="xref py py-class docutils literal notranslate"><span class="pre">TableValuedAlias</span></code></a> construct that renders a SQL function
as a named table</p></li>
<li><p>Support for PostgreSQL’s special “derived column” syntax that includes
column names and sometimes datatypes, such as for the
<code class="docutils literal notranslate"><span class="pre">json_to_recordset</span></code> function, using the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived" title="sqlalchemy.sql.expression.TableValuedAlias.render_derived"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TableValuedAlias.render_derived()</span></code></a> method.</p></li>
<li><p>Support for PostgreSQL’s “WITH ORDINALITY” construct using the
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued.params.with_ordinality" title="sqlalchemy.sql.functions.FunctionElement.table_valued"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">FunctionElement.table_valued.with_ordinality</span></code></a> parameter</p></li>
<li><p>Support for selection FROM a SQL function as column-valued scalar, a
syntax supported by PostgreSQL and Oracle, via the
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued" title="sqlalchemy.sql.functions.FunctionElement.column_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.column_valued()</span></code></a> method</p></li>
<li><p>A way to SELECT a single column from a table-valued expression without
using a FROM clause via the <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.scalar_table_valued" title="sqlalchemy.sql.functions.FunctionElement.scalar_table_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.scalar_table_valued()</span></code></a>
method.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../tutorial/data_select.html#tutorial-functions-table-valued"><span class="std std-ref">Table-Valued Functions</span></a> - in the <a class="reference internal" href="../tutorial/index.html#unified-tutorial"><span class="std std-ref">SQLAlchemy 1.4 / 2.0 Tutorial</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/3566">#3566</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-22"><span class="target" id="change-1055bd64ad4853782c2c7397dd371ed5"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-1055bd64ad4853782c2c7397dd371ed5">¶</a></span><p>Multiple calls to “returning”, e.g. <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert.returning" title="sqlalchemy.sql.expression.Insert.returning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.returning()</span></code></a>,
may now be chained to add new columns to the RETURNING clause.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5695">#5695</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-23"><span class="target" id="change-ddfc42d9c357788f9e4ae70579d93dce"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ddfc42d9c357788f9e4ae70579d93dce">¶</a></span><p>Added <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin_from" title="sqlalchemy.sql.expression.Select.outerjoin_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.outerjoin_from()</span></code></a> method to complement
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a>.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-24"><span class="target" id="change-8bef182370bf5ff088e03e8fd737e7cb"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8bef182370bf5ff088e03e8fd737e7cb">¶</a></span><p>Adjusted the “literal_binds” feature of <code class="xref py py-class docutils literal notranslate"><span class="pre">Compiler</span></code> to render
NULL for a bound parameter that has <code class="docutils literal notranslate"><span class="pre">None</span></code> as the value, either
explicitly passed or omitted. The previous error message “bind parameter
without a renderable value” is removed, and a missing or <code class="docutils literal notranslate"><span class="pre">None</span></code> value
will now render NULL in all cases. Previously, rendering of NULL was
starting to happen for DML statements due to internal refactorings, but was
not explicitly part of test coverage, which it now is.</p>
<p>While no error is raised, when the context is within that of a column
comparison, and the operator is not “IS”/”IS NOT”, a warning is emitted
that this is not generally useful from a SQL perspective.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5888">#5888</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-25"><span class="target" id="change-b0edc6bd729ab239963ae75775520aa6"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b0edc6bd729ab239963ae75775520aa6">¶</a></span><p>Fixed issue in new <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> method where chaining from the
current JOIN wasn’t looking at the right state, causing an expression like
“FROM a JOIN b &lt;onclause&gt;, b JOIN c &lt;onclause&gt;” rather than
“FROM a JOIN b &lt;onclause&gt; JOIN c &lt;onclause&gt;”.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5858">#5858</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-26"><span class="target" id="change-1d56ddbc45dd98ad563ff5e04aba3ce7"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-1d56ddbc45dd98ad563ff5e04aba3ce7">¶</a></span><p>Deprecation warnings are emitted under “SQLALCHEMY_WARN_20” mode when
passing a plain string to <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5754">#5754</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-27"><span class="target" id="change-4a1c9cad903f872bd86877a23be42aab"><strong>[sql] [bug] [orm]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4a1c9cad903f872bd86877a23be42aab">¶</a></span><p>A wide variety of fixes to the “lambda SQL” feature introduced at
<a class="reference internal" href="../core/connections.html#engine-lambda-caching"><span class="std std-ref">Using Lambdas to add significant speed gains to statement production</span></a> have been implemented based on user feedback,
with an emphasis on its use within the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_loader_criteria" title="sqlalchemy.orm.with_loader_criteria"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_loader_criteria()</span></code></a>
feature where it is most prominently used [ticket:5760]:</p>
<ul>
<li><p>fixed issue where boolean True/False values referred towards in the
closure variables of the lambda would cause failures [ticket:5763]</p></li>
<li><p>Repaired a non-working detection for Python functions embedded in the
lambda that produce bound values; this case is likely not supportable
so raises an informative error, where the function should be invoked
outside the lambda itself.  New documentation has been added to
further detail this behavior. [ticket:5770]</p></li>
<li><p>The lambda system by default now rejects the use of non-SQL elements
within the closure variables of the lambda entirely, where the error
suggests the two options of either explicitly ignoring closure variables
that are not SQL parameters, or specifying a specific set of values to be
considered as part of the cache key based on hash value.   This critically
prevents the lambda system from assuming that arbitrary objects within
the lambda’s closure are appropriate for caching while also refusing to
ignore them by default, preventing the case where their state might
not be constant and have an impact on the SQL construct produced.
The error message is comprehensive and new documentation has been
added to further detail this behavior. [ticket:5765]</p></li>
<li><p>Fixed support for the edge case where an <code class="docutils literal notranslate"><span class="pre">in_()</span></code> expression
against a list of SQL elements, such as <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.literal" title="sqlalchemy.sql.expression.literal"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal()</span></code></a> objects,
would fail to be accommodated correctly. [ticket:5768]</p></li>
</ul>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5760">#5760</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5763">#5763</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5765">#5765</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5768">#5768</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5770">#5770</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-28"><span class="target" id="change-32a6e0a8b6d799d4b66028af0cf890be"><strong>[sql] [bug] [mysql] [postgresql] [sqlite]</strong> <a class="changelog-reference headerlink reference internal" href="#change-32a6e0a8b6d799d4b66028af0cf890be">¶</a></span><p>An informative error message is now raised for a selected set of DML
methods (currently all part of <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a> constructs) if they are
called a second time, which would implicitly cancel out the previous
setting.  The methods altered include:
<a class="reference internal" href="../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update" title="sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">on_conflict_do_update</span></code></a>,
<a class="reference internal" href="../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing" title="sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing"><code class="xref py py-class docutils literal notranslate"><span class="pre">on_conflict_do_nothing</span></code></a> (SQLite),
<a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update" title="sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">on_conflict_do_update</span></code></a>,
<a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing" title="sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing"><code class="xref py py-class docutils literal notranslate"><span class="pre">on_conflict_do_nothing</span></code></a> (PostgreSQL),
<a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update" title="sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">on_duplicate_key_update</span></code></a> (MySQL)</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5169">#5169</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-29"><span class="target" id="change-b3d2d126657db24565cae378066a108f"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b3d2d126657db24565cae378066a108f">¶</a></span><p>Fixed issue in new <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Values" title="sqlalchemy.sql.expression.Values"><code class="xref py py-class docutils literal notranslate"><span class="pre">Values</span></code></a> construct where passing tuples of
objects would fall back to per-value type detection rather than making use
of the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects passed directly to
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Values" title="sqlalchemy.sql.expression.Values"><code class="xref py py-class docutils literal notranslate"><span class="pre">Values</span></code></a> that tells SQLAlchemy what the expected type is. This
would lead to issues for objects such as enumerations and numpy strings
that are not actually necessary since the expected type is given.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5785">#5785</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-30"><span class="target" id="change-3c55922a8a405136026482da296017cf"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3c55922a8a405136026482da296017cf">¶</a></span><p>Fixed issue where a <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.RemovedIn20Warning" title="sqlalchemy.exc.RemovedIn20Warning"><code class="xref py py-class docutils literal notranslate"><span class="pre">RemovedIn20Warning</span></code></a> would erroneously emit
when the <code class="docutils literal notranslate"><span class="pre">.bind</span></code> attribute were accessed internally on objects,
particularly when stringifying a SQL construct.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5717">#5717</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-31"><span class="target" id="change-bb059f5d04b32a6eb2875e1e64aa0477"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-bb059f5d04b32a6eb2875e1e64aa0477">¶</a></span><p>Properly render <code class="docutils literal notranslate"><span class="pre">cycle=False</span></code> and <code class="docutils literal notranslate"><span class="pre">order=False</span></code> as <code class="docutils literal notranslate"><span class="pre">NO</span> <span class="pre">CYCLE</span></code> and
<code class="docutils literal notranslate"><span class="pre">NO</span> <span class="pre">ORDER</span></code> in <code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code>
objects.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5722">#5722</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-32"><span class="target" id="change-941766418c834970d9842ebae6da5af4"><strong>[sql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-941766418c834970d9842ebae6da5af4">¶</a></span><p>Replace <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.with_labels" title="sqlalchemy.orm.Query.with_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_labels()</span></code></a> and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.apply_labels" title="sqlalchemy.sql.expression.GenerativeSelect.apply_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenerativeSelect.apply_labels()</span></code></a> with explicit getters and
setters <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.get_label_style" title="sqlalchemy.sql.expression.GenerativeSelect.get_label_style"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenerativeSelect.get_label_style()</span></code></a> and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.set_label_style" title="sqlalchemy.sql.expression.GenerativeSelect.set_label_style"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GenerativeSelect.set_label_style()</span></code></a> to accommodate the three
supported label styles: <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.LABEL_STYLE_DISAMBIGUATE_ONLY" title="sqlalchemy.sql.expression.LABEL_STYLE_DISAMBIGUATE_ONLY"><code class="xref py py-data docutils literal notranslate"><span class="pre">LABEL_STYLE_DISAMBIGUATE_ONLY</span></code></a>,
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.LABEL_STYLE_TABLENAME_PLUS_COL" title="sqlalchemy.sql.expression.LABEL_STYLE_TABLENAME_PLUS_COL"><code class="xref py py-data docutils literal notranslate"><span class="pre">LABEL_STYLE_TABLENAME_PLUS_COL</span></code></a>, and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.LABEL_STYLE_NONE" title="sqlalchemy.sql.expression.LABEL_STYLE_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">LABEL_STYLE_NONE</span></code></a>.</p>
<p>In addition, for Core and “future style” ORM queries,
<code class="docutils literal notranslate"><span class="pre">LABEL_STYLE_DISAMBIGUATE_ONLY</span></code> is now the default label style. This
style differs from the existing “no labels” style in that labeling is
applied in the case of column name conflicts; with <code class="docutils literal notranslate"><span class="pre">LABEL_STYLE_NONE</span></code>, a
duplicate column name is not accessible via name in any case.</p>
<p>For cases where labeling is significant, namely that the <code class="docutils literal notranslate"><span class="pre">.c</span></code> collection
of a subquery is able to refer to all columns unambiguously, the behavior
of <code class="docutils literal notranslate"><span class="pre">LABEL_STYLE_DISAMBIGUATE_ONLY</span></code> is now sufficient for all
SQLAlchemy features across Core and ORM which involve this behavior.
Result set rows since SQLAlchemy 1.0 are usually aligned with column
constructs positionally.</p>
<p>For legacy ORM queries using <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>, the table-plus-column
names labeling style applied by <code class="docutils literal notranslate"><span class="pre">LABEL_STYLE_TABLENAME_PLUS_COL</span></code>
continues to be used so that existing test suites and logging facilities
see no change in behavior by default.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4757">#4757</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-schema">
<h3>schema<a class="headerlink" href="#change-1.4.0b2-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-33"><span class="target" id="change-06d2bf937412606dd59c1d367b0e0702"><strong>[schema] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-06d2bf937412606dd59c1d367b0e0702">¶</a></span><p>Added <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine.as_generic" title="sqlalchemy.types.TypeEngine.as_generic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.as_generic()</span></code></a> to map dialect-specific types,
such as <a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.INTEGER" title="sqlalchemy.dialects.mysql.INTEGER"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.mysql.INTEGER</span></code></a>, with the “best match”
generic SQLAlchemy type, in this case <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>.  Pull
request courtesy Andrew Hannigan.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/reflection.html#metadata-reflection-dbagnostic-types"><span class="std std-ref">Reflecting with Database-Agnostic Types</span></a> - example usage</p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5659">#5659</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-34"><span class="target" id="change-827e0c8971685c13e1030956e8c8203c"><strong>[schema] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-827e0c8971685c13e1030956e8c8203c">¶</a></span><p>The <a class="reference internal" href="../core/events.html#sqlalchemy.events.DDLEvents.column_reflect" title="sqlalchemy.events.DDLEvents.column_reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DDLEvents.column_reflect()</span></code></a> event may now be applied to a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object where it will take effect for the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects local to that collection.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/events.html#sqlalchemy.events.DDLEvents.column_reflect" title="sqlalchemy.events.DDLEvents.column_reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DDLEvents.column_reflect()</span></code></a></p>
<p><a class="reference internal" href="../orm/mapping_columns.html#mapper-automated-reflection-schemes"><span class="std std-ref">Automating Column Naming Schemes from Reflected Tables</span></a> - in the ORM mapping documentation</p>
<p><a class="reference internal" href="../orm/extensions/automap.html#automap-intercepting-columns"><span class="std std-ref">Intercepting Column Definitions</span></a> - in the <a class="reference internal" href="../orm/extensions/automap.html"><span class="std std-ref">Automap</span></a> documentation</p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5712">#5712</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-35"><span class="target" id="change-bc2b7420824d488f37321f347f2e296d"><strong>[schema] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-bc2b7420824d488f37321f347f2e296d">¶</a></span><p>Added parameters <a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.CreateTable.params.if_not_exists" title="sqlalchemy.schema.CreateTable"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">CreateTable.if_not_exists</span></code></a>,
<a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.CreateIndex.params.if_not_exists" title="sqlalchemy.schema.CreateIndex"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">CreateIndex.if_not_exists</span></code></a>,
<a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.DropTable.params.if_exists" title="sqlalchemy.schema.DropTable"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">DropTable.if_exists</span></code></a> and
<a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.DropIndex.params.if_exists" title="sqlalchemy.schema.DropIndex"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">DropIndex.if_exists</span></code></a> to the <a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.CreateTable" title="sqlalchemy.schema.CreateTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateTable</span></code></a>,
<a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.DropTable" title="sqlalchemy.schema.DropTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DropTable</span></code></a>, <a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.CreateIndex" title="sqlalchemy.schema.CreateIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateIndex</span></code></a> and
<a class="reference internal" href="../core/ddl.html#sqlalchemy.schema.DropIndex" title="sqlalchemy.schema.DropIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">DropIndex</span></code></a> constructs which result in “IF NOT EXISTS” / “IF
EXISTS” DDL being added to the CREATE/DROP. These phrases are not accepted
by all databases and the operation will fail on a database that does not
support it as there is no similarly compatible fallback within the scope of
a single DDL statement.  Pull request courtesy Ramon Williams.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/2843">#2843</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-36"><span class="target" id="change-a8fa393c9fea3a0524c0a1209d74bea7"><strong>[schema] [changed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a8fa393c9fea3a0524c0a1209d74bea7">¶</a></span><p>Altered the behavior of the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Identity" title="sqlalchemy.schema.Identity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code></a> construct such that
when applied to a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>, it will automatically imply that
the value of <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.nullable</span></code> should default to <code class="docutils literal notranslate"><span class="pre">False</span></code>,
in a similar manner as when the <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.primary_key</span></code>
parameter is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.   This matches the default behavior of all
supporting databases where <code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> implies <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code>.  The
PostgreSQL backend is the only one that supports adding <code class="docutils literal notranslate"><span class="pre">NULL</span></code> to an
<code class="docutils literal notranslate"><span class="pre">IDENTITY</span></code> column, which is here supported by passing a <code class="docutils literal notranslate"><span class="pre">True</span></code> value
for the <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.nullable</span></code> parameter at the same time.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5775">#5775</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-asyncio">
<h3>asyncio<a class="headerlink" href="#change-1.4.0b2-asyncio" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-37"><span class="target" id="change-ac98c934451794473fb6e837e5c801e6"><strong>[asyncio] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ac98c934451794473fb6e837e5c801e6">¶</a></span><p>The <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine" title="sqlalchemy.ext.asyncio.AsyncEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncEngine</span></code></a>, <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection" title="sqlalchemy.ext.asyncio.AsyncConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncConnection</span></code></a> and
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction" title="sqlalchemy.ext.asyncio.AsyncTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncTransaction</span></code></a> objects may be compared using Python <code class="docutils literal notranslate"><span class="pre">==</span></code> or
<code class="docutils literal notranslate"><span class="pre">!=</span></code>, which will compare the two given objects based on the “sync” object
they are proxying towards. This is useful as there are cases particularly
for <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction" title="sqlalchemy.ext.asyncio.AsyncTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncTransaction</span></code></a> where multiple instances of
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction" title="sqlalchemy.ext.asyncio.AsyncTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncTransaction</span></code></a> can be proxying towards the same sync
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Transaction" title="sqlalchemy.engine.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>, and are actually equivalent.   The
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_transaction" title="sqlalchemy.ext.asyncio.AsyncConnection.get_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncConnection.get_transaction()</span></code></a> method will currently return a new
proxying <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction" title="sqlalchemy.ext.asyncio.AsyncTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncTransaction</span></code></a> each time as the
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncTransaction" title="sqlalchemy.ext.asyncio.AsyncTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncTransaction</span></code></a> is not otherwise statefully associated with its
originating <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection" title="sqlalchemy.ext.asyncio.AsyncConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncConnection</span></code></a>.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-38"><span class="target" id="change-12b8eb8e600cc32590b51d0087552191"><strong>[asyncio] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-12b8eb8e600cc32590b51d0087552191">¶</a></span><p>Adjusted the greenlet integration, which provides support for Python asyncio
in SQLAlchemy, to accommodate for the handling of Python <code class="docutils literal notranslate"><span class="pre">contextvars</span></code>
(introduced in Python 3.7) for <code class="docutils literal notranslate"><span class="pre">greenlet</span></code> versions greater than 0.4.17.
Greenlet version 0.4.17 added automatic handling of contextvars in a
backwards-incompatible way; we’ve coordinated with the greenlet authors to
add a preferred API for this in versions subsequent to 0.4.17 which is now
supported by SQLAlchemy’s greenlet integration.  For greenlet versions prior
to 0.4.17 no behavioral change is needed, version 0.4.17 itself is blocked
from the dependencies.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5615">#5615</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-39"><span class="target" id="change-ea57c300f6cfbf3c16b3e9cdf90e1884"><strong>[asyncio] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ea57c300f6cfbf3c16b3e9cdf90e1884">¶</a></span><p>Implemented “connection-binding” for <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a>, the ability to
pass an <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection" title="sqlalchemy.ext.asyncio.AsyncConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncConnection</span></code></a> to create an <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a>.
Previously, this use case was not implemented and would use the associated
engine when the connection were passed.  This fixes the issue where the
“join a session to an external transaction” use case would not work
correctly for the <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a>.  Additionally, added methods
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.in_transaction" title="sqlalchemy.ext.asyncio.AsyncConnection.in_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncConnection.in_transaction()</span></code></a>,
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.in_nested_transaction" title="sqlalchemy.ext.asyncio.AsyncConnection.in_nested_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncConnection.in_nested_transaction()</span></code></a>,
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_transaction" title="sqlalchemy.ext.asyncio.AsyncConnection.get_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncConnection.get_transaction()</span></code></a>,
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.get_nested_transaction" title="sqlalchemy.ext.asyncio.AsyncConnection.get_nested_transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncConnection.get_nested_transaction()</span></code></a> and
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.info" title="sqlalchemy.ext.asyncio.AsyncConnection.info"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AsyncConnection.info</span></code></a> attribute.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5811">#5811</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-40"><span class="target" id="change-d1e32636914aa6eb22e28ce68212a5c0"><strong>[asyncio] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d1e32636914aa6eb22e28ce68212a5c0">¶</a></span><p>Fixed bug in asyncio connection pool where <code class="docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code> would
be raised rather than <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.TimeoutError" title="sqlalchemy.exc.TimeoutError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeoutError</span></code></a>.  Also repaired the
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.pool_timeout" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.pool_timeout</span></code></a> parameter set to zero when using
the async engine, which previously would ignore the timeout and block
rather than timing out immediately as is the behavior with regular
<a class="reference internal" href="../core/pooling.html#sqlalchemy.pool.QueuePool" title="sqlalchemy.pool.QueuePool"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueuePool</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5827">#5827</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-41"><span class="target" id="change-898532ea0715f424aaa0ed14d4204bec"><strong>[asyncio] [bug] [pool]</strong> <a class="changelog-reference headerlink reference internal" href="#change-898532ea0715f424aaa0ed14d4204bec">¶</a></span><p>When using an asyncio engine, the connection pool will now detach and
discard a pooled connection that is was not explicitly closed/returned to
the pool when its tracking object is garbage collected, emitting a warning
that the connection was not properly closed.   As this operation occurs
during Python gc finalizers, it’s not safe to run any IO operations upon
the connection including transaction rollback or connection close as this
will often be outside of the event loop.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AsyncAdaptedQueue</span></code> used by default on async dpapis
should instantiate a queue only when it’s first used
to avoid binding it to a possibly wrong event loop.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5823">#5823</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-42"><span class="target" id="change-3e8f2aa7b6cb5c1bd18efa7f3146e0c3"><strong>[asyncio]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3e8f2aa7b6cb5c1bd18efa7f3146e0c3">¶</a></span><p>The SQLAlchemy async mode now detects and raises an informative
error when an non asyncio compatible <a class="reference internal" href="../glossary.html#term-DBAPI"><span class="xref std std-term">DBAPI</span></a> is used.
Using a standard <code class="docutils literal notranslate"><span class="pre">DBAPI</span></code> with async SQLAlchemy will cause
it to block like any sync call, interrupting the executing asyncio
loop.</p>
<p></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.0b2-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-43"><span class="target" id="change-411ed9a33b69e1692d275d59d9949fbe"><strong>[postgresql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-411ed9a33b69e1692d275d59d9949fbe">¶</a></span><p>Added new parameter <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.ops" title="sqlalchemy.dialects.postgresql.ExcludeConstraint"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ExcludeConstraint.ops</span></code></a> to the
<a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint" title="sqlalchemy.dialects.postgresql.ExcludeConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExcludeConstraint</span></code></a> object, to support operator class
specification with this constraint.  Pull request courtesy Alon Menczer.</p>
<p>This change is also <strong>backported</strong> to: 1.3.21</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5604">#5604</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-44"><span class="target" id="change-2612bf9ed7ac66d73f2a5708f4ec9767"><strong>[postgresql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2612bf9ed7ac66d73f2a5708f4ec9767">¶</a></span><p>Added a read/write <code class="docutils literal notranslate"><span class="pre">.autocommit</span></code> attribute to the DBAPI-adaptation layer
for the asyncpg dialect.   This so that when working with DBAPI-specific
schemes that need to use “autocommit” directly with the DBAPI connection,
the same <code class="docutils literal notranslate"><span class="pre">.autocommit</span></code> attribute which works with both psycopg2 as well
as pg8000 is available.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-45"><span class="target" id="change-8a9210bac21fe3d1fcbb00deb4779406"><strong>[postgresql] [changed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8a9210bac21fe3d1fcbb00deb4779406">¶</a></span><p>Fixed issue where the psycopg2 dialect would silently pass the
<code class="docutils literal notranslate"><span class="pre">use_native_unicode=False</span></code> flag without actually having any effect under
Python 3, as the psycopg2 DBAPI uses Unicode unconditionally under Python
3.  This usage now raises an <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.ArgumentError" title="sqlalchemy.exc.ArgumentError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArgumentError</span></code></a> when used under
Python 3. Added test support for Python 2.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-46"><span class="target" id="change-cfd30e7d918b30d2bbcbe392973abe30"><strong>[postgresql] [performance]</strong> <a class="changelog-reference headerlink reference internal" href="#change-cfd30e7d918b30d2bbcbe392973abe30">¶</a></span><p>Enhanced the performance of the asyncpg dialect by caching the asyncpg
PreparedStatement objects on a per-connection basis. For a test case that
makes use of the same statement on a set of pooled connections this appears
to grant a 10-20% speed improvement.  The cache size is adjustable and may
also be disabled.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/postgresql.html#asyncpg-prepared-statement-cache"><span class="std std-ref">Prepared Statement Cache</span></a></p>
</div>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-47"><span class="target" id="change-3b7a53b248399772e99ded17a7913f0a"><strong>[postgresql] [bug] [mysql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3b7a53b248399772e99ded17a7913f0a">¶</a></span><p>Fixed regression introduced in 1.3.2 for the PostgreSQL dialect, also
copied out to the MySQL dialect’s feature in 1.3.18, where usage of a non
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> construct such as <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> as the argument
to <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update.params.of" title="sqlalchemy.sql.expression.Select.with_for_update"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Select.with_for_update.of</span></code></a> would fail to be accommodated
correctly within the PostgreSQL or MySQL compilers.</p>
<p>This change is also <strong>backported</strong> to: 1.3.21</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5729">#5729</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-48"><span class="target" id="change-2f263e3b02b0a6b190c425a7519513b9"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2f263e3b02b0a6b190c425a7519513b9">¶</a></span><p>Fixed a small regression where the query for “show
standard_conforming_strings” upon initialization would be emitted even if
the server version info were detected as less than version 8.2, previously
it would only occur for server version 8.2 or greater. The query fails on
Amazon Redshift which reports a PG server version older than this value.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5698">#5698</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-49"><span class="target" id="change-19178a241e0f8b2a34369084a42a2e70"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-19178a241e0f8b2a34369084a42a2e70">¶</a></span><p>Established support for <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects as well as ORM
instrumented attributes as keys in the <code class="docutils literal notranslate"><span class="pre">set_</span></code> dictionary passed to the
<a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update" title="sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.on_conflict_do_update()</span></code></a> and
<a class="reference internal" href="../dialects/sqlite.html#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update" title="sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.on_conflict_do_update()</span></code></a> methods, which match to the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects in the <code class="docutils literal notranslate"><span class="pre">.c</span></code> collection of the target
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>. Previously,  only string column names were
expected; a column expression would be assumed to be an out-of-table
expression that would render fully along with a warning.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5722">#5722</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-50"><span class="target" id="change-923032dbb910364fe3e9603b05c1511f"><strong>[postgresql] [bug] [asyncio]</strong> <a class="changelog-reference headerlink reference internal" href="#change-923032dbb910364fe3e9603b05c1511f">¶</a></span><p>Fixed bug in asyncpg dialect where a failure during a “commit” or less
likely a “rollback” should cancel the entire transaction; it’s no longer
possible to emit rollback. Previously the connection would continue to
await a rollback that could not succeed as asyncpg would reject it.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5824">#5824</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-mysql">
<h3>mysql<a class="headerlink" href="#change-1.4.0b2-mysql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-51"><span class="target" id="change-74d96a749cc428fe9183aed213b6d149"><strong>[mysql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-74d96a749cc428fe9183aed213b6d149">¶</a></span><p>Added support for the aiomysql driver when using the asyncio SQLAlchemy
extension.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/mysql.html#aiomysql"><span class="std std-ref">aiomysql</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5747">#5747</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-52"><span class="target" id="change-9ed6cce8eb8102923c961166672d152f"><strong>[mysql] [bug] [reflection]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9ed6cce8eb8102923c961166672d152f">¶</a></span><p>Fixed issue where reflecting a server default on MariaDB only that
contained a decimal point in the value would fail to be reflected
correctly, leading towards a reflected table that lacked any server
default.</p>
<p>This change is also <strong>backported</strong> to: 1.3.21</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5744">#5744</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-sqlite">
<h3>sqlite<a class="headerlink" href="#change-1.4.0b2-sqlite" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-53"><span class="target" id="change-ae5ec81116fd9e4afd016bd9db210dde"><strong>[sqlite] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ae5ec81116fd9e4afd016bd9db210dde">¶</a></span><p>Implemented INSERT… ON CONFLICT clause for SQLite. Pull request courtesy
Ramon Williams.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/sqlite.html#sqlite-on-conflict-insert"><span class="std std-ref">INSERT…ON CONFLICT (Upsert)</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4010">#4010</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-54"><span class="target" id="change-a008444b761a781daf968af60aff3a7d"><strong>[sqlite] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a008444b761a781daf968af60aff3a7d">¶</a></span><p>Use python <code class="docutils literal notranslate"><span class="pre">re.search()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">re.match()</span></code> as the operation
used by the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Column.regexp_match()</span></code> method when using sqlite.
This matches the behavior of regular expressions on other databases
as well as that of well-known SQLite plugins.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5699">#5699</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.0b2-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-55"><span class="target" id="change-f243bb8d34d89aac79476a68da1b01de"><strong>[mssql] [bug] [datatypes] [mysql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f243bb8d34d89aac79476a68da1b01de">¶</a></span><p>Decimal accuracy and behavior has been improved when extracting floating
point and/or decimal values from JSON strings using the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Comparator.as_float()</span></code> method, when the numeric
value inside of the JSON string has many significant digits; previously,
MySQL backends would truncate values with many significant digits and SQL
Server backends would raise an exception due to a DECIMAL cast with
insufficient significant digits.   Both backends now use a FLOAT-compatible
approach that does not hardcode significant digits for floating point
values. For precision numerics, a new method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Comparator.as_numeric()</span></code> has been added which
accepts arguments for precision and scale, and will return values as Python
<code class="docutils literal notranslate"><span class="pre">Decimal</span></code> objects with no floating point conversion assuming the DBAPI
supports it (all but pysqlite).</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5788">#5788</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-oracle">
<h3>oracle<a class="headerlink" href="#change-1.4.0b2-oracle" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-56"><span class="target" id="change-1345cceac1c6de48af0b27ce77c79cd2"><strong>[oracle] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-1345cceac1c6de48af0b27ce77c79cd2">¶</a></span><p>Fixed regression which occured due to <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5755">#5755</a> which implemented
isolation level support for Oracle.   It has been reported that many Oracle
accounts don’t actually have permission to query the <code class="docutils literal notranslate"><span class="pre">v$transaction</span></code>
view so this feature has been altered to gracefully fallback when it fails
upon database connect, where the dialect will assume “READ COMMITTED” is
the default isolation level as was the case prior to SQLAlchemy 1.3.21.
However, explicit use of the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level" title="sqlalchemy.engine.Connection.get_isolation_level"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.get_isolation_level()</span></code></a>
method must now necessarily raise an exception, as Oracle databases with
this restriction explicitly disallow the user from reading the current
isolation level.</p>
<p>This change is also <strong>backported</strong> to: 1.3.22</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5784">#5784</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-57"><span class="target" id="change-9f309ea5b1d788ddb3fa465ff65a295b"><strong>[oracle] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9f309ea5b1d788ddb3fa465ff65a295b">¶</a></span><p>Oracle two-phase transactions at a rudimentary level are now no longer
deprecated. After receiving support from cx_Oracle devs we can provide for
basic xid + begin/prepare support with some limitations, which will work
more fully in an upcoming release of cx_Oracle. Two phase “recovery” is not
currently supported.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5884">#5884</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-58"><span class="target" id="change-36fda2ade27ab7b9b55aa843100168e7"><strong>[oracle] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-36fda2ade27ab7b9b55aa843100168e7">¶</a></span><p>The Oracle dialect now uses
<code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">sys_context(</span> <span class="pre">'userenv',</span> <span class="pre">'current_schema'</span> <span class="pre">)</span> <span class="pre">from</span> <span class="pre">dual</span></code> to get
the default schema name, rather than <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">USER</span> <span class="pre">FROM</span> <span class="pre">DUAL</span></code>, to
accommodate for changes to the session-local schema name under Oracle.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5716">#5716</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b2-misc">
<h3>misc<a class="headerlink" href="#change-1.4.0b2-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b2-59"><span class="target" id="change-ca3d469417a9c2c5ccec9ca30c2daa4c"><strong>[usecase] [pool] [tests]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ca3d469417a9c2c5ccec9ca30c2daa4c">¶</a></span><p>Improve documentation and add test for sub-second pool timeouts.
Pull request courtesy Jordan Pittier.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5582">#5582</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-60"><span class="target" id="change-a231acde7b90a23cfc45515f70c94e15"><strong>[usecase] [pool]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a231acde7b90a23cfc45515f70c94e15">¶</a></span><p>The internal mechanics of the engine connection routine has been altered
such that it’s now guaranteed that a user-defined event handler for the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">PoolEvents.connect()</span></code> handler, when established using
<code class="docutils literal notranslate"><span class="pre">insert=True</span></code>, will allow an event handler to run that is definitely
invoked <strong>before</strong> any dialect-specific initialization starts up, most
notably when it does things like detect default schema name.
Previously, this would occur in most cases but not unconditionally.
A new example is added to the schema documentation illustrating how to
establish the “default schema name” within an on-connect event.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5497">#5497</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5708">#5708</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-61"><span class="target" id="change-f484659b6eda604bfd2acd784de89c1a"><strong>[bug] [reflection]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f484659b6eda604bfd2acd784de89c1a">¶</a></span><p>Fixed bug where the now-deprecated <code class="docutils literal notranslate"><span class="pre">autoload</span></code> parameter was being called
internally within the reflection routines when a related table were
reflected.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5684">#5684</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-62"><span class="target" id="change-07ad52fabcb1015deee8c5130b1c2266"><strong>[bug] [pool]</strong> <a class="changelog-reference headerlink reference internal" href="#change-07ad52fabcb1015deee8c5130b1c2266">¶</a></span><p>Fixed regression where a connection pool event specified with a keyword,
most notably <code class="docutils literal notranslate"><span class="pre">insert=True</span></code>, would be lost when the event were set up.
This would prevent startup events that need to fire before dialect-level
events from working correctly.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5708">#5708</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b2-63"><span class="target" id="change-48f6485863a6067180c3e538e0fb0ed0"><strong>[bug] [pool] [pypy]</strong> <a class="changelog-reference headerlink reference internal" href="#change-48f6485863a6067180c3e538e0fb0ed0">¶</a></span><p>Fixed issue where connection pool would not return connections to the pool
or otherwise be finalized upon garbage collection under pypy if the checked
out connection fell out of scope without being closed.   This is a long
standing issue due to pypy’s difference in GC behavior that does not call
weakref finalizers if they are relative to another object that is also
being garbage collected.  A strong reference to the related record is now
maintained so that the weakref has a strong-referenced “base” to trigger
off of.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5842">#5842</a></p>
</p>
</li>
</ul>
</section>
</section>
<section id="change-1.4.0b1">
<h2 class="release-version">1.4.0b1<a class="headerlink" href="#change-1.4.0b1" title="Permalink to this headline">¶</a></h2>
Released: November 2, 2020<section id="change-1.4.0b1-general">
<h3>general<a class="headerlink" href="#change-1.4.0b1-general" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-0"><span class="target" id="change-22b90430465e9ee035069c4877c14e7f"><strong>[general] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-22b90430465e9ee035069c4877c14e7f">¶</a></span><p>”python setup.py test” is no longer a test runner, as this is deprecated by
Pypa.   Please use “tox” with no arguments for a basic test run.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4789">#4789</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-1"><span class="target" id="change-4e7006bf1f74f6aa206760e1b0d9de67"><strong>[general] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4e7006bf1f74f6aa206760e1b0d9de67">¶</a></span><p>Refactored the internal conventions used to cross-import modules that have
mutual dependencies between them, such that the inspected arguments of
functions and methods are no longer modified.  This allows tools like
pylint, Pycharm, other code linters, as well as hypothetical pep-484
implementations added in the future to function correctly as they no longer
see missing arguments to function calls.   The new approach is also
simpler and more performant.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4656"><span class="std std-ref">Repaired internal importing conventions such that code linters may work correctly</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4656">#4656</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4689">#4689</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-platform">
<h3>platform<a class="headerlink" href="#change-1.4.0b1-platform" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-2"><span class="target" id="change-a53b112767e3af163d7e92b15800f0a0"><strong>[platform] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a53b112767e3af163d7e92b15800f0a0">¶</a></span><p>The <code class="docutils literal notranslate"><span class="pre">importlib_metadata</span></code> library is used to scan for setuptools
entrypoints rather than pkg_resources.   as importlib_metadata is a small
library that is included as of Python 3.8, the compatibility library is
installed as a dependency for Python versions older than 3.8.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5400">#5400</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-3"><span class="target" id="change-92b1aa1e144fcadcb17ef129bf1f5996"><strong>[platform] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-92b1aa1e144fcadcb17ef129bf1f5996">¶</a></span><p>Installation has been modernized to use setup.cfg for most package
metadata.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5404">#5404</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-4"><span class="target" id="change-f814d2919aaf5a56b06fed34b031638a"><strong>[platform] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f814d2919aaf5a56b06fed34b031638a">¶</a></span><p>Dropped support for python 3.4 and 3.5 that has reached EOL. SQLAlchemy 1.4
series requires python 2.7 or 3.6+.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5634"><span class="std std-ref">Python 3.6 is the minimum Python 3 version; Python 2.7 still supported</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5634">#5634</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-5"><span class="target" id="change-8334d0f6902cd6997ca5d71ec25ec4b6"><strong>[platform] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8334d0f6902cd6997ca5d71ec25ec4b6">¶</a></span><p>Removed all dialect code related to support for Jython and zxJDBC. Jython
has not been supported by SQLAlchemy for many years and it is not expected
that the current zxJDBC code is at all functional; for the moment it just
takes up space and adds confusion by showing up in documentation. At the
moment, it appears that Jython has achieved Python 2.7 support in its
releases but not Python 3.   If Jython were to be supported again, the form
it should take is against the Python 3 version of Jython, and the various
zxJDBC stubs for various backends should be implemented as a third party
dialect.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5094">#5094</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-orm">
<h3>orm<a class="headerlink" href="#change-1.4.0b1-orm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-6"><span class="target" id="change-5114f33c9a97a39b00063240a2a0a31b"><strong>[orm] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5114f33c9a97a39b00063240a2a0a31b">¶</a></span><p>The ORM can now generate queries previously only available when using
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct directly.
A new system by which ORM “plugins” may establish themselves within a
Core <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> allow the majority of query building logic
previously inside of <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> to now take place within
a compilation-level extension for <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>.  Similar changes
have been made for the <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Update" title="sqlalchemy.sql.expression.Update"><code class="xref py py-class docutils literal notranslate"><span class="pre">Update</span></code></a> and <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Delete" title="sqlalchemy.sql.expression.Delete"><code class="xref py py-class docutils literal notranslate"><span class="pre">Delete</span></code></a>
constructs as well.  The constructs when invoked using <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>
now do ORM-related work within the method. For <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>,
the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object returned now contains ORM-level
entities and results.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5159"><span class="std std-ref">ORM Query is internally unified with select, update, delete; 2.0 style execution available</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5159">#5159</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-7"><span class="target" id="change-a882bd179a7fcb7892c61379524f4004"><strong>[orm] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a882bd179a7fcb7892c61379524f4004">¶</a></span><p>Added the ability to add arbitrary criteria to the ON clause generated
by a relationship attribute in a query, which applies to methods such
as <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> as well as loader options like
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>.   Additionally, a “global” version of the option
allows limiting criteria to be applied to particular entities in
a query globally.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/loading_relationships.html#loader-option-criteria"><span class="std std-ref">Adding Criteria to loader options</span></a></p>
<p><a class="reference internal" href="../orm/session_events.html#do-orm-execute-global-criteria"><span class="std std-ref">Adding global WHERE / ON criteria</span></a></p>
<p><a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_loader_criteria" title="sqlalchemy.orm.with_loader_criteria"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_loader_criteria()</span></code></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4472">#4472</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-8"><span class="target" id="change-1383b8655e1f94451338941a393cdca6"><strong>[orm] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-1383b8655e1f94451338941a393cdca6">¶</a></span><p>The ORM Declarative system is now unified into the ORM itself, with new
import spaces under <code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm</span></code> and new kinds of mappings.  Support
for decorator-based mappings without using a base class, support for
classical style-mapper() calls that have access to the declarative class
registry for relationships, and full integration of Declarative with 3rd
party class attribute systems like <code class="docutils literal notranslate"><span class="pre">dataclasses</span></code> and <code class="docutils literal notranslate"><span class="pre">attrs</span></code> is now
supported.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5508"><span class="std std-ref">Declarative is now integrated into the ORM with new features</span></a></p>
<p><a class="reference internal" href="migration_14.html#change-5027"><span class="std std-ref">Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5508">#5508</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-9"><span class="target" id="change-f9bee279324b578fab504bfb447d1c29"><strong>[orm] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f9bee279324b578fab504bfb447d1c29">¶</a></span><p>Eager loaders, such as joined loading, SELECT IN loading, etc., when
configured on a mapper or via query options will now be invoked during
the refresh on an expired object; in the case of selectinload and
subqueryload, since the additional load is for a single object only,
the “immediateload” scheme is used in these cases which resembles the
single-parent query emitted by lazy loading.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-1763"><span class="std std-ref">Eager loaders emit during unexpire operations</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1763">#1763</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-10"><span class="target" id="change-5b3c1379990592e4e93ddf935a54ff44"><strong>[orm] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5b3c1379990592e4e93ddf935a54ff44">¶</a></span><p>Added support for direct mapping of Python classes that are defined using
the Python <code class="docutils literal notranslate"><span class="pre">dataclasses</span></code> decorator.    Pull request courtesy Václav
Klusák.  The new feature integrates into new support at the Declarative
level for systems such as <code class="docutils literal notranslate"><span class="pre">dataclasses</span></code> and <code class="docutils literal notranslate"><span class="pre">attrs</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5027"><span class="std std-ref">Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings</span></a></p>
<p><a class="reference internal" href="migration_14.html#change-5508"><span class="std std-ref">Declarative is now integrated into the ORM with new features</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5027">#5027</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-11"><span class="target" id="change-947f8b8de5d7d84b3abb4b26b4bc9ef6"><strong>[orm] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-947f8b8de5d7d84b3abb4b26b4bc9ef6">¶</a></span><p>Added “raiseload” feature for ORM mapped columns via <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.defer.params.raiseload" title="sqlalchemy.orm.defer"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">defer.raiseload</span></code></a>
parameter on <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.defer" title="sqlalchemy.orm.defer"><code class="xref py py-func docutils literal notranslate"><span class="pre">defer()</span></code></a> and <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.deferred" title="sqlalchemy.orm.deferred"><code class="xref py py-func docutils literal notranslate"><span class="pre">deferred()</span></code></a>.   This provides
similar behavior for column-expression mapped attributes as the
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a> option does for relationship mapped attributes.  The
change also includes some behavioral changes to deferred columns regarding
expiration; see the migration notes for details.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4826"><span class="std std-ref">Raiseload for Columns</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4826">#4826</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-12"><span class="target" id="change-881d13a872b2df20c49bc386a479d7a7"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-881d13a872b2df20c49bc386a479d7a7">¶</a></span><p>The evaluator that takes place within the ORM bulk update and delete for
synchronize_session=”evaluate” now supports the IN and NOT IN operators.
Tuple IN is also supported.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1653">#1653</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-13"><span class="target" id="change-c1740609bf89afb7f1292259eb38c3c7"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c1740609bf89afb7f1292259eb38c3c7">¶</a></span><p>Enhanced logic that tracks if relationships will be conflicting with each
other when they write to the same column to include simple cases of two
relationships that should have a “backref” between them.   This means that
if two relationships are not viewonly, are not linked with back_populates
and are not otherwise in an inheriting sibling/overriding arrangement, and
will populate the same foreign key column, a warning is emitted at mapper
configuration time warning that a conflict may arise.  A new parameter
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.overlaps</span></code></a> is added to suit those very rare cases
where such an overlapping persistence arrangement may be unavoidable.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5171">#5171</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-14"><span class="target" id="change-121a60bf3a64b230461f90edf63ee5ae"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-121a60bf3a64b230461f90edf63ee5ae">¶</a></span><p>The ORM bulk update and delete operations, historically available via the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.update" title="sqlalchemy.orm.Query.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.update()</span></code></a> and <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.delete" title="sqlalchemy.orm.Query.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.delete()</span></code></a> methods as well as
via the <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Update" title="sqlalchemy.sql.expression.Update"><code class="xref py py-class docutils literal notranslate"><span class="pre">Update</span></code></a> and <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Delete" title="sqlalchemy.sql.expression.Delete"><code class="xref py py-class docutils literal notranslate"><span class="pre">Delete</span></code></a> constructs for
<a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> execution, will now automatically accommodate for the
additional WHERE criteria needed for a single-table inheritance
discriminator in order to limit the statement to rows referring to the
specific subtype requested.   The new <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.with_loader_criteria" title="sqlalchemy.orm.with_loader_criteria"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_loader_criteria()</span></code></a>
construct is also supported for with bulk update/delete operations.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/3903">#3903</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5018">#5018</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-15"><span class="target" id="change-55ac31bfa48eb1b4f5d0178d02144640"><strong>[orm] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-55ac31bfa48eb1b4f5d0178d02144640">¶</a></span><p>Update <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.sync_backref</span></code></a> flag in a relationship
to make it implicitly <code class="docutils literal notranslate"><span class="pre">False</span></code> in <code class="docutils literal notranslate"><span class="pre">viewonly=True</span></code> relationships,
preventing synchronization events.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5237-14"><span class="std std-ref">Viewonly relationships don’t synchronize backrefs</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5237">#5237</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-16"><span class="target" id="change-f7b996813d7921f404e0cc8457951f9a"><strong>[orm] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f7b996813d7921f404e0cc8457951f9a">¶</a></span><p>The condition where a pending object being flushed with an identity that
already exists in the identity map has been adjusted to emit a warning,
rather than throw a <a class="reference internal" href="../orm/exceptions.html#sqlalchemy.orm.exc.FlushError" title="sqlalchemy.orm.exc.FlushError"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlushError</span></code></a>. The rationale is so that the
flush will proceed and raise a <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.IntegrityError" title="sqlalchemy.exc.IntegrityError"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegrityError</span></code></a> instead, in the
same way as if the existing object were not present in the identity map
already.   This helps with schemes that are using the
<a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.IntegrityError" title="sqlalchemy.exc.IntegrityError"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegrityError</span></code></a> as a means of catching whether or not a row
already exists in the table.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4662"><span class="std std-ref">The “New instance conflicts with existing identity” error is now a warning</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4662">#4662</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-17"><span class="target" id="change-26d7397576b5043799bb4b12603ca2fb"><strong>[orm] [change] [sql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-26d7397576b5043799bb4b12603ca2fb">¶</a></span><p>A selection of Core and ORM query objects now perform much more of their
Python computational tasks within the compile step, rather than at
construction time.  This is to support an upcoming caching model that will
provide for caching of the compiled statement structure based on a cache
key that is derived from the statement construct, which itself is expected
to be newly constructed in Python code each time it is used.    This means
that the internal state of these objects may not be the same as it used to
be, as well as that some but not all error raise scenarios for various
kinds of argument validation will occur within the compilation / execution
phase, rather than at statement construction time.   See the migration
notes linked below for complete details.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-deferred-construction"><span class="std std-ref">Many Core and ORM statement objects now perform much of their construction and validation in the compile phase</span></a></p>
</div>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-18"><span class="target" id="change-30a45391c76d8cd9e8e0999e29109fd9"><strong>[orm] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-30a45391c76d8cd9e8e0999e29109fd9">¶</a></span><p>The automatic uniquing of rows on the client side is turned off for the new
<a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> of ORM querying.  This improves both clarity and
performance.  However, uniquing of rows on the client side is generally
necessary when using joined eager loading for collections, as there
will be duplicates of the primary entity for each element in the
collection because a join was used.  This uniquing must now be manually
enabled and can be achieved using the new
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.unique" title="sqlalchemy.engine.Result.unique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.unique()</span></code></a> modifier.   To avoid silent failure, the ORM
explicitly requires the method be called when the result of an ORM
query in 2.0 style makes use of joined load collections.    The newer
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> strategy is likely preferable for eager loading
of collections in any case.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html#joinedload-not-uniqued"><span class="std std-ref">ORM Rows not uniquified by default</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4395">#4395</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-19"><span class="target" id="change-eb18d201ebe7209056b7c9d54f986b9e"><strong>[orm] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-eb18d201ebe7209056b7c9d54f986b9e">¶</a></span><p>The ORM will now warn when asked to coerce a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct into
a subquery implicitly.  This occurs within places such as the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.select_entity_from" title="sqlalchemy.orm.Query.select_entity_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.select_entity_from()</span></code></a> and  <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.select_from" title="sqlalchemy.orm.Query.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.select_from()</span></code></a> methods
as well as within the <a class="reference internal" href="../orm/inheritance_loading.html#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_polymorphic()</span></code></a> function.  When a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase" title="sqlalchemy.sql.expression.SelectBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectBase</span></code></a> (which is what’s produced by <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>) or
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object is passed directly to these functions and others,
the ORM is typically coercing them to be a subquery by calling the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias" title="sqlalchemy.sql.expression.SelectBase.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.alias()</span></code></a> method automatically (which is now superseded by
the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a> method).   See the migration notes linked
below for further details.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4617"><span class="std std-ref">A SELECT statement is no longer implicitly considered to be a FROM clause</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-20"><span class="target" id="change-f461678c6ce516f72c74428e49a805b3"><strong>[orm] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f461678c6ce516f72c74428e49a805b3">¶</a></span><p>The “KeyedTuple” class returned by <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> is now replaced with the
Core <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> class, which behaves in the same way as KeyedTuple.
In SQLAlchemy 2.0, both Core and ORM will return result rows using the same
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> object.   In the interim, Core uses a backwards-compatibility
class <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a> that maintains the former mapping/tuple hybrid
behavior used by “RowProxy”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4710-orm"><span class="std std-ref">The “KeyedTuple” object returned by Query is replaced by Row</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4710">#4710</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-21"><span class="target" id="change-a3f6a7b89bebcd922012f5be50b9609c"><strong>[orm] [performance]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a3f6a7b89bebcd922012f5be50b9609c">¶</a></span><p>The bulk update and delete methods <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.update" title="sqlalchemy.orm.Query.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.update()</span></code></a> and
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.delete" title="sqlalchemy.orm.Query.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.delete()</span></code></a>, as well as their 2.0-style counterparts, now make
use of RETURNING when the “fetch” strategy is used in order to fetch the
list of affected primary key identites, rather than emitting a separate
SELECT, when the backend in use supports RETURNING.  Additionally, the
“fetch” strategy will in ordinary cases not expire the attributes that have
been updated, and will instead apply the updated values directly in the
same way that the “evaluate” strategy does, to avoid having to refresh the
object.   The “evaluate” strategy will also fall back to expiring
attributes that were updated to a SQL expression that was unevaluable in
Python.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-orm-update-returning-14"><span class="std std-ref">ORM Bulk Update and Delete use RETURNING for “fetch” strategy when available</span></a></p>
</div>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-22"><span class="target" id="change-19a336ee96986522f56cb530f6ec19fd"><strong>[orm] [performance] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-19a336ee96986522f56cb530f6ec19fd">¶</a></span><p>Implemented support for the psycopg2 <code class="docutils literal notranslate"><span class="pre">execute_values()</span></code> extension
within the ORM flush process via the enhancements to Core made
in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5401">#5401</a>, so that this extension is used
both as a strategy to batch INSERT statements together as well as
that RETURNING may now be used among multiple parameter sets to
retrieve primary key values back in batch.   This allows nearly
all INSERT statements emitted by the ORM on behalf of PostgreSQL
to be submitted in batch and also via the <code class="docutils literal notranslate"><span class="pre">execute_values()</span></code>
extension which benches at five times faster than plain
executemany() for this particular backend.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5263"><span class="std std-ref">ORM Batch inserts with psycopg2 now batch statements with RETURNING in most cases</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5263">#5263</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-23"><span class="target" id="change-72c5443b262e921e34d41dd08ebb5bc6"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-72c5443b262e921e34d41dd08ebb5bc6">¶</a></span><p>A query that is against a mapped inheritance subclass which also uses
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.select_entity_from" title="sqlalchemy.orm.Query.select_entity_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.select_entity_from()</span></code></a> or a similar technique in order  to
provide an existing subquery to SELECT from, will now raise an error if the
given subquery returns entities that do not correspond to the given
subclass, that is, they are sibling or superclasses in the same hierarchy.
Previously, these would be returned without error.  Additionally, if the
inheritance mapping is a single-inheritance mapping, the given subquery
must apply the appropriate filtering against the polymorphic discriminator
column in order to avoid this error; previously, the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> would
add this criteria to the outside query however this interferes with some
kinds of query that return other kinds of entities as well.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5122"><span class="std std-ref">Stricter behavior when querying inheritance mappings using custom queries</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5122">#5122</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-24"><span class="target" id="change-a9e418db480af7ff87ac02f92f354b4b"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a9e418db480af7ff87ac02f92f354b4b">¶</a></span><p>The internal attribute symbols NO_VALUE and NEVER_SET have been unified, as
there was no meaningful difference between these two symbols, other than a
few codepaths where they were differentiated in subtle and undocumented
ways, these have been fixed.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4696">#4696</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-25"><span class="target" id="change-0c681d44fccd2f0216ce0df6c4dee88b"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0c681d44fccd2f0216ce0df6c4dee88b">¶</a></span><p>Fixed bug where a versioning column specified on a mapper against a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct where the version_id_col itself were against the
underlying table would incur additional loads when accessed, even if the
value were locally persisted by the flush.  The actual fix is a result of
the changes in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a>,  by fact that a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> object no
longer has a <code class="docutils literal notranslate"><span class="pre">.c</span></code> attribute and therefore does not confuse the mapper
into thinking there’s an unknown column value present.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4194">#4194</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-26"><span class="target" id="change-8ac43a4be5a411feb59017a7e3a957b3"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8ac43a4be5a411feb59017a7e3a957b3">¶</a></span><p>An <code class="docutils literal notranslate"><span class="pre">UnmappedInstanceError</span></code> is now raised for <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstrumentedAttribute" title="sqlalchemy.orm.InstrumentedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentedAttribute</span></code></a>
if an instance is an unmapped object. Prior to this an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>
was raised. Pull request courtesy Ramon Williams.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/3858">#3858</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-27"><span class="target" id="change-3a765e29f0de41ba2cacef5dcc085838"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3a765e29f0de41ba2cacef5dcc085838">¶</a></span><p>The <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> object no longer initiates a
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a> object immediately upon construction or after
the previous transaction is closed; instead, “autobegin” logic now
initiates the new <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a> on demand when it is next
needed.  Rationale includes to remove reference cycles from a
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> that has been closed out, as well as to remove the
overhead incurred by the creation of <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a> objects
that are often discarded immediately. This change affects the behavior of
the <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create" title="sqlalchemy.orm.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.after_transaction_create()</span></code></a> hook in that the event
will be emitted when the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> first requires a
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a> be present, rather than whenever the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> were created or the previous <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a>
were closed.   Interactions with the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> and the database
itself remain unaffected.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5074"><span class="std std-ref">Session features new “autobegin” behavior</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5074">#5074</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-28"><span class="target" id="change-0ea69c5380bbb461a21c8b4ef19a56bc"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0ea69c5380bbb461a21c8b4ef19a56bc">¶</a></span><p>Added new entity-targeting capabilities to the ORM query context
help with the case where the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> is using a bind dictionary
against mapped classes, rather than a single bind, and the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
is against a Core statement that was ultimately generated from a method
such as <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.subquery" title="sqlalchemy.orm.Query.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.subquery()</span></code></a>.  First implemented using a deep
search, the current approach leverages the unified <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>
construct to keep track of the first mapper that is part of
the construct.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4829">#4829</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-29"><span class="target" id="change-036219e4f3e372316308052142ed4bcc"><strong>[orm] [bug] [inheritance]</strong> <a class="changelog-reference headerlink reference internal" href="#change-036219e4f3e372316308052142ed4bcc">¶</a></span><p>An <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.ArgumentError" title="sqlalchemy.exc.ArgumentError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArgumentError</span></code></a> is now raised if both the <code class="docutils literal notranslate"><span class="pre">selectable</span></code> and
<code class="docutils literal notranslate"><span class="pre">flat</span></code> parameters are set to True in <a class="reference internal" href="../orm/inheritance_loading.html#sqlalchemy.orm.with_polymorphic" title="sqlalchemy.orm.with_polymorphic"><code class="xref py py-func docutils literal notranslate"><span class="pre">with_polymorphic()</span></code></a>. The
selectable name is already aliased and applying flat=True overrides the
selectable name with an anonymous name that would’ve previously caused the
code to break. Pull request courtesy Ramon Williams.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4212">#4212</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-30"><span class="target" id="change-6562289bfd42b51ab7d445027e4fa2fa"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6562289bfd42b51ab7d445027e4fa2fa">¶</a></span><p>Fixed issue in polymorphic loading internals which would fall back to a
more expensive, soon-to-be-deprecated form of result column lookup within
certain unexpiration scenarios in conjunction with the use of
“with_polymorphic”.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4718">#4718</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-31"><span class="target" id="change-9d958e3bbe18b1bfd43e0f3f2c1d64fa"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9d958e3bbe18b1bfd43e0f3f2c1d64fa">¶</a></span><p>An error is raised if any persistence-related “cascade” settings are made
on a <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> that also sets up viewonly=True.   The “cascade”
settings now default to non-persistence related settings only when viewonly
is also set.  This is the continuation from <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4993">#4993</a> where this
setting was changed to emit a warning in 1.3.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4994"><span class="std std-ref">Persistence-related cascade operations disallowed with viewonly=True</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4994">#4994</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-32"><span class="target" id="change-dae2d49d4e57f5bee2f3327be9803fe7"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-dae2d49d4e57f5bee2f3327be9803fe7">¶</a></span><p>Improved declarative inheritance scanning to not get tripped up when the
same base class appears multiple times in the base inheritance list.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4699">#4699</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-33"><span class="target" id="change-4275bd1bea57996cac100db95064b7a3"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4275bd1bea57996cac100db95064b7a3">¶</a></span><p>Fixed bug in ORM versioning feature where assignment of an explicit
version_id for a counter configured against a mapped selectable where
version_id_col is against the underlying table would fail if the previous
value were expired; this was due to the fact that the  mapped attribute
would not be configured with active_history=True.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4195">#4195</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-34"><span class="target" id="change-b42e3ab2bee3e4690bfda418d7b8e0fb"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b42e3ab2bee3e4690bfda418d7b8e0fb">¶</a></span><p>An exception is now raised if the ORM loads a row for a polymorphic
instance that has a primary key but the discriminator column is NULL, as
discriminator columns should not be null.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4836">#4836</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-35"><span class="target" id="change-e810b84072bbbf72393203e43779675c"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e810b84072bbbf72393203e43779675c">¶</a></span><p>Accessing a collection-oriented attribute on a newly created object no
longer mutates <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>, but still returns an empty collection as has
always been the case.   This allows collection-oriented attributes to work
consistently in comparison to scalar attributes which return <code class="docutils literal notranslate"><span class="pre">None</span></code>, but
also don’t mutate <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>.  In order to accommodate for the collection
being mutated, the same empty collection is returned each time once
initially created, and when it is mutated (e.g. an item appended, added,
etc.) it is then moved into <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>.  This removes the last of
mutating side-effects on read-only attribute access within the ORM.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4519"><span class="std std-ref">Accessing an uninitialized collection attribute on a transient object no longer mutates __dict__</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4519">#4519</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-36"><span class="target" id="change-075c49c37669ec79de85622ee14a5cfd"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-075c49c37669ec79de85622ee14a5cfd">¶</a></span><p>The refresh of an expired object will now trigger an autoflush if the list
of expired attributes include one or more attributes that were explicitly
expired or refreshed using the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.expire" title="sqlalchemy.orm.Session.expire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expire()</span></code></a> or
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.refresh" title="sqlalchemy.orm.Session.refresh"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.refresh()</span></code></a> methods.   This is an attempt to find a middle
ground between the normal unexpiry of attributes that can happen in many
cases where autoflush is not desirable, vs. the case where attributes are
being explicitly expired or refreshed and it is possible that these
attributes depend upon other pending state within the session that needs to
be flushed.   The two methods now also gain a new flag
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.expire.params.autoflush" title="sqlalchemy.orm.Session.expire"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.expire.autoflush</span></code></a> and
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.refresh.params.autoflush" title="sqlalchemy.orm.Session.refresh"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.refresh.autoflush</span></code></a>, defaulting to True; when set to
False, this will disable the autoflush that occurs on unexpire for these
attributes.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5226">#5226</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-37"><span class="target" id="change-b4b9f9c117e3fb8fe690e602a6b2cb66"><strong>[orm] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b4b9f9c117e3fb8fe690e602a6b2cb66">¶</a></span><p>The behavior of the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade_backrefs</span></code></a> flag
will be reversed in 2.0 and set to <code class="docutils literal notranslate"><span class="pre">False</span></code> unconditionally, such that
backrefs don’t cascade save-update operations from a forwards-assignment to
a backwards assignment.   A 2.0 deprecation warning is emitted when the
parameter is left at its default of <code class="docutils literal notranslate"><span class="pre">True</span></code> at the point at which such a
cascade operation actually takes place.   The new behavior can be
established as always by setting the flag to <code class="docutils literal notranslate"><span class="pre">False</span></code> on a specific
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>, or more generally can be set up across the board
by setting the the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.params.future" title="sqlalchemy.orm.Session"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.future</span></code></a> flag to True.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5150"><span class="std std-ref">cascade_backrefs behavior deprecated for removal in 2.0</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5150">#5150</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-38"><span class="target" id="change-f3597d359b7048ac8c93b746056172c6"><strong>[orm] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f3597d359b7048ac8c93b746056172c6">¶</a></span><p>The “slice index” feature used by <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> as well as by the
dynamic relationship loader will no longer accept negative indexes in
SQLAlchemy 2.0.  These operations do not work efficiently and load the
entire collection in, which is both surprising and undesirable.   These
will warn in 1.4 unless the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.params.future" title="sqlalchemy.orm.Session"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.future</span></code></a> flag is set in
which case they will raise IndexError.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5606">#5606</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-39"><span class="target" id="change-8e1e32675a716d4b7225ce15bbdc7856"><strong>[orm] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8e1e32675a716d4b7225ce15bbdc7856">¶</a></span><p>Calling the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.instances" title="sqlalchemy.orm.Query.instances"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.instances()</span></code></a> method without passing a
<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.QueryContext" title="sqlalchemy.orm.QueryContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueryContext</span></code></a> is deprecated.   The original use case for this was
that a <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> could yield ORM objects when given only the entities
to be selected as well as a DBAPI cursor object.  However, for this to work
correctly there is essential metadata that is passed from a SQLAlchemy
<code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code> that is derived from the mapped column expressions,
which comes originally from the <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.QueryContext" title="sqlalchemy.orm.QueryContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueryContext</span></code></a>.   To retrieve ORM
results from arbitrary SELECT statements, the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.from_statement" title="sqlalchemy.orm.Query.from_statement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.from_statement()</span></code></a>
method should be used.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4719">#4719</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-40"><span class="target" id="change-8101ea772445346cb198d84764be8e7a"><strong>[orm] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8101ea772445346cb198d84764be8e7a">¶</a></span><p>Using strings to represent relationship names in ORM operations such as
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>, as well as strings for all ORM attribute names
in loader options like <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a>
is deprecated and will be removed in SQLAlchemy 2.0.  The class-bound
attribute should be passed instead.  This provides much better specificity
to the given method, allows for modifiers such as <code class="docutils literal notranslate"><span class="pre">of_type()</span></code>, and
reduces internal complexity.</p>
<p>Additionally, the <code class="docutils literal notranslate"><span class="pre">aliased</span></code> and <code class="docutils literal notranslate"><span class="pre">from_joinpoint</span></code> parameters to
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> are also deprecated.   The <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a>
construct now provides for a great deal of flexibility and capability
and should be used directly.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html#migration-20-orm-query-join-strings"><span class="std std-ref">ORM Query  - Joining / loading on relationships uses attributes, not strings</span></a></p>
<p><a class="reference internal" href="migration_20.html#migration-20-query-join-options"><span class="std std-ref">ORM Query - join(…, aliased=True), from_joinpoint removed</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4705">#4705</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5202">#5202</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-41"><span class="target" id="change-b2e18f8a880fe1298d5ab33ea2e1a524"><strong>[orm] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b2e18f8a880fe1298d5ab33ea2e1a524">¶</a></span><p>Deprecated logic in <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.distinct" title="sqlalchemy.orm.Query.distinct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.distinct()</span></code></a> that automatically adds
columns in the ORDER BY clause to the columns clause; this will be removed
in 2.0.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html#migration-20-query-distinct"><span class="std std-ref">Using DISTINCT with additional columns, but only select the entity</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5134">#5134</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-42"><span class="target" id="change-e1ea1d4266de6d541c60476b1916497c"><strong>[orm] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e1ea1d4266de6d541c60476b1916497c">¶</a></span><p>Passing keyword arguments to methods such as <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>
to be passed into the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.get_bind" title="sqlalchemy.orm.Session.get_bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.get_bind()</span></code></a> method is deprecated;
the new <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute.params.bind_arguments" title="sqlalchemy.orm.Session.execute"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.execute.bind_arguments</span></code></a> dictionary should
be passed instead.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5573">#5573</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-43"><span class="target" id="change-f4278925c3d2f63176f302eff6b8a745"><strong>[orm] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f4278925c3d2f63176f302eff6b8a745">¶</a></span><p>The <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.eagerload" title="sqlalchemy.orm.eagerload"><code class="xref py py-func docutils literal notranslate"><span class="pre">eagerload()</span></code></a> and <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relation" title="sqlalchemy.orm.relation"><code class="xref py py-func docutils literal notranslate"><span class="pre">relation()</span></code></a> were old aliases and are
now deprecated. Use <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> and <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>
respectively.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5192">#5192</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-44"><span class="target" id="change-6daf2f59ac2438ef9c8213e9ebeac157"><strong>[orm] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6daf2f59ac2438ef9c8213e9ebeac157">¶</a></span><p>All long-deprecated “extension” classes have been removed, including
MapperExtension, SessionExtension, PoolListener, ConnectionProxy,
AttributeExtension.  These classes have been deprecated since version 0.7
long superseded by the event listener system.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4638">#4638</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-45"><span class="target" id="change-8d8456461762e0f42fe2a237b5be160e"><strong>[orm] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8d8456461762e0f42fe2a237b5be160e">¶</a></span><p>Remove the deprecated loader options <code class="docutils literal notranslate"><span class="pre">joinedload_all</span></code>, <code class="docutils literal notranslate"><span class="pre">subqueryload_all</span></code>,
<code class="docutils literal notranslate"><span class="pre">lazyload_all</span></code>, <code class="docutils literal notranslate"><span class="pre">selectinload_all</span></code>. The normal version with method chaining
should be used in their place.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4642">#4642</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-46"><span class="target" id="change-b2b94629c3428a7a3d1e7d10546de36f"><strong>[orm] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b2b94629c3428a7a3d1e7d10546de36f">¶</a></span><p>Remove deprecated function <code class="docutils literal notranslate"><span class="pre">comparable_property</span></code>. Please refer to the
<a class="reference internal" href="../orm/extensions/hybrid.html#module-sqlalchemy.ext.hybrid" title="sqlalchemy.ext.hybrid"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hybrid</span></code></a> extension. This also removes the function
<code class="docutils literal notranslate"><span class="pre">comparable_using</span></code> in the declarative extension.</p>
<p>Remove deprecated function <code class="docutils literal notranslate"><span class="pre">compile_mappers</span></code>.  Please use
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal notranslate"><span class="pre">configure_mappers()</span></code></a></p>
<p>Remove deprecated method <code class="docutils literal notranslate"><span class="pre">collection.linker</span></code>. Please refer to the
<a class="reference internal" href="../orm/events.html#sqlalchemy.orm.AttributeEvents.init_collection" title="sqlalchemy.orm.AttributeEvents.init_collection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AttributeEvents.init_collection()</span></code></a> and
<a class="reference internal" href="../orm/events.html#sqlalchemy.orm.AttributeEvents.dispose_collection" title="sqlalchemy.orm.AttributeEvents.dispose_collection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AttributeEvents.dispose_collection()</span></code></a> event handlers.</p>
<p>Remove deprecated method <code class="docutils literal notranslate"><span class="pre">Session.prune</span></code> and parameter
<code class="docutils literal notranslate"><span class="pre">Session.weak_identity_map</span></code>. See the recipe at
<a class="reference internal" href="../orm/session_state_management.html#session-referencing-behavior"><span class="std std-ref">Session Referencing Behavior</span></a> for an event-based approach to
maintaining strong identity references.
This change also removes the class <code class="docutils literal notranslate"><span class="pre">StrongInstanceDict</span></code>.</p>
<p>Remove deprecated parameter <code class="docutils literal notranslate"><span class="pre">mapper.order_by</span></code>. Use <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.order_by" title="sqlalchemy.orm.Query.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.order_by()</span></code></a>
to determine the ordering of a result set.</p>
<p>Remove deprecated parameter <code class="docutils literal notranslate"><span class="pre">Session._enable_transaction_accounting</span></code>.</p>
<p>Remove deprecated parameter <code class="docutils literal notranslate"><span class="pre">Session.is_modified.passive</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4643">#4643</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-engine">
<h3>engine<a class="headerlink" href="#change-1.4.0b1-engine" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-47"><span class="target" id="change-2c594e0c9f3b29b5c4547367ab9db8b9"><strong>[engine] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2c594e0c9f3b29b5c4547367ab9db8b9">¶</a></span><p>Implemented an all-new <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object that replaces the previous
<code class="docutils literal notranslate"><span class="pre">ResultProxy</span></code> object.   As implemented in Core, the subclass
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CursorResult" title="sqlalchemy.engine.CursorResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">CursorResult</span></code></a> features a compatible calling interface with the
previous <code class="docutils literal notranslate"><span class="pre">ResultProxy</span></code>, and additionally adds a great amount of new
functionality that can be applied to Core result sets as well as ORM result
sets, which are now integrated into the same model.   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>
includes features such as column selection and rearrangement, improved
fetchmany patterns, uniquing, as well as a variety of implementations that
can be used to create database results from in-memory structures as well.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-result-14-core"><span class="std std-ref">New Result object</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4395">#4395</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4959">#4959</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5087">#5087</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-48"><span class="target" id="change-3499a8dabcae789b8e8020a54141f5fc"><strong>[engine] [feature] [orm]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3499a8dabcae789b8e8020a54141f5fc">¶</a></span><p>SQLAlchemy now includes support for Python asyncio within both Core and
ORM, using the included <a class="reference internal" href="../orm/extensions/asyncio.html"><span class="std std-ref">asyncio extension</span></a>. The
extension makes use of the <a class="reference external" href="https://greenlet.readthedocs.io/en/latest/">greenlet</a> library in order to adapt
SQLAlchemy’s sync-oriented internals such that an asyncio interface that
ultimately interacts with an asyncio database adapter is now feasible.  The
single driver supported at the moment is the
<a class="reference internal" href="../dialects/postgresql.html#dialect-postgresql-asyncpg"><span class="std std-ref">asyncpg</span></a> driver for PostgreSQL.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-3414"><span class="std std-ref">Asynchronous IO Support for Core and ORM</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/3414">#3414</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-49"><span class="target" id="change-e97cecde19151583582d86d903abe9df"><strong>[engine] [feature] [alchemy2]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e97cecde19151583582d86d903abe9df">¶</a></span><p>Implemented the <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.future" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.future</span></code></a> parameter which
enables forwards compatibility with SQLAlchemy 2. is used for forwards
compatibility with SQLAlchemy 2.   This engine features
always-transactional behavior with autobegin.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html"><span class="std std-ref">Migrating to SQLAlchemy 2.0</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4644">#4644</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-50"><span class="target" id="change-e33a5d01d8e44a2904ce23dfb98b6dfe"><strong>[engine] [feature] [pyodbc]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e33a5d01d8e44a2904ce23dfb98b6dfe">¶</a></span><p>Reworked the “setinputsizes()” set of dialect hooks to be correctly
extensible for any arbirary DBAPI, by allowing dialects individual hooks
that may invoke cursor.setinputsizes() in the appropriate style for that
DBAPI.   In particular this is intended to support pyodbc’s style of usage
which is fundamentally different from that of cx_Oracle.  Added support
for pyodbc.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5649">#5649</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-51"><span class="target" id="change-f7aec00e66540d9537ba85f516d1e1e9"><strong>[engine] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f7aec00e66540d9537ba85f516d1e1e9">¶</a></span><p>Added new reflection method <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names" title="sqlalchemy.engine.reflection.Inspector.get_sequence_names"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_sequence_names()</span></code></a> which
returns all the sequences defined and <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence" title="sqlalchemy.engine.reflection.Inspector.has_sequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.has_sequence()</span></code></a> to
check if a particular sequence exits.
Support for this method has been added to the backend that support
<a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>: PostgreSQL, Oracle and MariaDB &gt;= 10.3.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/2056">#2056</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-52"><span class="target" id="change-75879c7f862c84c59981f9c8812f5faa"><strong>[engine] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-75879c7f862c84c59981f9c8812f5faa">¶</a></span><p>The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.autoload_with</span></code></a> parameter now accepts an <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector" title="sqlalchemy.engine.reflection.Inspector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code></a> object
directly, as well as any <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> or <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> as was the case before.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4755">#4755</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-53"><span class="target" id="change-92bef7dc44edac0974d25ec65ad1aecb"><strong>[engine] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-92bef7dc44edac0974d25ec65ad1aecb">¶</a></span><p>The <code class="docutils literal notranslate"><span class="pre">RowProxy</span></code> class is no longer a “proxy” object, and is instead
directly populated with the post-processed contents of the DBAPI row tuple
upon construction.   Now named <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>, the mechanics of how the
Python-level value processors have been simplified, particularly as it impacts the
format of the C code, so that a DBAPI row is processed into a result tuple
up front.   The object returned by the <code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code> is now the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a> subclass, which maintains mapping/tuple hybrid behavior,
however the base <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> class now behaves more fully like a named
tuple.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4710-core"><span class="std std-ref">RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4710">#4710</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-54"><span class="target" id="change-6bc91a2bef8d8afd244e6dbd38439c4d"><strong>[engine] [performance]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6bc91a2bef8d8afd244e6dbd38439c4d">¶</a></span><p>The pool “pre-ping” feature has been refined to not invoke for a DBAPI
connection that was just opened in the same checkout operation.  pre ping
only applies to a DBAPI connection that’s been checked into the pool
and is being checked out again.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4524">#4524</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-55"><span class="target" id="change-d3650b27f4c852ac687ea55326051ed0"><strong>[engine] [performance] [change] [py3k]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d3650b27f4c852ac687ea55326051ed0">¶</a></span><p>Disabled the “unicode returns” check that runs on dialect startup when
running under Python 3, which for many years has occurred in order to test
the current DBAPI’s behavior for whether or not it returns Python Unicode
or Py2K strings for the VARCHAR and NVARCHAR datatypes.  The check still
occurs by default under Python 2, however the mechanism to test the
behavior will be removed in SQLAlchemy 2.0 when Python 2 support is also
removed.</p>
<p>This logic was very effective when it was needed, however now that Python 3
is standard, all DBAPIs are expected to return Python 3 strings for
character datatypes.  In the unlikely case that a third party DBAPI does
not support this, the conversion logic within <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> is still
available and the third party dialect may specify this in its upfront
dialect flags by setting the dialect level flag <code class="docutils literal notranslate"><span class="pre">returns_unicode_strings</span></code>
to one of <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.RETURNS_CONDITIONAL" title="sqlalchemy.types.String.RETURNS_CONDITIONAL"><code class="xref py py-attr docutils literal notranslate"><span class="pre">String.RETURNS_CONDITIONAL</span></code></a> or
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String.RETURNS_BYTES" title="sqlalchemy.types.String.RETURNS_BYTES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">String.RETURNS_BYTES</span></code></a>, both of which will enable Unicode conversion
even under Python 3.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5315">#5315</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-56"><span class="target" id="change-f8a130923cff752e26f7be9cf1ea18eb"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f8a130923cff752e26f7be9cf1ea18eb">¶</a></span><p>Revised the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Connection.execution_options.schema_translate_map</span></code></a>
feature such that the processing of the SQL statement to receive a specific
schema name occurs within the execution phase of the statement, rather than
at the compile phase.   This is to support the statement being efficiently
cached.   Previously, the current schema being rendered into the statement
for a particular run would be considered as part of the cache key itself,
meaning that for a run against hundreds of schemas, there would be hundreds
of cache keys, rendering the cache much less performant.  The new behavior
is that the rendering is done in a similar  manner as the “post compile”
rendering added in 1.4 as part of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4645">#4645</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4808">#4808</a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5004">#5004</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-57"><span class="target" id="change-73657d86215268fd9ca8652a4fc419f8"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-73657d86215268fd9ca8652a4fc419f8">¶</a></span><p>The <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> object will now not clear a rolled-back
transaction  until the outermost transaction is explicitly rolled back.
This is essentially the same behavior that the ORM <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> has
had for a long time, where an explicit call to <code class="docutils literal notranslate"><span class="pre">.rollback()</span></code> on all
enclosing transactions is required for the transaction to logically clear,
even though the DBAPI-level transaction has already been rolled back.
The new behavior helps with situations such as the “ORM rollback test suite”
pattern where the test suite rolls the transaction back within the ORM
scope, but the test harness which seeks to control the scope of the
transaction externally does not expect a new transaction to start
implicitly.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4712"><span class="std std-ref">Connection-level transactions can now be inactive based on subtransaction</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4712">#4712</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-58"><span class="target" id="change-efee59aee6cb2459ce3317ef2617eebd"><strong>[engine] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-efee59aee6cb2459ce3317ef2617eebd">¶</a></span><p>Adjusted the dialect initialization process such that the
<a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect.on_connect" title="sqlalchemy.engine.Dialect.on_connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Dialect.on_connect()</span></code></a> is not called a second time
on the first connection.   The hook is called first, then the
<a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect.initialize" title="sqlalchemy.engine.Dialect.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Dialect.initialize()</span></code></a> is called if that connection is the
first for that dialect, then no more events are called.   This eliminates
the two calls to the “on_connect” function which can produce very
difficult debugging situations.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5497">#5497</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-59"><span class="target" id="change-41f7a69f16c0de9908f5e37c68b6d6d0"><strong>[engine] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-41f7a69f16c0de9908f5e37c68b6d6d0">¶</a></span><p>The <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> object is now an immutable named tuple. To modify
a URL object, use the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.set" title="sqlalchemy.engine.URL.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">URL.set()</span></code></a> method to produce a new URL
object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5526"><span class="std std-ref">The URL object is now immutable</span></a> - notes on migration</p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5526">#5526</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-60"><span class="target" id="change-e3aa96b32025e822f6d64eec868d2ef6"><strong>[engine] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e3aa96b32025e822f6d64eec868d2ef6">¶</a></span><p>The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.params.bind" title="sqlalchemy.schema.MetaData"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">MetaData.bind</span></code></a> argument as well as the overall
concept of “bound metadata” is deprecated in SQLAlchemy 1.4 and will be
removed in SQLAlchemy 2.0.  The parameter as well as related functions now
emit a <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.RemovedIn20Warning" title="sqlalchemy.exc.RemovedIn20Warning"><code class="xref py py-class docutils literal notranslate"><span class="pre">RemovedIn20Warning</span></code></a> when <a class="reference internal" href="migration_14.html#deprecation-20-mode"><span class="std std-ref">SQLAlchemy 2.0 Deprecations Mode</span></a> is
in use.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html#migration-20-implicit-execution"><span class="std std-ref">“Implicit” and “Connectionless” execution, “bound metadata” removed</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4634">#4634</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-61"><span class="target" id="change-c9f031f85039675e8cae75d829d5968e"><strong>[engine] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c9f031f85039675e8cae75d829d5968e">¶</a></span><p>The <code class="docutils literal notranslate"><span class="pre">server_side_cursors</span></code> engine-wide parameter is deprecated and will be
removed in a future release.  For unbuffered cursors, the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Connection.execution_options.stream_results</span></code></a> execution
option should be used on a per-execution basis.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-62"><span class="target" id="change-f78f4ea15de086a7228534c3a6719cb9"><strong>[engine] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f78f4ea15de086a7228534c3a6719cb9">¶</a></span><p>The <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.connect" title="sqlalchemy.engine.Connection.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.connect()</span></code></a> method is deprecated as is the concept of
“connection branching”, which copies a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> into a new one
that has a no-op “.close()” method.  This pattern is oriented around the
“connectionless execution” concept which is also being removed in 2.0.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5131">#5131</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-63"><span class="target" id="change-37b584f1a6a9379d88ad47c17d5a311d"><strong>[engine] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-37b584f1a6a9379d88ad47c17d5a311d">¶</a></span><p>The <code class="xref py py-paramref docutils literal notranslate"><span class="pre">case_sensitive</span></code> flag on <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> is
deprecated; this flag was part of the transition of the result row object
to allow case sensitive column matching as the default, while providing
backwards compatibility for the former matching method.   All string access
for a row should be assumed to be case sensitive just like any other Python
mapping.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4878">#4878</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-64"><span class="target" id="change-59701182e5a0f698c2254f31f310d2f9"><strong>[engine] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-59701182e5a0f698c2254f31f310d2f9">¶</a></span><p>”Implicit autocommit”, which is the COMMIT that occurs when a DML or DDL
statement is emitted on a connection, is deprecated and won’t be part of
SQLAlchemy 2.0.   A 2.0-style warning is emitted when autocommit takes
effect, so that the calling code may be adjusted to use an explicit
transaction.</p>
<p>As part of this change, DDL methods such as
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.create_all" title="sqlalchemy.schema.MetaData.create_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.create_all()</span></code></a> when used against an
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> will run the operation in a BEGIN block if one is
not started already.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#deprecation-20-mode"><span class="std std-ref">SQLAlchemy 2.0 Deprecations Mode</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4846">#4846</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-65"><span class="target" id="change-b82464dd154b94e357299844171b257e"><strong>[engine] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b82464dd154b94e357299844171b257e">¶</a></span><p>Deprecated the behavior by which a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> can be used as the key
in a result set row lookup, when that <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> is not part of the
SQL selectable that is being selected; that is, it is only matched on name.
A deprecation warning is now emitted for this case.   Various ORM use
cases, such as those involving <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> constructs, have been improved
so that this fallback logic is avoided in most cases.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4877">#4877</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-66"><span class="target" id="change-becf6cd0b99c4de41b9e7281432ebf2a"><strong>[engine] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-becf6cd0b99c4de41b9e7281432ebf2a">¶</a></span><p>Deprecated remaining engine-level introspection and utility methods
including <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.run_callable" title="sqlalchemy.engine.Engine.run_callable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.run_callable()</span></code></a>, <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.transaction" title="sqlalchemy.engine.Engine.transaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.transaction()</span></code></a>,
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.table_names" title="sqlalchemy.engine.Engine.table_names"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.table_names()</span></code></a>, <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.has_table" title="sqlalchemy.engine.Engine.has_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.has_table()</span></code></a>.   The utility
methods are superseded by modern context-manager patterns, and the table
introspection tasks are suited by the <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector" title="sqlalchemy.engine.reflection.Inspector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code></a> object.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4755">#4755</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-67"><span class="target" id="change-5cc934f074787203cf15d3e2c3d87025"><strong>[engine] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5cc934f074787203cf15d3e2c3d87025">¶</a></span><p>Remove deprecated method <code class="docutils literal notranslate"><span class="pre">get_primary_keys</span></code> in the <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a> and
<a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector" title="sqlalchemy.engine.reflection.Inspector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code></a> classes. Please refer to the
<a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect.get_pk_constraint" title="sqlalchemy.engine.Dialect.get_pk_constraint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Dialect.get_pk_constraint()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_primary_keys()</span></code>
methods.</p>
<p>Remove deprecated event <code class="docutils literal notranslate"><span class="pre">dbapi_error</span></code> and the method
<code class="docutils literal notranslate"><span class="pre">ConnectionEvents.dbapi_error</span></code>. Please refer to the
<a class="reference internal" href="../core/events.html#sqlalchemy.events.ConnectionEvents.handle_error" title="sqlalchemy.events.ConnectionEvents.handle_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ConnectionEvents.handle_error()</span></code></a> event.
This change also removes the attributes <code class="docutils literal notranslate"><span class="pre">ExecutionContext.is_disconnect</span></code>
and <code class="docutils literal notranslate"><span class="pre">ExecutionContext.exception</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4643">#4643</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-68"><span class="target" id="change-0215fae622c01f9409eb1ba2754f4792"><strong>[engine] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0215fae622c01f9409eb1ba2754f4792">¶</a></span><p>The internal dialect method <code class="docutils literal notranslate"><span class="pre">Dialect.reflecttable</span></code> has been removed.  A
review of third party dialects has not found any making use of this method,
as it was already documented as one that should not be used by external
dialects.  Additionally, the private <code class="docutils literal notranslate"><span class="pre">Engine._run_visitor</span></code> method
is also removed.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4755">#4755</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-69"><span class="target" id="change-48d8e9d0ead3648abc4ee851e235f46b"><strong>[engine] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-48d8e9d0ead3648abc4ee851e235f46b">¶</a></span><p>The long-deprecated <code class="docutils literal notranslate"><span class="pre">Inspector.get_table_names.order_by</span></code> parameter has
been removed.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4755">#4755</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-70"><span class="target" id="change-114431311698478a75c637f0ecfc4b78"><strong>[engine] [renamed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-114431311698478a75c637f0ecfc4b78">¶</a></span><p>The <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.reflecttable" title="sqlalchemy.engine.reflection.Inspector.reflecttable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.reflecttable()</span></code></a> was renamed to
<a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.reflect_table" title="sqlalchemy.engine.reflection.Inspector.reflect_table"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.reflect_table()</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5244">#5244</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-sql">
<h3>sql<a class="headerlink" href="#change-1.4.0b1-sql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-71"><span class="target" id="change-5e8f2c35d1292bddb011ccce6537acfe"><strong>[sql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5e8f2c35d1292bddb011ccce6537acfe">¶</a></span><p>Added “from linting” as a built-in feature to the SQL compiler.  This
allows the compiler to maintain graph of all the FROM clauses in a
particular SELECT statement, linked by criteria in either the WHERE
or in JOIN clauses that link these FROM clauses together.  If any two
FROM clauses have no path between them, a warning is emitted that the
query may be producing a cartesian product.   As the Core expression
language as well as the ORM are built on an “implicit FROMs” model where
a particular FROM clause is automatically added if any part of the query
refers to it, it is easy for this to happen inadvertently and it is
hoped that the new feature helps with this issue.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4737"><span class="std std-ref">Built-in FROM linting will warn for any potential cartesian products in a SELECT statement</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4737">#4737</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-72"><span class="target" id="change-f84ee9187669024a4818355291041304"><strong>[sql] [feature] [mssql] [oracle]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f84ee9187669024a4818355291041304">¶</a></span><p>Added new “post compile parameters” feature.  This feature allows a
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> construct to have its value rendered into the SQL string
before being passed to the DBAPI driver, but after the compilation step,
using the “literal render” feature of the compiler.  The immediate
rationale for this feature is to support LIMIT/OFFSET schemes that don’t
work or perform well as bound parameters handled by the database driver,
while still allowing for SQLAlchemy SQL constructs to be cacheable in their
compiled form.     The immediate targets for the new feature are the “TOP
N” clause used by SQL Server (and Sybase) which does not support a bound
parameter, as well as the “ROWNUM” and optional “FIRST_ROWS()” schemes used
by the Oracle dialect, the former of which has been known to perform better
without bound parameters and the latter of which does not support a bound
parameter.   The feature builds upon the mechanisms first developed to
support “expanding” parameters for IN expressions.   As part of this
feature, the Oracle <code class="docutils literal notranslate"><span class="pre">use_binds_for_limits</span></code> feature is turned on
unconditionally and this flag is now deprecated.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4808"><span class="std std-ref">New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4808">#4808</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-73"><span class="target" id="change-14928162e9457fa1a132b513ea72618c"><strong>[sql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-14928162e9457fa1a132b513ea72618c">¶</a></span><p>Add support for regular expression on supported backends.
Two operations have been defined:</p>
<ul>
<li><p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match" title="sqlalchemy.sql.expression.ColumnOperators.regexp_match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.regexp_match()</span></code></a> implementing a regular
expression match like function.</p></li>
<li><p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace" title="sqlalchemy.sql.expression.ColumnOperators.regexp_replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.regexp_replace()</span></code></a> implementing a regular
expression string replace function.</p></li>
</ul>
<p>Supported backends include SQLite, PostgreSQL, MySQL / MariaDB, and Oracle.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-1390"><span class="std std-ref">Support for SQL Regular Expression operators</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1390">#1390</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-74"><span class="target" id="change-4e5fa22062256301d7a5e20b6ba21f04"><strong>[sql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4e5fa22062256301d7a5e20b6ba21f04">¶</a></span><p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct and related constructs now allow for
duplication of column labels and columns themselves in the columns clause,
mirroring exactly how column expressions were passed in.   This allows
the tuples returned by an executed result to match what was SELECTed
for in the first place, which is how the ORM <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> works, so
this establishes better cross-compatibility between the two constructs.
Additionally, it allows column-positioning-sensitive structures such as
UNIONs (i.e. <code class="xref py py-class docutils literal notranslate"><span class="pre">_selectable.CompoundSelect</span></code>) to be more intuitively constructed
in those cases where a particular column might appear in more than one
place.   To support this change, the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection" title="sqlalchemy.sql.expression.ColumnCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnCollection</span></code></a> has been
revised to support duplicate columns as well as to allow integer index
access.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4753"><span class="std std-ref">SELECT objects and derived FROM clauses allow for duplicate columns and column labels</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4753">#4753</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-75"><span class="target" id="change-0554186a238a71798ccba1c8d86431d6"><strong>[sql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0554186a238a71798ccba1c8d86431d6">¶</a></span><p>Enhanced the disambiguating labels feature of the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct such that when a select statement
is used in a subquery, repeated column names from different tables are now
automatically labeled with a unique label name, without the need to use the
full “apply_labels()” feature that combines tablename plus column name.
The disambiguated labels are available as plain string keys in the .c
collection of the subquery, and most importantly the feature allows an ORM
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> construct against the combination of an entity and an
arbitrary subquery to work correctly, targeting the correct columns despite
same-named columns in the source tables, without the need for an “apply
labels” warning.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html#migration-20-query-from-self"><span class="std std-ref">Selecting from the query itself as a subquery, e.g. “from_self()”</span></a> - Illustrates the new
disambiguation feature as part of a strategy to migrate away from the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.from_self" title="sqlalchemy.orm.Query.from_self"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.from_self()</span></code></a> method.</p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5221">#5221</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-76"><span class="target" id="change-ec466d1a10e8ff426e6bd1429f954889"><strong>[sql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ec466d1a10e8ff426e6bd1429f954889">¶</a></span><p>The “expanding IN” feature, which generates IN expressions at query
execution time which are based on the particular parameters associated with
the statement execution, is now used for all IN expressions made against
lists of literal values.   This allows IN expressions to be fully cacheable
independently of the list of values being passed, and also includes support
for empty lists. For any scenario where the IN expression contains
non-literal SQL expressions, the old behavior of pre-rendering for each
position in the IN is maintained. The change also completes support for
expanding IN with tuples, where previously type-specific bind processors
weren’t taking effect.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4645"><span class="std std-ref">All IN expressions render parameters for each value in the list on the fly (e.g. expanding parameters)</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4645">#4645</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-77"><span class="target" id="change-28298ced8814e61280d17bd89a678ff0"><strong>[sql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-28298ced8814e61280d17bd89a678ff0">¶</a></span><p>Along with the new transparent statement caching feature introduced as part
of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4369">#4369</a>, a new feature intended to decrease the Python overhead
of creating statements is added, allowing lambdas to be used when
indicating arguments being passed to a statement object such as select(),
Query(), update(), etc., as well as allowing the construction of full
statements within lambdas in a similar manner as that of the “baked query”
system.   The rationale of using lambdas is adapted from that of the “baked
query” approach which uses lambdas to encapsulate any amount of Python code
into a callable that only needs to be called when the statement is first
constructed into a string.  The new feature however is more sophisticated
in that Python literal values that would be passed as parameters are
automatically extracted, so that there is no longer a need to use
bindparam() objects with such queries.   Use of the feature is optional and
can be used to as small or as great a degree as is desired, while still
allowing statements to be fully cacheable.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#engine-lambda-caching"><span class="std std-ref">Using Lambdas to add significant speed gains to statement production</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5380">#5380</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-78"><span class="target" id="change-5dd7289189bea12be0a50f0222d2ae2d"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5dd7289189bea12be0a50f0222d2ae2d">¶</a></span><p>The <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index.create" title="sqlalchemy.schema.Index.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Index.create()</span></code></a> and <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index.drop" title="sqlalchemy.schema.Index.drop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Index.drop()</span></code></a> methods now have a
parameter <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index.create.params.checkfirst" title="sqlalchemy.schema.Index.create"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Index.create.checkfirst</span></code></a>, in the same way as that of
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> and <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>, which when enabled will cause the
operation to detect if the index exists (or not) before performing a create
or drop operation.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/527">#527</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-79"><span class="target" id="change-2ebea41afd8caa7e5ba6eb303d4f7ab2"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2ebea41afd8caa7e5ba6eb303d4f7ab2">¶</a></span><p>The <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.true" title="sqlalchemy.sql.expression.true"><code class="xref py py-func docutils literal notranslate"><span class="pre">true()</span></code></a> and <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.false" title="sqlalchemy.sql.expression.false"><code class="xref py py-func docutils literal notranslate"><span class="pre">false()</span></code></a> operators may now be applied as the
“onclause” of a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.join" title="sqlalchemy.sql.expression.join"><code class="xref py py-func docutils literal notranslate"><span class="pre">join()</span></code></a> on a backend that does not support
“native boolean” expressions, e.g. Oracle or SQL Server, and the expression
will render as “1=1” for true and “1=0” false.  This is the behavior that
was introduced many years ago in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/2804">#2804</a> for and/or expressions.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-80"><span class="target" id="change-14a7ae56d06c50c25de473dd8ac1867a"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-14a7ae56d06c50c25de473dd8ac1867a">¶</a></span><p>Change the method <code class="docutils literal notranslate"><span class="pre">__str</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnCollection</span></code> to avoid
confusing it with a python list of string.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5191">#5191</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-81"><span class="target" id="change-4bbea2a396e1dd525428bf9b8c5a1357"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4bbea2a396e1dd525428bf9b8c5a1357">¶</a></span><p>Add support to <code class="docutils literal notranslate"><span class="pre">FETCH</span> <span class="pre">{FIRST</span> <span class="pre">|</span> <span class="pre">NEXT}</span> <span class="pre">[</span> <span class="pre">count</span> <span class="pre">]</span>
<span class="pre">{ROW</span> <span class="pre">|</span> <span class="pre">ROWS}</span> <span class="pre">{ONLY</span> <span class="pre">|</span> <span class="pre">WITH</span> <span class="pre">TIES}</span></code> in the select for the supported
backends, currently PostgreSQL, Oracle and MSSQL.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5576">#5576</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-82"><span class="target" id="change-81e3a5d199010e0361d76080dec7adcb"><strong>[sql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-81e3a5d199010e0361d76080dec7adcb">¶</a></span><p>Additional logic has been added such that certain SQL expressions which
typically wrap a single database column will use the name of that column as
their “anonymous label” name within a SELECT statement, potentially making
key-based lookups in result tuples more intuitive.   The primary example of
this is that of a CAST expression, e.g. <code class="docutils literal notranslate"><span class="pre">CAST(table.colname</span> <span class="pre">AS</span> <span class="pre">INTEGER)</span></code>,
which will export its default name as “colname”, rather than the usual
“anon_1” label, that is, <code class="docutils literal notranslate"><span class="pre">CAST(table.colname</span> <span class="pre">AS</span> <span class="pre">INTEGER)</span> <span class="pre">AS</span> <span class="pre">colname</span></code>.
If the inner expression doesn’t have a name, then the previous “anonymous
label” logic is used.  When using SELECT statements that make use of
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.apply_labels" title="sqlalchemy.sql.expression.Select.apply_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.apply_labels()</span></code></a>, such as those emitted by the ORM, the
labeling logic will produce <code class="docutils literal notranslate"><span class="pre">&lt;tablename&gt;_&lt;inner</span> <span class="pre">column</span> <span class="pre">name&gt;</span></code> in the same
was as if the column were named alone.   The logic applies right now to the
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> and <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> constructs as well as some
single-element boolean expressions.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4449"><span class="std std-ref">Improved column labeling for simple column expressions using CAST or similar</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4449">#4449</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-83"><span class="target" id="change-7a44352bc657301047fb4ff3345c0241"><strong>[sql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7a44352bc657301047fb4ff3345c0241">¶</a></span><p>The “clause coercion” system, which is SQLAlchemy Core’s system of receiving
arguments and resolving them into <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a> structures in order
to build up SQL expression objects, has been rewritten from a series of
ad-hoc functions to a fully consistent class-based system.   This change
is internal and should have no impact on end users other than more specific
error messages when the wrong kind of argument is passed to an expression
object, however the change is part of a larger set of changes involving
the role and behavior of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> objects.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-84"><span class="target" id="change-7f08ac16d43fed2d88ce0ad3f65ee4bc"><strong>[sql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7f08ac16d43fed2d88ce0ad3f65ee4bc">¶</a></span><p>Added a core <code class="xref py py-class docutils literal notranslate"><span class="pre">Values</span></code> object that enables a VALUES construct
to be used in the FROM clause of an SQL statement for databases that
support it (mainly PostgreSQL and SQL Server).</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4868">#4868</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-85"><span class="target" id="change-0c8db3ee80eac341c1bdb754fd6b33df"><strong>[sql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0c8db3ee80eac341c1bdb754fd6b33df">¶</a></span><p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct is moving towards a new calling
form that is <code class="docutils literal notranslate"><span class="pre">select(col1,</span> <span class="pre">col2,</span> <span class="pre">col3,</span> <span class="pre">..)</span></code>, with all other keyword
arguments removed, as these are all suited using generative methods.    The
single list of column or table arguments passed to <code class="docutils literal notranslate"><span class="pre">select()</span></code> is still
accepted, however is no longer necessary if expressions are passed in a
simple positional style.   Other keyword arguments are disallowed when this
form is used.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5284"><span class="std std-ref">select(), case() now accept positional expressions</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5284">#5284</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-86"><span class="target" id="change-c21f3ce1697d02aa85275f248247aa9f"><strong>[sql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c21f3ce1697d02aa85275f248247aa9f">¶</a></span><p>As part of the SQLAlchemy 2.0 migration project, a conceptual change has
been made to the role of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase" title="sqlalchemy.sql.expression.SelectBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectBase</span></code></a> class hierarchy,
which is the root of all “SELECT” statement constructs, in that they no
longer serve directly as FROM clauses, that is, they no longer subclass
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a>.  For end users, the change mostly means that any
placement of a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct in the FROM clause of another
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> requires first that it be wrapped in a subquery first,
which historically is through the use of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias" title="sqlalchemy.sql.expression.SelectBase.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.alias()</span></code></a>
method, and is now also available through the use of
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a>.    This was usually a requirement in any
case since several databases don’t accept unnamed SELECT subqueries
in their FROM clause in any case.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4617"><span class="std std-ref">A SELECT statement is no longer implicitly considered to be a FROM clause</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-87"><span class="target" id="change-22f6d5058669a61e4a82ddeb71a36507"><strong>[sql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-22f6d5058669a61e4a82ddeb71a36507">¶</a></span><p>Added a new Core class <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a>, which takes the place of
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> when creating named subqueries against a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase" title="sqlalchemy.sql.expression.SelectBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectBase</span></code></a>
object.   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> acts in the same way as <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a>
and is produced from the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a> method; for
ease of use and backwards compatibility, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias" title="sqlalchemy.sql.expression.SelectBase.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.alias()</span></code></a>
method is synonymous with this new method.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4617"><span class="std std-ref">A SELECT statement is no longer implicitly considered to be a FROM clause</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-88"><span class="target" id="change-d7627d94b58420dcd694c59c3144072a"><strong>[sql] [performance]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d7627d94b58420dcd694c59c3144072a">¶</a></span><p>An all-encompassing reorganization and refactoring of Core and ORM
internals now allows all Core and ORM statements within the areas of
DQL (e.g. SELECTs) and DML (e.g. INSERT, UPDATE, DELETE) to allow their
SQL compilation as well as the construction of result-fetching metadata
to be fully cached in most cases.   This effectively provides a transparent
and generalized version of what the “Baked Query” extension has offered
for the ORM in past versions.  The new feature can calculate the
cache key for any given SQL construction based on the string that
it would ultimately produce for a given dialect, allowing functions that
compose the equivalent select(), Query(), insert(), update() or delete()
object each time to have that statement cached after it’s generated
the first time.</p>
<p>The feature is enabled transparently but includes some new programming
paradigms that may be employed to make the caching even more efficient.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4639"><span class="std std-ref">Transparent SQL Compilation Caching added to All DQL, DML Statements in Core, ORM</span></a></p>
<p><a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">SQL Compilation Caching</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4639">#4639</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-89"><span class="target" id="change-f99111d32c9061b8620ddd8d6c0ac151"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f99111d32c9061b8620ddd8d6c0ac151">¶</a></span><p>Fixed issue where when constructing constraints from ORM-bound columns,
primarily <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> objects but also <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="sqlalchemy.schema.UniqueConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueConstraint</span></code></a>,
<a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.CheckConstraint" title="sqlalchemy.schema.CheckConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">CheckConstraint</span></code></a> and others, the ORM-level
<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstrumentedAttribute" title="sqlalchemy.orm.InstrumentedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentedAttribute</span></code></a> is discarded entirely, and all ORM-level
annotations from the columns are removed; this is so that the constraints
are still fully pickleable without the ORM-level entities being pulled in.
These annotations are not necessary to be present at the schema/metadata
level.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5001">#5001</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-90"><span class="target" id="change-a79466ee6f4c8d39f98707881a3e3707"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a79466ee6f4c8d39f98707881a3e3707">¶</a></span><p>Registered function names based on <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.GenericFunction" title="sqlalchemy.sql.functions.GenericFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericFunction</span></code></a> are now
retrieved in a case-insensitive fashion in all cases, removing the
deprecation logic from 1.3 which temporarily allowed multiple
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.GenericFunction" title="sqlalchemy.sql.functions.GenericFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericFunction</span></code></a> objects to exist with differing cases.   A
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.GenericFunction" title="sqlalchemy.sql.functions.GenericFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericFunction</span></code></a> that replaces another on the same name whether or
not it’s case sensitive emits a warning before replacing the object.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4569">#4569</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4649">#4649</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-91"><span class="target" id="change-9779f4f3104ee7fa9e18a16dc22253f4"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9779f4f3104ee7fa9e18a16dc22253f4">¶</a></span><p>Creating an <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">and_()</span></code></a> or <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.or_" title="sqlalchemy.sql.expression.or_"><code class="xref py py-func docutils literal notranslate"><span class="pre">or_()</span></code></a> construct with no arguments or
empty <code class="docutils literal notranslate"><span class="pre">*args</span></code> will now emit a deprecation warning, as the SQL produced is
a no-op (i.e. it renders as a blank string). This behavior is considered to
be non-intuitive, so for empty or possibly empty <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">and_()</span></code></a> or
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.or_" title="sqlalchemy.sql.expression.or_"><code class="xref py py-func docutils literal notranslate"><span class="pre">or_()</span></code></a> constructs, an appropriate default boolean should be included,
such as <code class="docutils literal notranslate"><span class="pre">and_(True,</span> <span class="pre">*args)</span></code> or <code class="docutils literal notranslate"><span class="pre">or_(False,</span> <span class="pre">*args)</span></code>.   As has been the
case for many major versions of SQLAlchemy, these particular boolean
values will not render if the <code class="docutils literal notranslate"><span class="pre">*args</span></code> portion is non-empty.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5054">#5054</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-92"><span class="target" id="change-d1799c3e93f31127881e66f36e121da9"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d1799c3e93f31127881e66f36e121da9">¶</a></span><p>Improved the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.tuple_" title="sqlalchemy.sql.expression.tuple_"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple_()</span></code></a> construct such that it behaves predictably
when used in a columns-clause context.  The SQL tuple is not supported as a
“SELECT” columns clause element on most backends; on those that do
(PostgreSQL, not surprisingly), the Python DBAPI does not have a “nested
type” concept so there are still challenges in fetching rows for such an
object. Use of <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.tuple_" title="sqlalchemy.sql.expression.tuple_"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple_()</span></code></a> in a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> or
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> will now raise a <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.CompileError" title="sqlalchemy.exc.CompileError"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompileError</span></code></a> at the
point at which the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.tuple_" title="sqlalchemy.sql.expression.tuple_"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple_()</span></code></a> object is seen as presenting itself
for fetching rows (i.e., if the tuple is in the columns clause of a
subquery, no error is raised).  For ORM use,the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Bundle" title="sqlalchemy.orm.Bundle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bundle</span></code></a> object
is an explicit directive that a series of columns should be returned as a
sub-tuple per row and is suggested by the error message. Additionally ,the
tuple will now render with parenthesis in all contexts. Previously, the
parenthesization would not render in a columns context leading to
non-defined behavior.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5127">#5127</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-93"><span class="target" id="change-48451446aa2066c5eca0eee9ee492997"><strong>[sql] [bug] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-48451446aa2066c5eca0eee9ee492997">¶</a></span><p>Improved support for column names that contain percent signs in the string,
including repaired issues involving anoymous labels that also embedded a
column name with a percent sign in it, as well as re-established support
for bound parameter names with percent signs embedded on the psycopg2
dialect, using a late-escaping process similar to that used by the
cx_Oracle dialect.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5653">#5653</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-94"><span class="target" id="change-e76f5c8cb510a71a77d83eab57793bf5"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e76f5c8cb510a71a77d83eab57793bf5">¶</a></span><p>Custom functions that are created as subclasses of
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement" title="sqlalchemy.sql.functions.FunctionElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionElement</span></code></a> will now generate an “anonymous label” based on
the “name” of the function just like any other <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> object,
e.g. <code class="docutils literal notranslate"><span class="pre">&quot;SELECT</span> <span class="pre">myfunc()</span> <span class="pre">AS</span> <span class="pre">myfunc_1&quot;</span></code>. While SELECT statements no longer
require labels in order for the result proxy object to function, the ORM
still targets columns in rows by using objects as mapping keys, which works
more reliably when the column expressions have distinct names.  In any
case, the behavior is  now made consistent between functions generated by
<code class="xref py py-attr docutils literal notranslate"><span class="pre">func</span></code> and those generated as custom <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement" title="sqlalchemy.sql.functions.FunctionElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionElement</span></code></a>
objects.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4887">#4887</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-95"><span class="target" id="change-ae969eb842e8aecd695a98af1ede757b"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-ae969eb842e8aecd695a98af1ede757b">¶</a></span><p>Reworked the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ClauseElement.compare" title="sqlalchemy.sql.expression.ClauseElement.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ClauseElement.compare()</span></code></a> methods in terms of a new
visitor-based approach, and additionally added test coverage ensuring that
all <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a> subclasses can be accurately compared
against each other in terms of structure.   Structural comparison
capability is used to a small degree within the ORM currently, however
it also may form the basis for new caching features.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4336">#4336</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-96"><span class="target" id="change-bd9f4fbb36ffb5585ba1c39299a957df"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-bd9f4fbb36ffb5585ba1c39299a957df">¶</a></span><p>Deprecate usage of <code class="docutils literal notranslate"><span class="pre">DISTINCT</span> <span class="pre">ON</span></code> in dialect other than PostgreSQL.
Deprecate old usage of string distinct in MySQL dialect</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4002">#4002</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-97"><span class="target" id="change-9e1e56ca8c8ebf8695272a2a38b94a27"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9e1e56ca8c8ebf8695272a2a38b94a27">¶</a></span><p>The ORDER BY clause of a <code class="xref py py-class docutils literal notranslate"><span class="pre">_selectable.CompoundSelect</span></code>, e.g. UNION, EXCEPT, etc.
will not render the table name associated with a given column when applying
<code class="xref py py-meth docutils literal notranslate"><span class="pre">CompoundSelect.order_by()</span></code> in terms of a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> - bound
column.   Most databases require that the names in the ORDER BY clause be
expressed as label names only which are matched to names in the first
SELECT statement.    The change is related to <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a> in that a
previous workaround was to refer to the <code class="docutils literal notranslate"><span class="pre">.c</span></code> attribute of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">_selectable.CompoundSelect</span></code> in order to get at a column that has no table
name.  As the subquery is now named, this change allows both the workaround
to continue to work, as well as allows table-bound columns as well as the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">CompoundSelect.selected_columns</span></code> collections to be usable in the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">CompoundSelect.order_by()</span></code> method.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-98"><span class="target" id="change-087a96105bc7b6ffa7f0ef7ab52fb6f2"><strong>[sql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-087a96105bc7b6ffa7f0ef7ab52fb6f2">¶</a></span><p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Join" title="sqlalchemy.sql.expression.Join"><code class="xref py py-class docutils literal notranslate"><span class="pre">Join</span></code></a> construct no longer considers the “onclause” as a source
of additional FROM objects to be omitted from the FROM list of an enclosing
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object as standalone FROM objects. This applies to an ON
clause that includes a reference to another  FROM object outside the JOIN;
while this is usually not correct from a SQL perspective, it’s also
incorrect for it to be omitted, and the behavioral change makes the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> / <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Join" title="sqlalchemy.sql.expression.Join"><code class="xref py py-class docutils literal notranslate"><span class="pre">Join</span></code></a> behave a bit more intuitively.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4621">#4621</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-99"><span class="target" id="change-dc7b4b72b6f4f01bfc5d6dfe8031881f"><strong>[sql] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-dc7b4b72b6f4f01bfc5d6dfe8031881f">¶</a></span><p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Join.alias" title="sqlalchemy.sql.expression.Join.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Join.alias()</span></code></a> method is deprecated and will be removed in
SQLAlchemy 2.0.   An explicit select + subquery, or aliasing of the inner
tables, should be used instead.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5010">#5010</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-100"><span class="target" id="change-e16363a9016c000a7a46be93d8c92d4f"><strong>[sql] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e16363a9016c000a7a46be93d8c92d4f">¶</a></span><p>The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> class now raises a deprecation warning
when columns with the same name are defined. To replace a column a new
parameter <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing" title="sqlalchemy.schema.Table.append_column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.append_column.replace_existing</span></code></a> was
added to the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.append_column" title="sqlalchemy.schema.Table.append_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.append_column()</span></code></a> method.</p>
<p>The <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection.contains_column" title="sqlalchemy.sql.expression.ColumnCollection.contains_column"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnCollection.contains_column()</span></code></a> will now
raises an error when called with a string, suggesting the caller
to use <code class="docutils literal notranslate"><span class="pre">in</span></code> instead.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-101"><span class="target" id="change-b922b1e71ec804bcec35652cbfdcf120"><strong>[sql] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b922b1e71ec804bcec35652cbfdcf120">¶</a></span><p>The “threadlocal” execution strategy, deprecated in 1.3, has been
removed for 1.4, as well as the concept of “engine strategies” and the
<code class="docutils literal notranslate"><span class="pre">Engine.contextual_connect</span></code> method.  The “strategy=’mock’” keyword
argument is still accepted for now with a deprecation warning; use
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_mock_engine" title="sqlalchemy.create_mock_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_mock_engine()</span></code></a> instead for this use case.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_13.html#change-4393-threadlocal"><span class="std std-ref">“threadlocal” engine strategy deprecated</span></a> - from the 1.3 migration notes which
discusses the rationale for deprecation.</p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4632">#4632</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-102"><span class="target" id="change-9f5c3bee0c0336bbd2cc0baa1322c307"><strong>[sql] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9f5c3bee0c0336bbd2cc0baa1322c307">¶</a></span><p>Removed the <code class="docutils literal notranslate"><span class="pre">sqlalchemy.sql.visitors.iterate_depthfirst</span></code> and
<code class="docutils literal notranslate"><span class="pre">sqlalchemy.sql.visitors.traverse_depthfirst</span></code> functions.  These functions
were unused by any part of SQLAlchemy.  The
<a class="reference internal" href="../core/visitors.html#sqlalchemy.sql.visitors.iterate" title="sqlalchemy.sql.visitors.iterate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterate()</span></code></a> and <a class="reference internal" href="../core/visitors.html#sqlalchemy.sql.visitors.traverse" title="sqlalchemy.sql.visitors.traverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">traverse()</span></code></a>
functions are commonly used for these functions.  Also removed unused
options from the remaining functions including “column_collections”,
“schema_visitor”.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-103"><span class="target" id="change-a6e9918d2e9f041e131f57ecbf111d8c"><strong>[sql] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a6e9918d2e9f041e131f57ecbf111d8c">¶</a></span><p>Removed the concept of a bound engine from the <code class="xref py py-class docutils literal notranslate"><span class="pre">Compiler</span></code> object,
and removed the <code class="docutils literal notranslate"><span class="pre">.execute()</span></code> and <code class="docutils literal notranslate"><span class="pre">.scalar()</span></code> methods from
<code class="xref py py-class docutils literal notranslate"><span class="pre">Compiler</span></code>. These were essentially forgotten methods from over a
decade ago and had no practical use, and it’s not appropriate for the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Compiler</span></code> object itself to be maintaining a reference to an
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-104"><span class="target" id="change-9db90d3de8bbabd8513c838813f7c5d8"><strong>[sql] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9db90d3de8bbabd8513c838813f7c5d8">¶</a></span><p>Remove deprecated methods <code class="docutils literal notranslate"><span class="pre">Compiled.compile</span></code>, <code class="docutils literal notranslate"><span class="pre">ClauseElement.__and__</span></code> and
<code class="docutils literal notranslate"><span class="pre">ClauseElement.__or__</span></code> and attribute <code class="docutils literal notranslate"><span class="pre">Over.func</span></code>.</p>
<p>Remove deprecated <code class="docutils literal notranslate"><span class="pre">FromClause.count</span></code> method. Please use the
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.count" title="sqlalchemy.sql.functions.count"><code class="xref py py-class docutils literal notranslate"><span class="pre">count</span></code></a> function available from the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">func</span></code> namespace.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4643">#4643</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-105"><span class="target" id="change-c9e39cc38397003d6724b6a04d725124"><strong>[sql] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c9e39cc38397003d6724b6a04d725124">¶</a></span><p>Remove deprecated parameters <code class="docutils literal notranslate"><span class="pre">text.bindparams</span></code> and <code class="docutils literal notranslate"><span class="pre">text.typemap</span></code>.
Please refer to the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.bindparams" title="sqlalchemy.sql.expression.TextClause.bindparams"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.bindparams()</span></code></a> and
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a> methods.</p>
<p>Remove deprecated parameter <code class="docutils literal notranslate"><span class="pre">Table.useexisting</span></code>. Please use
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.extend_existing</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4643">#4643</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-106"><span class="target" id="change-9507190872d43b541811bb3584432295"><strong>[sql] [renamed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-9507190872d43b541811bb3584432295">¶</a></span><p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> parameter <code class="docutils literal notranslate"><span class="pre">mustexist</span></code> has been renamed
to <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.must_exist" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.must_exist</span></code></a> and will now warn when used.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-107"><span class="target" id="change-f413ff8c13a1fb7d766bfa16dfcdfbf1"><strong>[sql] [renamed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f413ff8c13a1fb7d766bfa16dfcdfbf1">¶</a></span><p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.as_scalar" title="sqlalchemy.sql.expression.SelectBase.as_scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.as_scalar()</span></code></a> and <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.as_scalar" title="sqlalchemy.orm.Query.as_scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.as_scalar()</span></code></a> methods have
been renamed to <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.scalar_subquery" title="sqlalchemy.sql.expression.SelectBase.scalar_subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.scalar_subquery()</span></code></a> and
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.scalar_subquery" title="sqlalchemy.orm.Query.scalar_subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.scalar_subquery()</span></code></a>, respectively.  The old names continue to
exist within 1.4 series with a deprecation warning.  In addition, the
implicit coercion of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase" title="sqlalchemy.sql.expression.SelectBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectBase</span></code></a>, <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a>, and other
SELECT oriented objects into scalar subqueries when evaluated in a column
context is also deprecated, and emits a warning that the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.scalar_subquery" title="sqlalchemy.sql.expression.SelectBase.scalar_subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.scalar_subquery()</span></code></a> method should be called explicitly.
This warning will in a later major release become an error, however the
message will always be clear when <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.scalar_subquery" title="sqlalchemy.sql.expression.SelectBase.scalar_subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.scalar_subquery()</span></code></a> needs
to be invoked.   The latter part of the change is for clarity and to reduce
the implicit decisionmaking by the query coercion system.   The
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery.as_scalar" title="sqlalchemy.sql.expression.Subquery.as_scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Subquery.as_scalar()</span></code></a> method, which was previously
<code class="docutils literal notranslate"><span class="pre">Alias.as_scalar</span></code>, is also deprecated; <code class="docutils literal notranslate"><span class="pre">.scalar_subquery()</span></code> should be
invoked directly from ` <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> object or <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object.</p>
<p>This change is part of the larger change to convert <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> objects
to no longer be directly part of the “from clause” class hierarchy, which
also includes an overhaul of the clause coercion system.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-108"><span class="target" id="change-8dd50c1cc4d512bf97b23fb0243619af"><strong>[sql] [renamed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8dd50c1cc4d512bf97b23fb0243619af">¶</a></span><p>Several operators are renamed to achieve more consistent naming across
SQLAlchemy.</p>
<p>The operator changes are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">isfalse</span></code> is now <code class="docutils literal notranslate"><span class="pre">is_false</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isnot_distinct_from</span></code> is now <code class="docutils literal notranslate"><span class="pre">is_not_distinct_from</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">istrue</span></code> is now <code class="docutils literal notranslate"><span class="pre">is_true</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notbetween</span></code> is now <code class="docutils literal notranslate"><span class="pre">not_between</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notcontains</span></code> is now <code class="docutils literal notranslate"><span class="pre">not_contains</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notendswith</span></code> is now <code class="docutils literal notranslate"><span class="pre">not_endswith</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notilike</span></code> is now <code class="docutils literal notranslate"><span class="pre">not_ilike</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notlike</span></code> is now <code class="docutils literal notranslate"><span class="pre">not_like</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notmatch</span></code> is now <code class="docutils literal notranslate"><span class="pre">not_match</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notstartswith</span></code> is now <code class="docutils literal notranslate"><span class="pre">not_startswith</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nullsfirst</span></code> is now <code class="docutils literal notranslate"><span class="pre">nulls_first</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nullslast</span></code> is now <code class="docutils literal notranslate"><span class="pre">nulls_last</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isnot</span></code> is now <code class="docutils literal notranslate"><span class="pre">is_not</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">not_in_</span></code> is now <code class="docutils literal notranslate"><span class="pre">not_in</span></code></p></li>
</ul>
<p>Because these are core operators, the internal migration strategy for this
change is to support legacy terms for an extended period of time – if not
indefinitely – but update all documentation, tutorials, and internal usage
to the new terms.  The new terms are used to define the functions, and
the legacy terms have been deprecated into aliases of the new terms.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5429">#5429</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5435">#5435</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-109"><span class="target" id="change-0163990815b30fb63a987382ba8612f7"><strong>[sql] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0163990815b30fb63a987382ba8612f7">¶</a></span><p>Allow specifying the data type when creating a <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> in
PostgreSQL by using the parameter <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence.params.data_type" title="sqlalchemy.schema.Sequence"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Sequence.data_type</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5498">#5498</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-110"><span class="target" id="change-8c9c21f6988172241e7145457bf7315e"><strong>[sql] [reflection]</strong> <a class="changelog-reference headerlink reference internal" href="#change-8c9c21f6988172241e7145457bf7315e">¶</a></span><p>The “NO ACTION” keyword for foreign key “ON UPDATE” is now considered to be
the default cascade for a foreign key on all supporting backends (SQlite,
MySQL, PostgreSQL) and when detected is not included in the reflection
dictionary; this is already the behavior for PostgreSQL and MySQL for all
previous SQLAlchemy versions in any case.   The “RESTRICT” keyword is
positively stored when detected; PostgreSQL does report on this keyword,
and MySQL as of version 8.0 does as well.  On earlier MySQL versions, it is
not reported by the database.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4741">#4741</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-111"><span class="target" id="change-36ba10688af2cf9bc6b46cc83df64f99"><strong>[sql] [reflection]</strong> <a class="changelog-reference headerlink reference internal" href="#change-36ba10688af2cf9bc6b46cc83df64f99">¶</a></span><p>Added support for reflecting “identity” columns, which are now returned
as part of the structure returned by <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns" title="sqlalchemy.engine.reflection.Inspector.get_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_columns()</span></code></a>.
When reflecting full <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects, identity columns will
be represented using the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Identity" title="sqlalchemy.schema.Identity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code></a> construct.
Currently the supported backends are
PostgreSQL &gt;= 10, Oracle &gt;= 12 and MSSQL (with different syntax
and a subset of functionalities).</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5324">#5324</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5527">#5527</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-schema">
<h3>schema<a class="headerlink" href="#change-1.4.0b1-schema" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-112"><span class="target" id="change-22b21b44239fae0edb1b03961bb883d4"><strong>[schema] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-22b21b44239fae0edb1b03961bb883d4">¶</a></span><p>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint" title="sqlalchemy.types.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.create_constraint</span></code></a> and
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint" title="sqlalchemy.types.Boolean"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Boolean.create_constraint</span></code></a> parameters now default to False,
indicating when a so-called “non-native” version of these two datatypes is
created, a CHECK constraint will not be generated by default.   These CHECK
constraints present schema-management maintenance complexities that should
be opted in to, rather than being turned on by default.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5367"><span class="std std-ref">Enum and Boolean datatypes no longer default to “create constraint”</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5367">#5367</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-113"><span class="target" id="change-26f17e182245389e24654b17ab85b9bf"><strong>[schema] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-26f17e182245389e24654b17ab85b9bf">¶</a></span><p>Cleaned up the internal <code class="docutils literal notranslate"><span class="pre">str()</span></code> for datatypes so that all types produce a
string representation without any dialect present, including that it works
for third-party dialect types without that dialect being present.  The
string representation defaults to being the UPPERCASE name of that type
with nothing else.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4262">#4262</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-114"><span class="target" id="change-214869a306f72f33237772d33fc332ec"><strong>[schema] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-214869a306f72f33237772d33fc332ec">¶</a></span><p>Remove deprecated class <code class="docutils literal notranslate"><span class="pre">Binary</span></code>. Please use <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.LargeBinary" title="sqlalchemy.types.LargeBinary"><code class="xref py py-class docutils literal notranslate"><span class="pre">LargeBinary</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4643">#4643</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-115"><span class="target" id="change-643698b13ac1686f5ddc65328f5cbe53"><strong>[schema] [renamed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-643698b13ac1686f5ddc65328f5cbe53">¶</a></span><p>Renamed the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.tometadata" title="sqlalchemy.schema.Table.tometadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.tometadata()</span></code></a> method to
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.to_metadata" title="sqlalchemy.schema.Table.to_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.to_metadata()</span></code></a>.  The previous name remains with a
deprecation warning.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5413">#5413</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-116"><span class="target" id="change-4d92ec311e2f712ddf8ae0b98c2d8f0c"><strong>[schema] [sql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-4d92ec311e2f712ddf8ae0b98c2d8f0c">¶</a></span><p>Added the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Identity" title="sqlalchemy.schema.Identity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code></a> construct that can be used to
configure identity columns rendered with GENERATED { ALWAYS |
BY DEFAULT } AS IDENTITY. Currently the supported backends are
PostgreSQL &gt;= 10, Oracle &gt;= 12 and MSSQL (with different syntax
and a subset of functionalities).</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5324">#5324</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5360">#5360</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5362">#5362</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-extensions">
<h3>extensions<a class="headerlink" href="#change-1.4.0b1-extensions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-117"><span class="target" id="change-76a96d2463b5821e923f9e16f3311898"><strong>[extensions] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-76a96d2463b5821e923f9e16f3311898">¶</a></span><p>Custom compiler constructs created using the <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlalchemy.ext.compiled</span></code>
extension will automatically add contextual information to the compiler
when a custom construct is interpreted as an element in the columns
clause of a SELECT statement, such that the custom element will be
targetable as a key in result row mappings, which is the kind of targeting
that the ORM uses in order to match column elements into result tuples.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4887">#4887</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-118"><span class="target" id="change-5fd17312ee1ace20f6c4b126800ca065"><strong>[extensions] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-5fd17312ee1ace20f6c4b126800ca065">¶</a></span><p>Added new parameter <a class="reference internal" href="../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase.prepare.params.autoload_with" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.autoload_with</span></code></a>
which supersedes <a class="reference internal" href="../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.reflect</span></code></a>
and <a class="reference internal" href="../orm/extensions/automap.html#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine" title="sqlalchemy.ext.automap.AutomapBase.prepare"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">AutomapBase.prepare.engine</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5142">#5142</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-postgresql">
<h3>postgresql<a class="headerlink" href="#change-1.4.0b1-postgresql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-119"><span class="target" id="change-2f7cd0aadae339ec1740cb34996ea1d0"><strong>[postgresql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2f7cd0aadae339ec1740cb34996ea1d0">¶</a></span><p>Added support for PostgreSQL “readonly” and “deferrable” flags for all of
psycopg2, asyncpg and pg8000 dialects.   This takes advantage of a newly
generalized version of the “isolation level” API to support other kinds of
session attributes set via execution options that are reliably reset
when connections are returned to the connection pool.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-readonly-deferrable"><span class="std std-ref">Setting READ ONLY / DEFERRABLE</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5549">#5549</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-120"><span class="target" id="change-13c4a8ef5a488ea92cc1daff0f5f3034"><strong>[postgresql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-13c4a8ef5a488ea92cc1daff0f5f3034">¶</a></span><p>The maximum buffer size for the <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedRowResultProxy</span></code>, which
is used by dialects such as PostgreSQL when <code class="docutils literal notranslate"><span class="pre">stream_results=True</span></code>, can
now be set to a number greater than 1000 and the buffer will grow to
that size.  Previously, the buffer would not go beyond 1000 even if the
value were set larger.   The growth of the buffer is also now based
on a simple multiplying factor currently set to 5.  Pull request courtesy
Soumaya Mauthoor.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4914">#4914</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-121"><span class="target" id="change-a6b2d84ef4ad3e73ed573ca3d4a27f1b"><strong>[postgresql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-a6b2d84ef4ad3e73ed573ca3d4a27f1b">¶</a></span><p>When using the psycopg2 dialect for PostgreSQL, psycopg2 minimum version is
set at 2.7. The psycopg2 dialect relies upon many features of psycopg2
released in the past few years, so to simplify the dialect, version 2.7,
released in March, 2017 is now the minimum version required.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-122"><span class="target" id="change-50b1036e09bca9ab332a85960d88f0aa"><strong>[postgresql] [performance]</strong> <a class="changelog-reference headerlink reference internal" href="#change-50b1036e09bca9ab332a85960d88f0aa">¶</a></span><p>The psycopg2 dialect now defaults to using the very performant
<code class="docutils literal notranslate"><span class="pre">execute_values()</span></code> psycopg2 extension for compiled INSERT statements,
and also implements RETURNING support when this extension is used.  This
allows INSERT statements that even include an autoincremented SERIAL
or IDENTITY value to run very fast while still being able to return the
newly generated primary key values.   The ORM will then integrate this
new feature in a separate change.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-5401"><span class="std std-ref">psycopg2 dialect features “execute_values” with RETURNING for INSERT statements by default</span></a> - full list of changes regarding the
<code class="docutils literal notranslate"><span class="pre">executemany_mode</span></code> parameter.</p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5401">#5401</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-123"><span class="target" id="change-493b1ad80e0643bcd7f28ccd453ca356"><strong>[postgresql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-493b1ad80e0643bcd7f28ccd453ca356">¶</a></span><p>The pg8000 dialect has been revised and modernized for the most recent
version of the pg8000 driver for PostgreSQL.  Changes to the dialect
include:</p>
<ul>
<li><p>All data types are now sent as text rather than binary.</p></li>
<li><p>Using adapters, custom types can be plugged in to pg8000.</p></li>
<li><p>Previously, named prepared statements were used for all statements.
Now unnamed prepared statements are used by default, and named
prepared statements can be used explicitly by calling the
Connection.prepare() method, which returns a PreparedStatement
object.</p></li>
</ul>
<p>Pull request courtesy Tony Locke.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-124"><span class="target" id="change-37736e8ac696a35a19e8d27613aa4b07"><strong>[postgresql] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-37736e8ac696a35a19e8d27613aa4b07">¶</a></span><p>The pygresql and py-postgresql dialects are deprecated.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5189">#5189</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-125"><span class="target" id="change-3687655465c25a39b968b4f5f6e9170b"><strong>[postgresql] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-3687655465c25a39b968b4f5f6e9170b">¶</a></span><p>Remove support for deprecated engine URLs of the form <code class="docutils literal notranslate"><span class="pre">postgres://</span></code>;
this has emitted a warning for many years and projects should be
using <code class="docutils literal notranslate"><span class="pre">postgresql://</span></code>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4643">#4643</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-mysql">
<h3>mysql<a class="headerlink" href="#change-1.4.0b1-mysql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-126"><span class="target" id="change-0f6dbc4e3b494db9ae2c616216fa74a6"><strong>[mysql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0f6dbc4e3b494db9ae2c616216fa74a6">¶</a></span><p>Added support for MariaDB Connector/Python to the mysql dialect. Original
pull request courtesy Georg Richter.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5459">#5459</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-127"><span class="target" id="change-05af504ece2c095badc33ebc6c70de4b"><strong>[mysql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-05af504ece2c095badc33ebc6c70de4b">¶</a></span><p>Added a new dialect token “mariadb” that may be used in place of “mysql” in
the <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> URL.  This will deliver a MariaDB dialect
subclass of the MySQLDialect in use that forces the “is_mariadb” flag to
True.  The dialect will raise an error if a server version string that does
not indicate MariaDB in use is received.   This is useful for
MariaDB-specific testing scenarios as well as to support applications that
are hardcoding to MariaDB-only concepts.  As MariaDB and MySQL featuresets
and usage patterns continue to diverge, this pattern may become more
prominent.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5496">#5496</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-128"><span class="target" id="change-7e5f04e1f38f0ac59ed6eb540ae7f649"><strong>[mysql] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-7e5f04e1f38f0ac59ed6eb540ae7f649">¶</a></span><p>Added support for use of the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> construct with MariaDB 10.3
and greater, as this is now supported by this database.  The construct
integrates with the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object in the same way that it does for
other databases like PostgreSQL and Oracle; if is present on the integer
primary key “autoincrement” column, it is used to generate defaults.   For
backwards compatibility, to support a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> that has a
<a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> on it to support sequence only databases like Oracle,
while still not having the sequence fire off for MariaDB, the optional=True
flag should be set, which indicates the sequence should only be used to
generate the primary key if the target database offers no other option.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4976"><span class="std std-ref">Added Sequence support for MariaDB 10.3</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4976">#4976</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-129"><span class="target" id="change-73c895fe31614ae3b96915efece3a08b"><strong>[mysql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-73c895fe31614ae3b96915efece3a08b">¶</a></span><p>The MySQL and MariaDB dialects now query from the information_schema.tables
system view in order to determine if a particular table exists or not.
Previously, the “DESCRIBE” command was used with an exception catch to
detect non-existent,  which would have the undesirable effect of emitting a
ROLLBACK on the connection. There appeared to be legacy encoding issues
which prevented the use of “SHOW TABLES”, for this, but as MySQL support is
now at 5.0.2  or above due to <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4189">#4189</a>, the information_schema tables
are now available in all cases.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-130"><span class="target" id="change-fad055bbcf5fb8a7bdd77063a39fb7da"><strong>[mysql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-fad055bbcf5fb8a7bdd77063a39fb7da">¶</a></span><p>The “skip_locked” keyword used with <code class="docutils literal notranslate"><span class="pre">with_for_update()</span></code> will render “SKIP
LOCKED” on all MySQL backends, meaning it will fail for MySQL less than
version 8 and on current MariaDB backends.  This is because those backends
do not support “SKIP LOCKED” or any equivalent, so this error should not be
silently ignored.   This is upgraded from a warning in the 1.3 series.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5568">#5568</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-131"><span class="target" id="change-758e37887f5ce3cbe8065c01faaf6111"><strong>[mysql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-758e37887f5ce3cbe8065c01faaf6111">¶</a></span><p>MySQL dialect’s server_version_info tuple is now all numeric.  String
tokens like “MariaDB” are no longer present so that numeric comparison
works in all cases.  The .is_mariadb flag on the dialect should be
consulted for whether or not mariadb was detected.   Additionally removed
structures meant to support extremely old MySQL versions 3.x and 4.x;
the minimum MySQL version supported is now version 5.0.2.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4189">#4189</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-132"><span class="target" id="change-97082c4e1fdfd01f3580f7bc944419ed"><strong>[mysql] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-97082c4e1fdfd01f3580f7bc944419ed">¶</a></span><p>The OurSQL dialect is deprecated.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5189">#5189</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-133"><span class="target" id="change-fe61e2db1d883442ff4dba1fec003519"><strong>[mysql] [removed]</strong> <a class="changelog-reference headerlink reference internal" href="#change-fe61e2db1d883442ff4dba1fec003519">¶</a></span><p>Remove deprecated dialect <code class="docutils literal notranslate"><span class="pre">mysql+gaerdbms</span></code> that has been deprecated
since version 1.0. Use the MySQLdb dialect directly.</p>
<p>Remove deprecated parameter <code class="docutils literal notranslate"><span class="pre">quoting</span></code> from <a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.ENUM" title="sqlalchemy.dialects.mysql.ENUM"><code class="xref py py-class docutils literal notranslate"><span class="pre">ENUM</span></code></a>
and <a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.SET" title="sqlalchemy.dialects.mysql.SET"><code class="xref py py-class docutils literal notranslate"><span class="pre">SET</span></code></a> in the <code class="docutils literal notranslate"><span class="pre">mysql</span></code> dialect. The values passed to the
enum or the set are quoted by SQLAlchemy when needed automatically.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4643">#4643</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-sqlite">
<h3>sqlite<a class="headerlink" href="#change-1.4.0b1-sqlite" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-134"><span class="target" id="change-f7e2cf22c9fd7989654a2e38b302aad8"><strong>[sqlite] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-f7e2cf22c9fd7989654a2e38b302aad8">¶</a></span><p>Dropped support for right-nested join rewriting to support old SQLite
versions prior to 3.7.16, released in 2013.   It is expected that
all modern Python versions among those now supported should all include
much newer versions of SQLite.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4895"><span class="std std-ref">Removed “join rewriting” logic from SQLite dialect; updated imports</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4895">#4895</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-mssql">
<h3>mssql<a class="headerlink" href="#change-1.4.0b1-mssql" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-135"><span class="target" id="change-042e7e87bf45bb0b90dccb601f0af224"><strong>[mssql] [feature] [sql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-042e7e87bf45bb0b90dccb601f0af224">¶</a></span><p>Added support for the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> datatype on the SQL Server
dialect using the <a class="reference internal" href="../dialects/mssql.html#sqlalchemy.dialects.mssql.JSON" title="sqlalchemy.dialects.mssql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> implementation, which implements SQL
Server’s JSON functionality against the <code class="docutils literal notranslate"><span class="pre">NVARCHAR(max)</span></code> datatype as per
SQL Server documentation. Implementation courtesy Gord Thompson.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4384">#4384</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-136"><span class="target" id="change-0f9751623e95bf8b19d0467efcd2c479"><strong>[mssql] [feature]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0f9751623e95bf8b19d0467efcd2c479">¶</a></span><p>Added support for “CREATE SEQUENCE” and full <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> support for
Microsoft SQL Server.  This removes the deprecated feature of using
<a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> objects to manipulate IDENTITY characteristics which
should now be performed using <code class="docutils literal notranslate"><span class="pre">mssql_identity_start</span></code> and
<code class="docutils literal notranslate"><span class="pre">mssql_identity_increment</span></code> as documented at <a class="reference internal" href="../dialects/mssql.html#mssql-identity"><span class="std std-ref">Auto Increment Behavior / IDENTITY Columns</span></a>. The
change includes a new parameter <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence.params.data_type" title="sqlalchemy.schema.Sequence"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Sequence.data_type</span></code></a> to
accommodate SQL Server’s choice of datatype, which for that backend
includes INTEGER, BIGINT, and DECIMAL(n, 0).   The default starting value
for SQL Server’s version of <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> has been set at 1; this
default is now emitted within the CREATE SEQUENCE DDL for all backends.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_14.html#change-4235"><span class="std std-ref">Added Sequence support distinct from IDENTITY to SQL Server</span></a></p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4235">#4235</a>, <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4633">#4633</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-137"><span class="target" id="change-24786ed71119813a475fcb9d008f6fa4"><strong>[mssql] [usecase] [postgresql] [reflection] [schema]</strong> <a class="changelog-reference headerlink reference internal" href="#change-24786ed71119813a475fcb9d008f6fa4">¶</a></span><p>Improved support for covering indexes (with INCLUDE columns). Added the
ability for postgresql to render CREATE INDEX statements with an INCLUDE
clause from Core. Index reflection also report INCLUDE columns separately
for both mssql and postgresql (11+).</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4458">#4458</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-138"><span class="target" id="change-aed14f284b22eac3c1e9199ceccc19bf"><strong>[mssql] [usecase] [postgresql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-aed14f284b22eac3c1e9199ceccc19bf">¶</a></span><p>Added support for inspection / reflection of partial indexes / filtered
indexes, i.e. those which use the <code class="docutils literal notranslate"><span class="pre">mssql_where</span></code> or <code class="docutils literal notranslate"><span class="pre">postgresql_where</span></code>
parameters, with <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>.   The entry is both part of the
dictionary returned by <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes" title="sqlalchemy.engine.reflection.Inspector.get_indexes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_indexes()</span></code></a> as well as part of a
reflected <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> construct that was reflected.  Pull
request courtesy Ramon Williams.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4966">#4966</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-139"><span class="target" id="change-e5b6729b5de299e079d14d7dd0a17d87"><strong>[mssql] [usecase] [reflection]</strong> <a class="changelog-reference headerlink reference internal" href="#change-e5b6729b5de299e079d14d7dd0a17d87">¶</a></span><p>Added support for reflection of temporary tables with the SQL Server dialect.
Table names that are prefixed by a pound sign “#” are now introspected from
the MSSQL “tempdb” system catalog.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5506">#5506</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-140"><span class="target" id="change-c865344fd80ecd73ea290c84354e83f9"><strong>[mssql] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c865344fd80ecd73ea290c84354e83f9">¶</a></span><p>SQL Server OFFSET and FETCH keywords are now used for limit/offset, rather
than using a window function, for SQL Server versions 11 and higher. TOP is
still used for a query that features only LIMIT.   Pull request courtesy
Elkin.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5084">#5084</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-141"><span class="target" id="change-6291df9b333cf00429e9746fdd984094"><strong>[mssql] [bug] [schema]</strong> <a class="changelog-reference headerlink reference internal" href="#change-6291df9b333cf00429e9746fdd984094">¶</a></span><p>Fixed an issue where <code class="xref py py-meth docutils literal notranslate"><span class="pre">sqlalchemy.engine.reflection.has_table()</span></code> always returned
<code class="docutils literal notranslate"><span class="pre">False</span></code> for temporary tables.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5597">#5597</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-142"><span class="target" id="change-b4d7ca68ce89651e76f3ddf94efa7ab0"><strong>[mssql] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b4d7ca68ce89651e76f3ddf94efa7ab0">¶</a></span><p>Fixed the base class of the <a class="reference internal" href="../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET" title="sqlalchemy.dialects.mssql.DATETIMEOFFSET"><code class="xref py py-class docutils literal notranslate"><span class="pre">DATETIMEOFFSET</span></code></a> datatype to
be based on the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> class hierarchy, as this is a
datetime-holding datatype.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4980">#4980</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-143"><span class="target" id="change-b1a5073035c1c3cb9e55fb58d394e99a"><strong>[mssql] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-b1a5073035c1c3cb9e55fb58d394e99a">¶</a></span><p>The adodbapi and mxODBC dialects are deprecated.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5189">#5189</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-144"><span class="target" id="change-d336d859babeb66e0bdcba407bea5410"><strong>[mssql]</strong> <a class="changelog-reference headerlink reference internal" href="#change-d336d859babeb66e0bdcba407bea5410">¶</a></span><p>The mssql dialect will assume that at least MSSQL 2005 is used.
There is no hard exception raised if a previous version is detected,
but operations may fail for older versions.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-145"><span class="target" id="change-44ea300fd9dafdb8df99a64a11106079"><strong>[mssql] [reflection]</strong> <a class="changelog-reference headerlink reference internal" href="#change-44ea300fd9dafdb8df99a64a11106079">¶</a></span><p>As part of the support for reflecting <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Identity" title="sqlalchemy.schema.Identity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code></a> objects,
the method <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns" title="sqlalchemy.engine.reflection.Inspector.get_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_columns()</span></code></a> no longer returns
<code class="docutils literal notranslate"><span class="pre">mssql_identity_start</span></code> and <code class="docutils literal notranslate"><span class="pre">mssql_identity_increment</span></code> as part of the
<code class="docutils literal notranslate"><span class="pre">dialect_options</span></code>. Use the information in the <code class="docutils literal notranslate"><span class="pre">identity</span></code> key instead.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5527">#5527</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-146"><span class="target" id="change-0b373fe2d642bc5e4c50a2ab78b10267"><strong>[mssql] [engine]</strong> <a class="changelog-reference headerlink reference internal" href="#change-0b373fe2d642bc5e4c50a2ab78b10267">¶</a></span><p>Deprecated the <code class="docutils literal notranslate"><span class="pre">legacy_schema_aliasing</span></code> parameter to
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sqlalchemy.create_engine()</span></code></a>.   This is a long-outdated parameter that has
defaulted to False since version 1.1.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4809">#4809</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-oracle">
<h3>oracle<a class="headerlink" href="#change-1.4.0b1-oracle" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-147"><span class="target" id="change-83599e26ac8e08a7ae81cc0146d3b9bd"><strong>[oracle] [usecase]</strong> <a class="changelog-reference headerlink reference internal" href="#change-83599e26ac8e08a7ae81cc0146d3b9bd">¶</a></span><p>The max_identifier_length for the Oracle dialect is now 128 characters by
default, unless compatibility version less than 12.2 upon first connect, in
which case the legacy length of 30 characters is used.  This is a
continuation of the issue as committed to the 1.3 series which adds max
identifier length detection upon first connect as well as warns for the
change in Oracle server.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/oracle.html#oracle-max-identifier-lengths"><span class="std std-ref">Max Identifier Lengths</span></a> - in the Oracle dialect documentation</p>
</div>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4857">#4857</a></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-148"><span class="target" id="change-2e7befd2f0d906af8b093824bbb3b68a"><strong>[oracle] [change]</strong> <a class="changelog-reference headerlink reference internal" href="#change-2e7befd2f0d906af8b093824bbb3b68a">¶</a></span><p>The LIMIT / OFFSET scheme used in Oracle now makes use of named subqueries
rather than unnamed subqueries when it transparently rewrites a SELECT
statement to one that uses a subquery that includes ROWNUM.  The change is
part of a larger change where unnamed subqueries are no longer directly
supported by Core, as well as to modernize the internal use of the select()
construct within the Oracle dialect.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-149"><span class="target" id="change-947d0a1d2de3bcd4570e9fefc4cdecab"><strong>[oracle] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-947d0a1d2de3bcd4570e9fefc4cdecab">¶</a></span><p>Correctly render <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> and <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Identity" title="sqlalchemy.schema.Identity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Identity</span></code></a>
column options <code class="docutils literal notranslate"><span class="pre">nominvalue</span></code> and <code class="docutils literal notranslate"><span class="pre">nomaxvalue</span></code> as <code class="docutils literal notranslate"><span class="pre">NOMAXVALUE`</span> <span class="pre">and</span>
<span class="pre">``NOMINVALUE</span></code> on oracle database.</p>
<p></p>
</p>
</li>
<li><p class="caption" id="change-1.4.0b1-150"><span class="target" id="change-aec5bc92cb1b62b9ffb44f5a7a68fc89"><strong>[oracle] [bug]</strong> <a class="changelog-reference headerlink reference internal" href="#change-aec5bc92cb1b62b9ffb44f5a7a68fc89">¶</a></span><p>The <a class="reference internal" href="../dialects/oracle.html#sqlalchemy.dialects.oracle.INTERVAL" title="sqlalchemy.dialects.oracle.INTERVAL"><code class="xref py py-class docutils literal notranslate"><span class="pre">INTERVAL</span></code></a> class of the Oracle dialect is now correctly
a subclass of the abstract version of <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Interval" title="sqlalchemy.types.Interval"><code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code></a> as well as the
correct “emulated” base class, which allows for correct behavior under both
native and non-native modes; previously it was only based on
<a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a>.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4971">#4971</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-firebird">
<h3>firebird<a class="headerlink" href="#change-1.4.0b1-firebird" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-151"><span class="target" id="change-74604e1b9b4adfb2a213e94566ab3049"><strong>[firebird] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-74604e1b9b4adfb2a213e94566ab3049">¶</a></span><p>The Firebird dialect is deprecated, as there is now a 3rd party
dialect that supports this database.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5189">#5189</a></p>
</p>
</li>
</ul>
</section>
<section id="change-1.4.0b1-misc">
<h3>misc<a class="headerlink" href="#change-1.4.0b1-misc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p class="caption" id="change-1.4.0b1-152"><span class="target" id="change-c1b5b06e39462b02766f38a8aad19341"><strong>[misc] [deprecated]</strong> <a class="changelog-reference headerlink reference internal" href="#change-c1b5b06e39462b02766f38a8aad19341">¶</a></span><p>The Sybase dialect is deprecated.</p>
<p>References: <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5189">#5189</a></p>
</p>
</li>
</ul>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="migration_20.html" title="previous chapter">Migrating to SQLAlchemy 2.0</a>
        Next:
        <a href="changelog_13.html" title="next chapter">1.3 Changelog</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2021, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 4.1.2.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.4.23',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


