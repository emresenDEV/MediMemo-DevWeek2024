<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

        <title>
            
    
    What’s New in SQLAlchemy 1.4?
 &mdash;
    SQLAlchemy 1.4 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.4 Documentation" href="../index.html" />
        <link rel="up" title="Changes and Migration" href="index.html" />
        <link rel="next" title="Migrating to SQLAlchemy 2.0" href="migration_20.html" />
        <link rel="prev" title="Changes and Migration" href="index.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.4.23</span>


        | Release Date: August 18, 2021

    </div>

    <h1><a href="../index.html">SQLAlchemy 1.4 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.4 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="Changes and Migration">Changes and Migration</a>
        </h3>

        <ul>
<li class="selected"><span class="link-container"><strong>What’s New in SQLAlchemy 1.4?</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#major-api-changes-and-features-general">Major API changes and features - General</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#python-3-6-is-the-minimum-python-3-version-python-2-7-still-supported">Python 3.6 is the minimum Python 3 version; Python 2.7 still supported</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-query-is-internally-unified-with-select-update-delete-2-0-style-execution-available">ORM Query is internally unified with select, update, delete; 2.0 style execution available</a></span></li>
<li><span class="link-container"><a class="reference external" href="#transparent-sql-compilation-caching-added-to-all-dql-dml-statements-in-core-orm">Transparent SQL Compilation Caching added to All DQL, DML Statements in Core, ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="#declarative-is-now-integrated-into-the-orm-with-new-features">Declarative is now integrated into the ORM with new features</a></span></li>
<li><span class="link-container"><a class="reference external" href="#python-dataclasses-attrs-supported-w-declarative-imperative-mappings">Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings</a></span></li>
<li><span class="link-container"><a class="reference external" href="#asynchronous-io-support-for-core-and-orm">Asynchronous IO Support for Core and ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="#many-core-and-orm-statement-objects-now-perform-much-of-their-construction-and-validation-in-the-compile-phase">Many Core and ORM statement objects now perform much of their construction and validation in the compile phase</a></span></li>
<li><span class="link-container"><a class="reference external" href="#repaired-internal-importing-conventions-such-that-code-linters-may-work-correctly">Repaired internal importing conventions such that code linters may work correctly</a></span></li>
<li><span class="link-container"><a class="reference external" href="#support-for-sql-regular-expression-operators">Support for SQL Regular Expression operators</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy-2-0-deprecations-mode">SQLAlchemy 2.0 Deprecations Mode</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#api-and-behavioral-changes-core">API and Behavioral Changes - Core</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#a-select-statement-is-no-longer-implicitly-considered-to-be-a-from-clause">A SELECT statement is no longer implicitly considered to be a FROM clause</a></span></li>
<li><span class="link-container"><a class="reference external" href="#select-join-and-outerjoin-add-join-criteria-to-the-current-query-rather-than-creating-a-subquery">select().join() and outerjoin() add JOIN criteria to the current query, rather than creating a subquery</a></span></li>
<li><span class="link-container"><a class="reference external" href="#the-url-object-is-now-immutable">The URL object is now immutable</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#changes-to-createengineplugin">Changes to CreateEnginePlugin</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#select-case-now-accept-positional-expressions">select(), case() now accept positional expressions</a></span></li>
<li><span class="link-container"><a class="reference external" href="#all-in-expressions-render-parameters-for-each-value-in-the-list-on-the-fly-e-g-expanding-parameters">All IN expressions render parameters for each value in the list on the fly (e.g. expanding parameters)</a></span></li>
<li><span class="link-container"><a class="reference external" href="#built-in-from-linting-will-warn-for-any-potential-cartesian-products-in-a-select-statement">Built-in FROM linting will warn for any potential cartesian products in a SELECT statement</a></span></li>
<li><span class="link-container"><a class="reference external" href="#new-result-object">New Result object</a></span></li>
<li><span class="link-container"><a class="reference external" href="#rowproxy-is-no-longer-a-proxy-is-now-called-row-and-behaves-like-an-enhanced-named-tuple">RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#rationale-to-behave-more-like-a-named-tuple-rather-than-a-mapping">Rationale: To behave more like a named tuple rather than a mapping</a></span></li>
<li><span class="link-container"><a class="reference external" href="#proxying-behavior-goes-away-was-also-unnecessary-in-modern-usage">Proxying behavior goes away, was also unnecessary in modern usage</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#select-objects-and-derived-from-clauses-allow-for-duplicate-columns-and-column-labels">SELECT objects and derived FROM clauses allow for duplicate columns and column labels</a></span></li>
<li><span class="link-container"><a class="reference external" href="#improved-column-labeling-for-simple-column-expressions-using-cast-or-similar">Improved column labeling for simple column expressions using CAST or similar</a></span></li>
<li><span class="link-container"><a class="reference external" href="#new-post-compile-bound-parameters-used-for-limit-offset-in-oracle-sql-server">New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server</a></span></li>
<li><span class="link-container"><a class="reference external" href="#connection-level-transactions-can-now-be-inactive-based-on-subtransaction">Connection-level transactions can now be inactive based on subtransaction</a></span></li>
<li><span class="link-container"><a class="reference external" href="#enum-and-boolean-datatypes-no-longer-default-to-create-constraint">Enum and Boolean datatypes no longer default to “create constraint”</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#new-features-orm">New Features - ORM</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#raiseload-for-columns">Raiseload for Columns</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-batch-inserts-with-psycopg2-now-batch-statements-with-returning-in-most-cases">ORM Batch inserts with psycopg2 now batch statements with RETURNING in most cases</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-bulk-update-and-delete-use-returning-for-fetch-strategy-when-available">ORM Bulk Update and Delete use RETURNING for “fetch” strategy when available</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#behavioral-changes-orm">Behavioral Changes - ORM</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#the-keyedtuple-object-returned-by-query-is-replaced-by-row">The “KeyedTuple” object returned by Query is replaced by Row</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-features-new-autobegin-behavior">Session features new “autobegin” behavior</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#rationale">Rationale</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#viewonly-relationships-don-t-synchronize-backrefs">Viewonly relationships don’t synchronize backrefs</a></span></li>
<li><span class="link-container"><a class="reference external" href="#cascade-backrefs-behavior-deprecated-for-removal-in-2-0">cascade_backrefs behavior deprecated for removal in 2.0</a></span></li>
<li><span class="link-container"><a class="reference external" href="#eager-loaders-emit-during-unexpire-operations">Eager loaders emit during unexpire operations</a></span></li>
<li><span class="link-container"><a class="reference external" href="#accessing-an-uninitialized-collection-attribute-on-a-transient-object-no-longer-mutates-dict">Accessing an uninitialized collection attribute on a transient object no longer mutates __dict__</a></span></li>
<li><span class="link-container"><a class="reference external" href="#the-new-instance-conflicts-with-existing-identity-error-is-now-a-warning">The “New instance conflicts with existing identity” error is now a warning</a></span></li>
<li><span class="link-container"><a class="reference external" href="#persistence-related-cascade-operations-disallowed-with-viewonly-true">Persistence-related cascade operations disallowed with viewonly=True</a></span></li>
<li><span class="link-container"><a class="reference external" href="#stricter-behavior-when-querying-inheritance-mappings-using-custom-queries">Stricter behavior when querying inheritance mappings using custom queries</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#dialect-changes">Dialect Changes</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#psycopg2-version-2-7-or-higher-is-required-for-the-postgresql-psycopg2-dialect">psycopg2 version 2.7 or higher is required for the PostgreSQL psycopg2 dialect</a></span></li>
<li><span class="link-container"><a class="reference external" href="#psycopg2-dialect-no-longer-has-limitations-regarding-bound-parameter-names">psycopg2 dialect no longer has limitations regarding bound parameter names</a></span></li>
<li><span class="link-container"><a class="reference external" href="#psycopg2-dialect-features-execute-values-with-returning-for-insert-statements-by-default">psycopg2 dialect features “execute_values” with RETURNING for INSERT statements by default</a></span></li>
<li><span class="link-container"><a class="reference external" href="#removed-join-rewriting-logic-from-sqlite-dialect-updated-imports">Removed “join rewriting” logic from SQLite dialect; updated imports</a></span></li>
<li><span class="link-container"><a class="reference external" href="#added-sequence-support-for-mariadb-10-3">Added Sequence support for MariaDB 10.3</a></span></li>
<li><span class="link-container"><a class="reference external" href="#added-sequence-support-distinct-from-identity-to-sql-server">Added Sequence support distinct from IDENTITY to SQL Server</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="migration_20.html">Migrating to SQLAlchemy 2.0</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_14.html">1.4 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_13.html">1.3 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_12.html">1.2 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_11.html">1.1 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_10.html">1.0 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_09.html">0.9 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_08.html">0.8 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_07.html">0.7 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_06.html">0.6 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_05.html">0.5 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_04.html">0.4 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_03.html">0.3 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_02.html">0.2 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_01.html">0.1 Changelog</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_13.html">What’s New in SQLAlchemy 1.3?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_12.html">What’s New in SQLAlchemy 1.2?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_11.html">What’s New in SQLAlchemy 1.1?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_10.html">What’s New in SQLAlchemy 1.0?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_09.html">What’s New in SQLAlchemy 0.9?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_08.html">What’s New in SQLAlchemy 0.8?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_07.html">What’s New in SQLAlchemy 0.7?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_06.html">What’s New in SQLAlchemy 0.6?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html">What’s new in SQLAlchemy 0.5?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html">What’s new in SQLAlchemy 0.4?</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar changelog-migration_14" >
        
<section id="what-s-new-in-sqlalchemy-1-4">
<span id="migration-14-toplevel"></span><h1>What’s New in SQLAlchemy 1.4?<a class="headerlink" href="#what-s-new-in-sqlalchemy-1-4" title="Permalink to this headline">¶</a></h1>
<div class="admonition-about-this-document admonition">
<p class="admonition-title">About this Document</p>
<p>This document describes changes between SQLAlchemy version 1.3
and SQLAlchemy version 1.4.</p>
<p>Version 1.4 is taking on a different focus than other SQLAlchemy releases
in that it is in many ways attempting to serve as a potential migration
point for a more dramatic series of API changes currently planned for
release  2.0 of SQLAlchemy.   The focus of SQLAlchemy 2.0 is a modernized
and slimmed down API that removes lots of usage patterns that have long
been discouraged, as well as mainstreams the best ideas in SQLAlchemy as
first class API features, with the goal being that there is much less
ambiguity in how the API is to be used, as well as that a series of
implicit behaviors and rarely-used API flags that complicate the internals
and hinder performance will be removed.</p>
<p>For the current status of SQLAlchemy 2.0, see <a class="reference internal" href="migration_20.html"><span class="std std-ref">Migrating to SQLAlchemy 2.0</span></a>.</p>
</div>
<section id="major-api-changes-and-features-general">
<h2>Major API changes and features - General<a class="headerlink" href="#major-api-changes-and-features-general" title="Permalink to this headline">¶</a></h2>
<section id="python-3-6-is-the-minimum-python-3-version-python-2-7-still-supported">
<span id="change-5634"></span><h3>Python 3.6 is the minimum Python 3 version; Python 2.7 still supported<a class="headerlink" href="#python-3-6-is-the-minimum-python-3-version-python-2-7-still-supported" title="Permalink to this headline">¶</a></h3>
<p>As Python 3.5 reached EOL in September of 2020, SQLAlchemy 1.4 now places
version 3.6 as the minimum Python 3 version.  Python 2.7 is still supported,
however the SQLAlchemy 1.4 series will be the last series to support Python 2.</p>
</section>
<section id="orm-query-is-internally-unified-with-select-update-delete-2-0-style-execution-available">
<span id="change-5159"></span><h3>ORM Query is internally unified with select, update, delete; 2.0 style execution available<a class="headerlink" href="#orm-query-is-internally-unified-with-select-update-delete-2-0-style-execution-available" title="Permalink to this headline">¶</a></h3>
<p>The biggest conceptual change to SQLAlchemy for version 2.0 and essentially
in 1.4 as well is that the great separation between the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>
construct in Core and the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object in the ORM has been removed,
as well as between the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.update" title="sqlalchemy.orm.Query.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.update()</span></code></a> and <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.delete" title="sqlalchemy.orm.Query.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.delete()</span></code></a>
methods in how they relate to <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Update" title="sqlalchemy.sql.expression.Update"><code class="xref py py-class docutils literal notranslate"><span class="pre">Update</span></code></a> and <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Delete" title="sqlalchemy.sql.expression.Delete"><code class="xref py py-class docutils literal notranslate"><span class="pre">Delete</span></code></a>.</p>
<p>With regards to <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> and <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>, these two objects
have for many versions had similar, largely overlapping APIs and even some
ability to change between one and the other, while remaining very different in
their usage patterns and behaviors.   The historical background for this was
that the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object was introduced to overcome shortcomings in
the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object which used to be at the core of how ORM objects
were queried, except that they had to be queried in terms of
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> metadata only.    However <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> had only a
simplistic interface for loading objects, and only over the course of many
major releases did it eventually gain most of the flexibility of the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object, which then led to the ongoing awkwardness that
these two objects became highly similar yet still largely incompatible with
each other.</p>
<p>In version 1.4, all Core and ORM SELECT statements are rendered from a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object directly; when the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object
is used, at statement invocation time it copies its state to a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>
which is then invoked internally using <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> execution.   Going forward,
the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object will become legacy only, and applications will
be encouraged to move to <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> execution which allows Core constructs
to be used freely against ORM entities:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">future</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">sess</span><span class="p">:</span>

    <span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;sandy&#39;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2">mail%&quot;</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">scalars</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">user</span><span class="p">)</span></pre></div>
</div>
<p>Things to note about the above example:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> and <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.sessionmaker" title="sqlalchemy.orm.sessionmaker"><code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code></a> objects now feature
full context manager (i.e. the <code class="docutils literal notranslate"><span class="pre">with:</span></code> statement) capability;
see the revised documentation at <a class="reference internal" href="../orm/session_basics.html#session-getting"><span class="std std-ref">Opening and Closing a Session</span></a> for an example.</p></li>
<li><p>Within the 1.4 series, all <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> ORM invocation uses a
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> that includes the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.params.future" title="sqlalchemy.orm.Session"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.future</span></code></a>
flag set to <code class="docutils literal notranslate"><span class="pre">True</span></code>; this flag indicates the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> should
have 2.0-style behaviors, which include that ORM queries can be invoked
from <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-class docutils literal notranslate"><span class="pre">execute</span></code></a> as well as some changes in transactional
features.   In version 2.0 this flag will always be <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct no longer needs brackets around the
columns clause; see <a class="reference internal" href="#change-5284"><span class="std std-ref">select(), case() now accept positional expressions</span></a> for background on this improvement.</p></li>
<li><p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  / <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object has a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>
method that acts like that of the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> and even accommodates
an ORM relationship attribute (without breaking the separation between
Core and ORM!) - see <a class="reference internal" href="#change-select-join"><span class="std std-ref">select().join() and outerjoin() add JOIN criteria to the current query, rather than creating a subquery</span></a> for background on this.</p></li>
<li><p>Statements that work with ORM entities and are expected to return ORM
results are invoked using <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>.  See
<a class="reference internal" href="../orm/session_basics.html#session-querying-20"><span class="std std-ref">Querying (2.0 style)</span></a> for a primer.</p></li>
<li><p>a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object is returned, rather than a plain list, which
itself is a much more sophisticated version of the previous <code class="docutils literal notranslate"><span class="pre">ResultProxy</span></code>
object; this object is now used both for Core and ORM results.   See
<a class="reference internal" href="#change-result-14-core"><span class="std std-ref">New Result object</span></a>,
<a class="reference internal" href="#change-4710-core"><span class="std std-ref">RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple</span></a>, and <a class="reference internal" href="#change-4710-orm"><span class="std std-ref">The “KeyedTuple” object returned by Query is replaced by Row</span></a> for information on this.</p></li>
</ul>
<p>Throughout SQLAlchemy’s documentation, there will be many references to
<a class="reference internal" href="../glossary.html#term-1.x-style"><span class="xref std std-term">1.x style</span></a> and <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> execution.  This is to distinguish
between the two querying styles and to attempt to forwards-document the new
calling style going forward.  In SQLAlchemy 2.0, while the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
object may remain as a legacy construct, it will no longer be featured in
most documentation.</p>
<p>Similar adjustments have been made to “bulk updates and deletes” such that
Core <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.update" title="sqlalchemy.sql.expression.update"><code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code></a> and <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.delete" title="sqlalchemy.sql.expression.delete"><code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code></a> can be used for bulk
operations.   A bulk update like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;sandy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="s2">&quot;foobar&quot;</span><span class="p">},</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="s2">&quot;fetch&quot;</span><span class="p">)</span></pre></div>
</div>
<p>can now be achieved in <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> (and indeed the above runs internally
in this way) as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">future</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">sess</span><span class="p">:</span>
    <span class="n">stmt</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;sandy&#39;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span>
        <span class="n">synchronize_session</span><span class="o">=</span><span class="s2">&quot;fetch&quot;</span>
    <span class="p">)</span>

    <span class="n">sess</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span></pre></div>
</div>
<p>Note the use of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options" title="sqlalchemy.sql.expression.Executable.execution_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Executable.execution_options()</span></code></a> method to pass
ORM-related options.  The use of “execution options” is now much more prevalent
within both Core and ORM, and many ORM-related methods from <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
are now implemented as execution options (see <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.execution_options" title="sqlalchemy.orm.Query.execution_options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.execution_options()</span></code></a>
for some examples).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html"><span class="std std-ref">Migrating to SQLAlchemy 2.0</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5159">#5159</a></p>
</section>
<section id="transparent-sql-compilation-caching-added-to-all-dql-dml-statements-in-core-orm">
<span id="change-4639"></span><h3>Transparent SQL Compilation Caching added to All DQL, DML Statements in Core, ORM<a class="headerlink" href="#transparent-sql-compilation-caching-added-to-all-dql-dml-statements-in-core-orm" title="Permalink to this headline">¶</a></h3>
<p>One of the most broadly encompassing changes to ever land in a single
SQLAlchemy version, a many-month reorganization and refactoring of all querying
systems from the base of Core all the way through ORM now allows the
majority of Python computation involved producing SQL strings and related
statement metadata from a user-constructed statement to be cached in memory,
such that subsequent invocations of an identical statement construct will use
35-60% fewer CPU resources.</p>
<p>This caching goes beyond the construction of the SQL string to also include the
construction of result fetching structures that link the SQL construct to the
result set, and in the ORM it includes the accommodation of ORM-enabled
attribute loaders, relationship eager loaders and other options, and object
construction routines that must be built up each time an ORM query seeks to run
and construct ORM objects from result sets.</p>
<p>To introduce the general idea of the feature, given code from the
<a class="reference internal" href="../orm/examples.html#examples-performance"><span class="std std-ref">Performance</span></a> suite as follows, which will invoke
a very simple query “n” times, for a default value of n=10000.   The
query returns only a single row, as the overhead we are looking to decrease
is that of <strong>many small queries</strong>.    The optimization is not as significant
for queries that return many rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Customer</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Customer</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id_</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span></pre></div>
</div>
<p>This example in the 1.3 release of SQLAlchemy on a Dell XPS13 running Linux
completes as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_orm_query</span> <span class="p">:</span> <span class="p">(</span><span class="mi">10000</span> <span class="n">iterations</span><span class="p">);</span> <span class="n">total</span> <span class="n">time</span> <span class="mf">3.440652</span> <span class="n">sec</span></pre></div>
</div>
<p>In 1.4, the code above without modification completes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_orm_query</span> <span class="p">:</span> <span class="p">(</span><span class="mi">10000</span> <span class="n">iterations</span><span class="p">);</span> <span class="n">total</span> <span class="n">time</span> <span class="mf">2.367934</span> <span class="n">sec</span></pre></div>
</div>
<p>This first test indicates that regular ORM queries when using caching can run
over many iterations in the range of <strong>30% faster</strong>.</p>
<p>A second variant of the feature is the optional use of Python lambdas to defer
the construction of the query itself.  This is a more sophisticated variant of
the approach used by the “Baked Query” extension, which was introduced in
version 1.0.0.     The “lambda” feature may be used in a style very similar to
that of baked queries, except that it is available in an ad-hoc way for any SQL
construct.  It additionally includes the ability to scan each invocation of the
lambda for bound literal values that change on every invocation, as well as
changes to other constructs, such as querying from a different entity or column
each time, while still not having to run the actual code each time.</p>
<p>Using this API looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">stmt</span> <span class="o">=</span> <span class="n">lambda_stmt</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">future_select</span><span class="p">(</span><span class="n">Customer</span><span class="p">))</span>
    <span class="n">stmt</span> <span class="o">+=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Customer</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">id_</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_one</span><span class="p">()</span></pre></div>
</div>
<p>The code above completes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_orm_query_newstyle_w_lambdas</span> <span class="p">:</span> <span class="p">(</span><span class="mi">10000</span> <span class="n">iterations</span><span class="p">);</span> <span class="n">total</span> <span class="n">time</span> <span class="mf">1.247092</span> <span class="n">sec</span></pre></div>
</div>
<p>This test indicates that using the newer “select()” style of ORM querying,
in conjunction with a full “baked” style invocation that caches the entire
construction, can run over many iterations in the range of <strong>60% faster</strong> and
grants performance about the same as the baked query system which is now superseded
by the native caching system.</p>
<p>The new system makes use of the existing
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.compiled_cache" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Connection.execution_options.compiled_cache</span></code></a> execution
option and also adds a cache to the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> directly, which is
configured using the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.params.query_cache_size" title="sqlalchemy.engine.Engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Engine.query_cache_size</span></code></a> parameter.</p>
<p>A significant portion of API and behavioral changes throughout 1.4 were
driven in order to support this new feature.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">SQL Compilation Caching</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4639">#4639</a>
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5380">#5380</a>
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4645">#4645</a>
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4808">#4808</a>
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5004">#5004</a></p>
</section>
<section id="declarative-is-now-integrated-into-the-orm-with-new-features">
<span id="change-5508"></span><h3>Declarative is now integrated into the ORM with new features<a class="headerlink" href="#declarative-is-now-integrated-into-the-orm-with-new-features" title="Permalink to this headline">¶</a></h3>
<p>After ten years or so of popularity, the <code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.declarative</span></code>
package is now integrated into the <code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm</span></code> namespace, with the
exception of the declarative “extension” classes which remain as Declarative
extensions.</p>
<p>The new classes added to <code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm</span></code> include:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code></a> - a new class that supersedes the role of the
“declarative base” class, serving as a registry of mapped classes which
can be referenced via string name within <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> calls
and is agnostic of the style in which any particular class was mapped.</p></li>
<li><p><a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declarative_base" title="sqlalchemy.orm.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a> - this is the same declarative base class that
has been in use throughout the span of the declarative system, except it now
references a <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code></a> object internally and is implemented
by the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.generate_base" title="sqlalchemy.orm.registry.generate_base"><code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.generate_base()</span></code></a> method which can be invoked
from a <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code></a> directly.   The <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declarative_base" title="sqlalchemy.orm.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a>
function creates this registry automatically so there is no impact on
existing code.    The <code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.declarative.declarative_base</span></code> name
is still present, emitting a 2.0 deprecation warning when
<a class="reference internal" href="#deprecation-20-mode"><span class="std std-ref">2.0 deprecations mode</span></a> is enabled.</p></li>
<li><p><a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declared_attr" title="sqlalchemy.orm.declared_attr"><code class="xref py py-func docutils literal notranslate"><span class="pre">declared_attr()</span></code></a> - the same “declared attr” function call now
part of <code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm</span></code>.  The <code class="docutils literal notranslate"><span class="pre">sqlalchemy.ext.declarative.declared_attr</span></code>
name is still present, emitting a 2.0 deprecation warning when
<a class="reference internal" href="#deprecation-20-mode"><span class="std std-ref">2.0 deprecations mode</span></a> is enabled.</p></li>
<li><p>Other names moved into <code class="docutils literal notranslate"><span class="pre">sqlalchemy.orm</span></code> include <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.has_inherited_table" title="sqlalchemy.orm.has_inherited_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_inherited_table()</span></code></a>,
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.synonym_for" title="sqlalchemy.orm.synonym_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">synonym_for()</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeMeta</span></code>, <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.as_declarative" title="sqlalchemy.orm.as_declarative"><code class="xref py py-func docutils literal notranslate"><span class="pre">as_declarative()</span></code></a>.</p></li>
</ul>
<p>In addition, The <code class="xref py py-func docutils literal notranslate"><span class="pre">instrument_declarative()</span></code> function is
deprecated, superseded by <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.map_declaratively" title="sqlalchemy.orm.registry.map_declaratively"><code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.map_declaratively()</span></code></a>.  The
<a class="reference internal" href="../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase" title="sqlalchemy.ext.declarative.ConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteBase</span></code></a>, <a class="reference internal" href="../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase" title="sqlalchemy.ext.declarative.AbstractConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractConcreteBase</span></code></a>,
and <a class="reference internal" href="../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection" title="sqlalchemy.ext.declarative.DeferredReflection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeferredReflection</span></code></a> classes remain as extensions in the
<a class="reference internal" href="../orm/extensions/declarative/index.html"><span class="std std-ref">Declarative Extensions</span></a> package.</p>
<p>Mapping styles have now been organized such that they all extend from
the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code></a> object, and fall into these categories:</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../orm/mapping_styles.html#orm-declarative-mapping"><span class="std std-ref">Declarative Mapping</span></a></dt><dd><ul>
<li><dl class="simple">
<dt>Using <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declarative_base" title="sqlalchemy.orm.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a> Base class w/ metaclass</dt><dd><ul>
<li><p><a class="reference internal" href="../orm/declarative_tables.html#orm-declarative-table"><span class="std std-ref">Declarative Table</span></a></p></li>
<li><p><a class="reference internal" href="../orm/declarative_tables.html#orm-imperative-table-configuration"><span class="std std-ref">Imperative Table (a.k.a. “hybrid table”)</span></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Using <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.mapped" title="sqlalchemy.orm.registry.mapped"><code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.mapped()</span></code></a> Declarative Decorator</dt><dd><ul>
<li><p>Declarative Table</p></li>
<li><dl class="simple">
<dt>Imperative Table (Hybrid)</dt><dd><ul>
<li><p><a class="reference internal" href="../orm/mapping_styles.html#orm-declarative-dataclasses"><span class="std std-ref">Declarative Mapping with Dataclasses and Attrs</span></a></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../orm/mapping_styles.html#classical-mapping"><span class="std std-ref">Imperative (a.k.a. “classical” mapping)</span></a></dt><dd><ul>
<li><dl class="simple">
<dt>Using <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively" title="sqlalchemy.orm.registry.map_imperatively"><code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.map_imperatively()</span></code></a></dt><dd><ul>
<li><p><a class="reference internal" href="../orm/mapping_styles.html#orm-imperative-dataclasses"><span class="std std-ref">Imperative Mapping with Dataclasses and Attrs</span></a></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>The existing classical mapping function <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapper()</span></code></a> remains, however
it is deprecated to call upon <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapper()</span></code></a> directly; the new
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively" title="sqlalchemy.orm.registry.map_imperatively"><code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.map_imperatively()</span></code></a> method now routes the request through
the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sqlalchemy.orm.registry()</span></code></a> so that it integrates with other declarative mappings
unambiguously.</p>
<p>The new approach interoperates with 3rd party class instrumentation systems
which necessarily must take place on the class before the mapping process
does, allowing declarative mapping to work via a decorator instead of a
declarative base so that packages like <a class="reference external" href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a> and <a class="reference external" href="https://pypi.org/project/attrs/">attrs</a> can be
used with declarative mappings, in addition to working with classical
mappings.</p>
<p>Declarative documentation has now been fully integrated into the ORM mapper
configuration documentation and includes examples for all styles of mappings
organized into one place. See the section
<a class="reference internal" href="../orm/mapping_styles.html"><span class="std std-ref">Mapping Python Classes</span></a> for the start of the newly reorganized
documentation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/mapping_styles.html"><span class="std std-ref">Mapping Python Classes</span></a></p>
<p><a class="reference internal" href="#change-5027"><span class="std std-ref">Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5508">#5508</a></p>
</section>
<section id="python-dataclasses-attrs-supported-w-declarative-imperative-mappings">
<span id="change-5027"></span><h3>Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings<a class="headerlink" href="#python-dataclasses-attrs-supported-w-declarative-imperative-mappings" title="Permalink to this headline">¶</a></h3>
<p>Along with the new declarative decorator styles introduced in <a class="reference internal" href="#change-5508"><span class="std std-ref">Declarative is now integrated into the ORM with new features</span></a>,
the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.Mapper" title="sqlalchemy.orm.Mapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code></a> is now explicitly aware of the Python <code class="docutils literal notranslate"><span class="pre">dataclasses</span></code>
module and will recognize attributes that are configured in this way, and
proceed to map them without skipping them as was the case previously.  In the
case of the <code class="docutils literal notranslate"><span class="pre">attrs</span></code> module, <code class="docutils literal notranslate"><span class="pre">attrs</span></code> already removes its own attributes
from the class so was already compatible with SQLAlchemy classical mappings.
With the addition of the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry.mapped" title="sqlalchemy.orm.registry.mapped"><code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.mapped()</span></code></a> decorator, both
attribute systems can now interoperate with Declarative mappings as well.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/mapping_styles.html#orm-declarative-dataclasses"><span class="std std-ref">Declarative Mapping with Dataclasses and Attrs</span></a></p>
<p><a class="reference internal" href="../orm/mapping_styles.html#orm-imperative-dataclasses"><span class="std std-ref">Imperative Mapping with Dataclasses and Attrs</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5027">#5027</a></p>
</section>
<section id="asynchronous-io-support-for-core-and-orm">
<span id="change-3414"></span><h3>Asynchronous IO Support for Core and ORM<a class="headerlink" href="#asynchronous-io-support-for-core-and-orm" title="Permalink to this headline">¶</a></h3>
<p>SQLAlchemy now supports Python <code class="docutils literal notranslate"><span class="pre">asyncio</span></code>-compatible database drivers using an
all-new asyncio front-end interface to <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> for Core
usage as well as <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> for ORM use, using the
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection" title="sqlalchemy.ext.asyncio.AsyncConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncConnection</span></code></a> and <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a> objects.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new asyncio feature should be considered <strong>alpha level</strong> for
the initial releases of SQLAlchemy 1.4.   This is super new stuff that uses
some previously unfamiliar programming techniques.</p>
</div>
<p>The initial database API supported is the <a class="reference internal" href="../dialects/postgresql.html#dialect-postgresql-asyncpg"><span class="std std-ref">asyncpg</span></a>
asyncio driver for PostgreSQL.</p>
<p>The internal features of SQLAlchemy are fully integrated by making use of
the <a class="reference external" href="https://greenlet.readthedocs.io/en/latest/">greenlet</a> library in order
to adapt the flow of execution within SQLAlchemy’s internals to propagate
asyncio <code class="docutils literal notranslate"><span class="pre">await</span></code> keywords outwards from the database driver to the end-user
API, which features <code class="docutils literal notranslate"><span class="pre">async</span></code> methods.  Using this approach, the asyncpg
driver is fully operational within SQLAlchemy’s own test suite and features
compatibility with most psycopg2 features.   The approach was vetted and
improved upon by developers of the greenlet project for which SQLAlchemy
is appreciative.</p>
<aside class="sidebar">
<p class="sidebar-title">greenlets are good</p>
<p>Don’t confuse the <a class="reference external" href="https://greenlet.readthedocs.io/en/latest/">greenlet</a> library with event-based IO libraries that build
on top of it such as <code class="docutils literal notranslate"><span class="pre">gevent</span></code> and <code class="docutils literal notranslate"><span class="pre">eventlet</span></code>; while the use of these
libraries with SQLAlchemy is common, SQLAlchemy’s asyncio integration
<strong>does not</strong> make use of these event based systems in any way. The asyncio
API integrates with the user-provided event loop, typically Python’s own
asyncio event loop, without the use of additional threads or event systems.
The approach involves a single greenlet context switch per <code class="docutils literal notranslate"><span class="pre">await</span></code> call,
and the extension which makes it possible is less than 20 lines of code.</p>
</aside>
<p>The user facing <code class="docutils literal notranslate"><span class="pre">async</span></code> API itself is focused around IO-oriented methods such
as <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.connect" title="sqlalchemy.ext.asyncio.AsyncEngine.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncEngine.connect()</span></code></a> and
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.execute" title="sqlalchemy.ext.asyncio.AsyncConnection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncConnection.execute()</span></code></a>.   The new Core constructs strictly
support <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> usage only; which means all statements must be
invoked given a connection object, in this case
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection" title="sqlalchemy.ext.asyncio.AsyncConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncConnection</span></code></a>.</p>
<p>Within the ORM, <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> query execution is
supported, using <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> constructs in conjunction with
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute" title="sqlalchemy.ext.asyncio.AsyncSession.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.execute()</span></code></a>; the legacy <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
object itself is not supported by the <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a> class.</p>
<p>ORM features such as lazy loading of related attributes as well as unexpiry of
expired attributes are by definition disallowed in the traditional asyncio
programming model, as they indicate IO operations that would run implicitly
within the scope of a Python <code class="docutils literal notranslate"><span class="pre">getattr()</span></code> operation.   To overcome this, the
<strong>traditional</strong> asyncio application should make judicious use of <a class="reference internal" href="../orm/loading_relationships.html"><span class="std std-ref">eager
loading</span></a> techniques as well as forego the use of features
such as <a class="reference internal" href="../orm/session_basics.html#session-committing"><span class="std std-ref">expire on commit</span></a> so that such loads are not
needed.</p>
<p>For the asyncio application developer who <strong>chooses to break</strong> with
tradition, the new API provides a <strong>strictly optional
feature</strong> such that applications that wish to make use of such ORM features
can opt to organize database-related code into functions which can then be
run within greenlets using the <a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.run_sync" title="sqlalchemy.ext.asyncio.AsyncSession.run_sync"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.run_sync()</span></code></a>
method. See the <code class="docutils literal notranslate"><span class="pre">greenlet_orm.py</span></code> example at <a class="reference internal" href="../orm/examples.html#examples-asyncio"><span class="std std-ref">Asyncio Integration</span></a>
for a demonstration.</p>
<p>Support for asynchronous cursors is also provided using new methods
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.stream" title="sqlalchemy.ext.asyncio.AsyncConnection.stream"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncConnection.stream()</span></code></a> and
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream" title="sqlalchemy.ext.asyncio.AsyncSession.stream"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncSession.stream()</span></code></a>, which support a new
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult" title="sqlalchemy.ext.asyncio.AsyncResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResult</span></code></a> object that itself provides awaitable
versions of common methods like
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.all" title="sqlalchemy.ext.asyncio.AsyncResult.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncResult.all()</span></code></a> and
<a class="reference internal" href="../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.fetchmany" title="sqlalchemy.ext.asyncio.AsyncResult.fetchmany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncResult.fetchmany()</span></code></a>.   Both Core and ORM are integrated
with the feature which corresponds to the use of “server side cursors”
in traditional SQLAlchemy.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/extensions/asyncio.html"><span class="std std-ref">Asynchronous I/O (asyncio)</span></a></p>
<p><a class="reference internal" href="../orm/examples.html#examples-asyncio"><span class="std std-ref">Asyncio Integration</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/3414">#3414</a></p>
</section>
<section id="many-core-and-orm-statement-objects-now-perform-much-of-their-construction-and-validation-in-the-compile-phase">
<span id="change-deferred-construction"></span><h3>Many Core and ORM statement objects now perform much of their construction and validation in the compile phase<a class="headerlink" href="#many-core-and-orm-statement-objects-now-perform-much-of-their-construction-and-validation-in-the-compile-phase" title="Permalink to this headline">¶</a></h3>
<p>A major initiative in the 1.4 series is to approach the model of both Core SQL
statements as well as the ORM Query to allow for an efficient, cacheable model
of statement creation and compilation, where the compilation step would be
cached, based on a cache key generated by the created statement object, which
itself is newly created for each use.  Towards this goal, much of the Python
computation which occurs within the construction of statements, particularly
that of the ORM <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> as well as the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>
construct when used to invoke ORM queries, is being moved to occur within
the compilation phase of the statement which only occurs after the statement
has been invoked, and only if the statement’s compiled form was not yet
cached.</p>
<p>From an end-user perspective, this means that some of the error messages which
can arise based on arguments passed to the object will no longer be raised
immediately, and instead will occur only when the statement is invoked for
the first time.    These conditions are always structural and not data driven,
so there is no risk of such a condition being missed due to a cached statement.</p>
<p>Error conditions which fall under this category include:</p>
<ul class="simple">
<li><p>when a <code class="xref py py-class docutils literal notranslate"><span class="pre">_selectable.CompoundSelect</span></code> is constructed (e.g. a UNION, EXCEPT, etc.)
and the SELECT statements passed do not have the same number of columns, a
<a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.CompileError" title="sqlalchemy.exc.CompileError"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompileError</span></code></a> is now raised to this effect; previously, an
<a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.ArgumentError" title="sqlalchemy.exc.ArgumentError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArgumentError</span></code></a> would be raised immediately upon statement
construction.</p></li>
<li><p>Various error conditions which may arise when calling upon <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>
will be evaluated at statement compilation time rather than when the method
is first called.</p></li>
</ul>
<p>Other things that may change involve the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object directly:</p>
<ul class="simple">
<li><p>Behaviors may be slightly different when calling upon the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.statement" title="sqlalchemy.orm.Query.statement"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Query.statement</span></code></a> accessor. The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object
returned is now a direct copy of the same state that was present in the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>, without any ORM-specific compilation being performed
(which means it’s dramatically faster). However, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>
will not have the same internal state as it had in 1.3, including things like
the FROM clauses being explicitly spelled out if they were not explicitly
stated in the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>. This means code that relies upon
manipulating this <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> statement such as calling methods like
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns" title="sqlalchemy.sql.expression.Select.with_only_columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.with_only_columns()</span></code></a> may need to accommodate for the FROM
clause.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#change-4639"><span class="std std-ref">Transparent SQL Compilation Caching added to All DQL, DML Statements in Core, ORM</span></a></p>
</div>
</section>
<section id="repaired-internal-importing-conventions-such-that-code-linters-may-work-correctly">
<span id="change-4656"></span><h3>Repaired internal importing conventions such that code linters may work correctly<a class="headerlink" href="#repaired-internal-importing-conventions-such-that-code-linters-may-work-correctly" title="Permalink to this headline">¶</a></h3>
<p>SQLAlchemy has for a long time used a parameter-injecting decorator to help resolve
mutually-dependent module imports, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@util</span><span class="o">.</span><span class="n">dependency_for</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.sql.dml&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dml</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span></pre></div>
</div>
<p>Where the above function would be rewritten to no longer have the <code class="docutils literal notranslate"><span class="pre">dml</span></code> parameter
on the outside.  This would confuse code-linting tools into seeing a missing parameter
to functions.  A new approach has been implemented internally such that the function’s
signature is no longer modified and the module object is procured inside the function
instead.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4656">#4656</a></p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4689">#4689</a></p>
</section>
<section id="support-for-sql-regular-expression-operators">
<span id="change-1390"></span><h3>Support for SQL Regular Expression operators<a class="headerlink" href="#support-for-sql-regular-expression-operators" title="Permalink to this headline">¶</a></h3>
<p>A long awaited feature to add rudimentary support for database regular
expression operators, to complement the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like" title="sqlalchemy.sql.expression.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a> and
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match" title="sqlalchemy.sql.expression.ColumnOperators.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.match()</span></code></a> suites of operations.   The new features
include <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match" title="sqlalchemy.sql.expression.ColumnOperators.regexp_match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.regexp_match()</span></code></a> implementing a regular
expression match like function, and <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace" title="sqlalchemy.sql.expression.ColumnOperators.regexp_replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.regexp_replace()</span></code></a>
implementing a regular expression string replace function.</p>
<p>Supported backends include SQLite, PostgreSQL, MySQL / MariaDB, and Oracle.
The SQLite backend only supports “regexp_match” but not “regexp_replace”.</p>
<p>The regular expression syntaxes and flags are <strong>not backend agnostic</strong>.
A future feature will allow multiple regular expression syntaxes to be
specified at once to switch between different backends on the fly.</p>
<p>For SQLite, Python’s <code class="docutils literal notranslate"><span class="pre">re.search()</span></code> function with no additional arguments
is established as the implementation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match" title="sqlalchemy.sql.expression.ColumnOperators.regexp_match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.regexp_match()</span></code></a></p>
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace" title="sqlalchemy.sql.expression.ColumnOperators.regexp_replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.regexp_replace()</span></code></a></p>
<p><a class="reference internal" href="../dialects/sqlite.html#pysqlite-regexp"><span class="std std-ref">Regular Expression Support</span></a> - SQLite implementation notes</p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1390">#1390</a></p>
</section>
<section id="sqlalchemy-2-0-deprecations-mode">
<span id="deprecation-20-mode"></span><h3>SQLAlchemy 2.0 Deprecations Mode<a class="headerlink" href="#sqlalchemy-2-0-deprecations-mode" title="Permalink to this headline">¶</a></h3>
<p>One of the primary goals of the 1.4 release is to provide a “transitional”
release so that applications may migrate to SQLAlchemy 2.0 gradually.   Towards
this end, a primary feature in release 1.4 is “2.0 deprecations mode”, which is
a series of deprecation warnings that emit against every detectable API pattern
which will work differently in version 2.0.   The warnings all make use of the
<a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.RemovedIn20Warning" title="sqlalchemy.exc.RemovedIn20Warning"><code class="xref py py-class docutils literal notranslate"><span class="pre">RemovedIn20Warning</span></code></a> class. As these warnings affect foundational
patterns including the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> and <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> constructs, even
simple applications can generate a lot of warnings until appropriate API
changes are made.   The warning mode is therefore turned off by default until
the developer enables the environment variable <code class="docutils literal notranslate"><span class="pre">SQLALCHEMY_WARN_20=1</span></code>.</p>
<p>For a full walkthrough of using 2.0 Deprecations mode, see <a class="reference internal" href="migration_20.html#migration-20-deprecations-mode"><span class="std std-ref">Migration to 2.0 Step Two - Turn on RemovedIn20Warnings</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html"><span class="std std-ref">Migrating to SQLAlchemy 2.0</span></a></p>
<p><a class="reference internal" href="migration_20.html#migration-20-deprecations-mode"><span class="std std-ref">Migration to 2.0 Step Two - Turn on RemovedIn20Warnings</span></a></p>
</div>
</section>
</section>
<section id="api-and-behavioral-changes-core">
<h2>API and Behavioral Changes - Core<a class="headerlink" href="#api-and-behavioral-changes-core" title="Permalink to this headline">¶</a></h2>
<section id="a-select-statement-is-no-longer-implicitly-considered-to-be-a-from-clause">
<span id="change-4617"></span><h3>A SELECT statement is no longer implicitly considered to be a FROM clause<a class="headerlink" href="#a-select-statement-is-no-longer-implicitly-considered-to-be-a-from-clause" title="Permalink to this headline">¶</a></h3>
<p>This change is one of the larger conceptual changes in SQLAlchemy in many years,
however it is hoped that the end user impact is relatively small, as the change
more closely matches what databases like MySQL and PostgreSQL require in any case.</p>
<p>The most immediate noticeable impact is that a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> can no longer
be embedded inside of another <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> directly, without explicitly
turning the inner <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> into a subquery first.  This is historically
performed by using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias" title="sqlalchemy.sql.expression.SelectBase.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.alias()</span></code></a> method, which remains, however
is more explicitly suited by using a new method <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a>;
both methods do the same thing.   The object returned is now <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a>,
which is very similar to the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> object and shares a common
base <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.AliasedReturnsRows" title="sqlalchemy.sql.expression.AliasedReturnsRows"><code class="xref py py-class docutils literal notranslate"><span class="pre">AliasedReturnsRows</span></code></a>.</p>
<p>That is, this will now raise:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="n">stmt2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="n">stmt1</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stmt1</span><span class="p">))</span></pre></div>
</div>
<p>Raising:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sqlalchemy.exc.ArgumentError: Column expression or FROM clause expected,
got &lt;...Select object ...&gt;. To create a FROM clause from a &lt;class
&#39;sqlalchemy.sql.selectable.Select&#39;&gt; object, use the .subquery() method.</pre></div>
</div>
<p>The correct calling form is instead (noting also that <a class="reference internal" href="#change-5284"><span class="std std-ref">brackets are no
longer required for select()</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sq1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="n">stmt2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="n">sq1</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sq1</span><span class="p">))</span></pre></div>
</div>
<p>Noting above that the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a> method is essentially
equivalent to using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias" title="sqlalchemy.sql.expression.SelectBase.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.alias()</span></code></a> method.</p>
<p>The rationale for this change is based on the following:</p>
<ul>
<li><p>In order to support the unification of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> with
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object needs to have
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin" title="sqlalchemy.sql.expression.Select.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.outerjoin()</span></code></a> methods that
actually add JOIN criteria to the existing FROM clause, as is what users have
always expected it to do in any case.    The previous behavior, having to
align with what a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> would do, was that it would generate
an unnamed subquery and then JOIN to it, which was a completely useless
feature that only confused those users unfortunate enough to try this.  This
change is discussed at <a class="reference internal" href="#change-select-join"><span class="std std-ref">select().join() and outerjoin() add JOIN criteria to the current query, rather than creating a subquery</span></a>.</p></li>
<li><p>The behavior of including a SELECT in the FROM clause of another SELECT
without first creating an alias or subquery would be that it creates an
unnamed subquery.   While standard SQL does support this syntax, in practice
it is rejected by most databases.  For example, both the MySQL and PostgreSQL
outright reject the usage of unnamed subqueries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># MySQL / MariaDB:</span>

<span class="n">MariaDB</span> <span class="p">[(</span><span class="n">none</span><span class="p">)]</span><span class="o">&gt;</span> <span class="n">select</span> <span class="o">*</span> <span class="kn">from</span> <span class="p">(</span><span class="n">select</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">ERROR</span> <span class="mi">1248</span> <span class="p">(</span><span class="mi">42000</span><span class="p">):</span> <span class="n">Every</span> <span class="n">derived</span> <span class="n">table</span> <span class="n">must</span> <span class="n">have</span> <span class="n">its</span> <span class="n">own</span> <span class="n">alias</span>


<span class="c1"># PostgreSQL:</span>

<span class="n">test</span><span class="o">=&gt;</span> <span class="n">select</span> <span class="o">*</span> <span class="kn">from</span> <span class="p">(</span><span class="n">select</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">ERROR</span><span class="p">:</span>  <span class="n">subquery</span> <span class="ow">in</span> <span class="n">FROM</span> <span class="n">must</span> <span class="n">have</span> <span class="n">an</span> <span class="n">alias</span>
<span class="n">LINE</span> <span class="mi">1</span><span class="p">:</span> <span class="n">select</span> <span class="o">*</span> <span class="kn">from</span> <span class="p">(</span><span class="n">select</span> <span class="mi">1</span><span class="p">);</span>
                      <span class="o">^</span>
<span class="n">HINT</span><span class="p">:</span>  <span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="n">FROM</span> <span class="p">(</span><span class="n">SELECT</span> <span class="o">...</span><span class="p">)</span> <span class="p">[</span><span class="n">AS</span><span class="p">]</span> <span class="n">foo</span><span class="o">.</span></pre></div>
</div>
<p>A database like SQLite accepts them, however it is still often the case that
the names produced from such a subquery are too ambiguous to be useful:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite</span><span class="o">&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">a</span><span class="p">(</span><span class="nb">id</span> <span class="n">integer</span><span class="p">);</span>
<span class="n">sqlite</span><span class="o">&gt;</span> <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">b</span><span class="p">(</span><span class="nb">id</span> <span class="n">integer</span><span class="p">);</span>
<span class="n">sqlite</span><span class="o">&gt;</span> <span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">a</span> <span class="n">JOIN</span> <span class="p">(</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">b</span><span class="p">)</span> <span class="n">ON</span> <span class="n">a</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="nb">id</span><span class="p">;</span>
<span class="n">Error</span><span class="p">:</span> <span class="n">ambiguous</span> <span class="n">column</span> <span class="n">name</span><span class="p">:</span> <span class="nb">id</span>
<span class="n">sqlite</span><span class="o">&gt;</span> <span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">a</span> <span class="n">JOIN</span> <span class="p">(</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">b</span><span class="p">)</span> <span class="n">ON</span> <span class="n">a</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">id</span><span class="p">;</span>
<span class="n">Error</span><span class="p">:</span> <span class="n">no</span> <span class="n">such</span> <span class="n">column</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">id</span>

<span class="c1"># use a name</span>
<span class="n">sqlite</span><span class="o">&gt;</span> <span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">a</span> <span class="n">JOIN</span> <span class="p">(</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">b</span><span class="p">)</span> <span class="n">AS</span> <span class="n">anon_1</span> <span class="n">ON</span> <span class="n">a</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">anon_1</span><span class="o">.</span><span class="n">id</span><span class="p">;</span></pre></div>
</div>
</li>
</ul>
<p>As <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase" title="sqlalchemy.sql.expression.SelectBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectBase</span></code></a> objects are no longer
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> objects, attributes like the <code class="docutils literal notranslate"><span class="pre">.c</span></code> attribute
as well as methods like <code class="docutils literal notranslate"><span class="pre">.select()</span></code> is now deprecated, as they imply implicit
production of a subquery. The <code class="docutils literal notranslate"><span class="pre">.join()</span></code> and <code class="docutils literal notranslate"><span class="pre">.outerjoin()</span></code> methods are now
<a class="reference internal" href="#change-select-join"><span class="std std-ref">repurposed to append JOIN criteria to the existing query</span></a> in a similar
way as that of <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>, which is what users have always
expected these methods to do in any case.</p>
<p>In place of the <code class="docutils literal notranslate"><span class="pre">.c</span></code> attribute, a new attribute <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns" title="sqlalchemy.sql.expression.SelectBase.selected_columns"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SelectBase.selected_columns</span></code></a>
is added.  This attribute resolves to a column collection that is what most
people hope that <code class="docutils literal notranslate"><span class="pre">.c</span></code> does (but does not), which is to reference the columns
that are in the columns clause of the SELECT statement.   A common beginner mistake
is code such as the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span></pre></div>
</div>
<p>The above code appears intuitive and that it would generate
“SELECT * FROM users WHERE name=’foo’”, however veteran SQLAlchemy users will
recognize that it in fact generates a useless subquery resembling
“SELECT * FROM (SELECT * FROM users) WHERE name=’foo’”.</p>
<p>The new <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns" title="sqlalchemy.sql.expression.SelectBase.selected_columns"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SelectBase.selected_columns</span></code></a> attribute however <strong>does</strong> suit
the use case above, as in a case like the above it links directly to the columns
present in the <code class="docutils literal notranslate"><span class="pre">users.c</span></code> collection:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">selected_columns</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span></pre></div>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4617">#4617</a></p>
</section>
<section id="select-join-and-outerjoin-add-join-criteria-to-the-current-query-rather-than-creating-a-subquery">
<span id="change-select-join"></span><h3>select().join() and outerjoin() add JOIN criteria to the current query, rather than creating a subquery<a class="headerlink" href="#select-join-and-outerjoin-add-join-criteria-to-the-current-query-rather-than-creating-a-subquery" title="Permalink to this headline">¶</a></h3>
<p>Towards the goal of unifying <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>,
particularly for <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> use of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>, it was critical
that there be a working <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> method that behaves like the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> method, adding additional entries to the FROM clause of
the existing SELECT and then returning the new <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object for
further modification, instead of wrapping the object inside of an unnamed
subquery and returning a JOIN from that subquery, a behavior that has always
been virtually useless and completely misleading to users.</p>
<p>To allow this to be the case, <a class="reference internal" href="#change-4617"><span class="std std-ref">A SELECT statement is no longer implicitly considered to be a FROM clause</span></a> was first implemented which
splits off <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> from having to be a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a>;
this removed the requirement that <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> would need to
return a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Join" title="sqlalchemy.sql.expression.Join"><code class="xref py py-class docutils literal notranslate"><span class="pre">Join</span></code></a> object rather than a new version of that
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object that includes a new JOIN in its FROM clause.</p>
<p>From that point on, as the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin" title="sqlalchemy.sql.expression.Select.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.outerjoin()</span></code></a>
did have an existing behavior, the original plan was that these
methods would be deprecated, and the new “useful” version of
the methods would be available on an alternate, “future” <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>
object available as a separate import.</p>
<p>However, after some time working with this particular codebase, it was decided
that having two different kinds of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> objects floating
around, each with 95% the same behavior except for some subtle difference
in how some of the methods behave was going to be more misleading and inconvenient
than simply making a hard change in how these two methods behave, given
that the existing behavior of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin" title="sqlalchemy.sql.expression.Select.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.outerjoin()</span></code></a>
is essentially never used and only causes confusion.</p>
<p>So it was decided, given how very useless the current behavior is, and how
extremely useful and important and useful the new behavior would be, to make a
<strong>hard behavioral change</strong> in this one area, rather than waiting another year
and having a more awkward API in the interim.   SQLAlchemy developers do not
take it lightly to make a completely breaking change like this, however this is
a very special case and it is extremely unlikely that the previous
implementation of these methods was being used;  as noted in
<a class="reference internal" href="#change-4617"><span class="std std-ref">A SELECT statement is no longer implicitly considered to be a FROM clause</span></a>, major databases such as MySQL and PostgreSQL don’t allow
for unnamed subqueries in any case and from a syntactical point of view it’s
nearly impossible for a JOIN from an unnamed subquery to be useful since it’s
very difficult to refer to the columns within it unambiguously.</p>
<p>With the new implementation, <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin" title="sqlalchemy.sql.expression.Select.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.outerjoin()</span></code></a> now behave very similarly to that of
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>, adding JOIN criteria to the existing statement by
matching to the left entity:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses_table</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span></pre></div>
</div>
<p>producing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="n">FROM</span> <span class="n">user</span> <span class="n">JOIN</span> <span class="n">address</span> <span class="n">ON</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">address</span><span class="o">.</span><span class="n">user_id</span></pre></div>
</div>
<p>As is the case for <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Join" title="sqlalchemy.sql.expression.Join"><code class="xref py py-class docutils literal notranslate"><span class="pre">Join</span></code></a>, the ON clause is automatically determined
if feasible:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses_table</span><span class="p">)</span></pre></div>
</div>
<p>When ORM entities are used in the statement, this is essentially how ORM
queries are built up using <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> invocation.  ORM entities will
assign a “plugin” to the statement internally such that ORM-related compilation
rules will take place when the statement is compiled into a SQL string. More
directly, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> method can accommodate ORM
relationships, without breaking the hard separation between Core and ORM
internals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span></pre></div>
</div>
<p>Another new method <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> is also added, which
allows easier specification of the left and right side of a join at once:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span></pre></div>
</div>
<p>producing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">address</span><span class="o">.</span><span class="n">email_address</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="n">FROM</span> <span class="n">user</span> <span class="n">JOIN</span> <span class="n">address</span> <span class="n">ON</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">address</span><span class="o">.</span><span class="n">user_id</span></pre></div>
</div>
</section>
<section id="the-url-object-is-now-immutable">
<span id="change-5526"></span><h3>The URL object is now immutable<a class="headerlink" href="#the-url-object-is-now-immutable" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> object has been formalized such that it now presents
itself as a <code class="docutils literal notranslate"><span class="pre">namedtuple</span></code> with a fixed number of fields that are immutable. In
addition, the dictionary represented by the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.query" title="sqlalchemy.engine.URL.query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">URL.query</span></code></a> attribute
is also an immutable mapping.   Mutation of the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> object was
not a formally supported or documented use case which led to some open-ended
use cases that made it very difficult to intercept incorrect usages, most
commonly mutation of the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.query" title="sqlalchemy.engine.URL.query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">URL.query</span></code></a> dictionary to include non-string elements.
It also led to all the common problems of allowing mutability in a fundamental
data object, namely unwanted mutations elsewhere leaking into code that didn’t
expect the URL to change.  Finally, the namedtuple design is inspired by that
of Python’s <code class="docutils literal notranslate"><span class="pre">urllib.parse.urlparse()</span></code> which returns the parsed object as a
named tuple.</p>
<p>The decision to change the API outright is based on a calculus weighing the
infeasibility of a deprecation path (which would involve changing the
<a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.query" title="sqlalchemy.engine.URL.query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">URL.query</span></code></a> dictionary to be a special dictionary that emits deprecation
warnings when any kind of standard library mutation methods are invoked, in
addition that when the dictionary would hold any kind of list of elements, the
list would also have to emit deprecation warnings on mutation) against the
unlikely use case of projects already mutating <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> objects in
the first place, as well as that small changes such as that of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5341">#5341</a>
were creating backwards-incompatibility in any case.   The primary case for
mutation of a
<a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> object is that of parsing plugin arguments within the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CreateEnginePlugin" title="sqlalchemy.engine.CreateEnginePlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateEnginePlugin</span></code></a> extension point, itself a fairly recent
addition that based on Github code search is in use by two repositories,
neither of which are actually mutating the URL object.</p>
<p>The <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> object now provides a rich interface inspecting
and generating new <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> objects.  The
existing mechanism to create a <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> object, the
<a class="reference internal" href="../core/engines.html#sqlalchemy.engine.make_url" title="sqlalchemy.engine.make_url"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_url()</span></code></a> function, remains unchanged:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.engine</span> <span class="kn">import</span> <span class="n">make_url</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="n">make_url</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://user:pass@host/dbname&quot;</span><span class="p">)</span></pre></div>
</div>
<p>For programmatic construction, code that may have been using the
<a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> constructor or <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method directly will
receive a deprecation warning if arguments are passed as keyword arguments
and not an exact 7-tuple.  The keyword-style constructor is now available
via the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.create" title="sqlalchemy.engine.URL.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">URL.create()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.engine</span> <span class="kn">import</span> <span class="n">URL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="n">URL</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="s2">&quot;postgresql&quot;</span><span class="p">,</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s2">&quot;host&quot;</span><span class="p">,</span> <span class="n">database</span><span class="o">=</span><span class="s2">&quot;dbname&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="go">&#39;postgresql://user:pass@host/dbname&#39;</span></pre></div>
</div>
<p>Fields can be altered typically using the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.set" title="sqlalchemy.engine.URL.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">URL.set()</span></code></a> method, which
returns a new <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> object with changes applied:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mysql_url</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">drivername</span><span class="o">=</span><span class="s2">&quot;mysql+pymysql&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">mysql_url</span><span class="p">)</span>
<span class="go">&#39;mysql+pymysql://user:pass@host/dbname&#39;</span></pre></div>
</div>
<p>To alter the contents of the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.query" title="sqlalchemy.engine.URL.query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">URL.query</span></code></a> dictionary, methods
such as <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.update_query_dict" title="sqlalchemy.engine.URL.update_query_dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">URL.update_query_dict()</span></code></a> may be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">url</span><span class="o">.</span><span class="n">update_query_dict</span><span class="p">({</span><span class="s2">&quot;sslcert&quot;</span><span class="p">:</span> <span class="s1">&#39;/path/to/crt&#39;</span><span class="p">})</span>
<span class="go">postgresql://user:***@host/dbname?sslcert=%2Fpath%2Fto%2Fcrt</span></pre></div>
</div>
<p>To upgrade code that is mutating these fields directly, a <strong>backwards and
forwards compatible approach</strong> is to use a duck-typing, as in the following
style:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_url_drivername</span><span class="p">(</span><span class="n">some_url</span><span class="p">,</span> <span class="n">some_drivername</span><span class="p">):</span>
    <span class="c1"># check for 1.4</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">some_url</span><span class="p">,</span> <span class="s2">&quot;set&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">some_url</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">drivername</span><span class="o">=</span><span class="n">some_drivername</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># SQLAlchemy 1.3 or earlier, mutate in place</span>
        <span class="n">some_url</span><span class="o">.</span><span class="n">drivername</span> <span class="o">=</span> <span class="n">some_drivername</span>
        <span class="k">return</span> <span class="n">some_url</span>

<span class="k">def</span> <span class="nf">set_ssl_cert</span><span class="p">(</span><span class="n">some_url</span><span class="p">,</span> <span class="n">ssl_cert</span><span class="p">):</span>
    <span class="c1"># check for 1.4</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">some_url</span><span class="p">,</span> <span class="s2">&quot;update_query_dict&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">some_url</span><span class="o">.</span><span class="n">update_query_dict</span><span class="p">({</span><span class="s2">&quot;sslcert&quot;</span><span class="p">:</span> <span class="n">ssl_cert</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># SQLAlchemy 1.3 or earlier, mutate in place</span>
        <span class="n">some_url</span><span class="o">.</span><span class="n">query</span><span class="p">[</span><span class="s2">&quot;sslcert&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssl_cert</span>
        <span class="k">return</span> <span class="n">some_url</span></pre></div>
</div>
<p>The query string retains its existing format as a dictionary of strings
to strings, using sequences of strings to represent multiple parameters.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.engine</span> <span class="kn">import</span> <span class="n">make_url</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="n">make_url</span><span class="p">(</span><span class="s2">&quot;postgresql://user:pass@host/dbname?alt_host=host1&amp;alt_host=host2&amp;sslcert=</span><span class="si">%2F</span><span class="s2">path</span><span class="si">%2F</span><span class="s2">to</span><span class="si">%2F</span><span class="s2">crt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span><span class="o">.</span><span class="n">query</span>
<span class="go">immutabledict({&#39;alt_host&#39;: (&#39;host1&#39;, &#39;host2&#39;), &#39;sslcert&#39;: &#39;/path/to/crt&#39;})</span></pre></div>
</div>
<p>To work with the contents of the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.query" title="sqlalchemy.engine.URL.query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">URL.query</span></code></a> attribute such that all values are
normalized into sequences, use the <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.normalized_query" title="sqlalchemy.engine.URL.normalized_query"><code class="xref py py-attr docutils literal notranslate"><span class="pre">URL.normalized_query</span></code></a> attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">url</span><span class="o">.</span><span class="n">normalized_query</span>
<span class="go">immutabledict({&#39;alt_host&#39;: (&#39;host1&#39;, &#39;host2&#39;), &#39;sslcert&#39;: (&#39;/path/to/crt&#39;,)})</span></pre></div>
</div>
<p>The query string can be appended to via methods such as <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.update_query_dict" title="sqlalchemy.engine.URL.update_query_dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">URL.update_query_dict()</span></code></a>,
<a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.update_query_pairs" title="sqlalchemy.engine.URL.update_query_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">URL.update_query_pairs()</span></code></a>, <a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL.update_query_string" title="sqlalchemy.engine.URL.update_query_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">URL.update_query_string()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">url</span><span class="o">.</span><span class="n">update_query_dict</span><span class="p">({</span><span class="s2">&quot;alt_host&quot;</span><span class="p">:</span> <span class="s2">&quot;host3&quot;</span><span class="p">},</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">postgresql://user:***@host/dbname?alt_host=host1&amp;alt_host=host2&amp;alt_host=host3&amp;sslcert=%2Fpath%2Fto%2Fcrt</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/engines.html#sqlalchemy.engine.URL" title="sqlalchemy.engine.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a></p>
</div>
<section id="changes-to-createengineplugin">
<h4>Changes to CreateEnginePlugin<a class="headerlink" href="#changes-to-createengineplugin" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CreateEnginePlugin" title="sqlalchemy.engine.CreateEnginePlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateEnginePlugin</span></code></a> is also impacted by this change,
as the documentation for custom plugins indicated that the <code class="docutils literal notranslate"><span class="pre">dict.pop()</span></code>
method should be used to remove consumed arguments from the URL object.  This
should now be achieved using the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url" title="sqlalchemy.engine.CreateEnginePlugin.update_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CreateEnginePlugin.update_url()</span></code></a>
method.  A backwards compatible approach would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.engine</span> <span class="kn">import</span> <span class="n">CreateEnginePlugin</span>

<span class="k">class</span> <span class="nc">MyPlugin</span><span class="p">(</span><span class="n">CreateEnginePlugin</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># check for 1.4 style</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">CreateEnginePlugin</span><span class="p">,</span> <span class="s2">&quot;update_url&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_argument_one</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">query</span><span class="p">[</span><span class="s1">&#39;my_argument_one&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_argument_two</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">query</span><span class="p">[</span><span class="s1">&#39;my_argument_two&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># legacy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_argument_one</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;my_argument_one&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_argument_two</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;my_argument_two&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">my_argument_three</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;my_argument_three&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="c1"># this method runs in 1.4 only and should be used to consume</span>
        <span class="c1"># plugin-specific arguments</span>
        <span class="k">return</span> <span class="n">url</span><span class="o">.</span><span class="n">difference_update_query</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;my_argument_one&quot;</span><span class="p">,</span> <span class="s2">&quot;my_argument_two&quot;</span><span class="p">]</span>
        <span class="p">)</span></pre></div>
</div>
<p>See the docstring at <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CreateEnginePlugin" title="sqlalchemy.engine.CreateEnginePlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateEnginePlugin</span></code></a> for complete details
on how this class is used.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5526">#5526</a></p>
</section>
</section>
<section id="select-case-now-accept-positional-expressions">
<span id="change-5284"></span><h3>select(), case() now accept positional expressions<a class="headerlink" href="#select-case-now-accept-positional-expressions" title="Permalink to this headline">¶</a></h3>
<p>As it may be seen elsewhere in this document, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct will
now accept “columns clause” arguments positionally, rather than requiring they
be passed as a list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># new way, supports 2.0</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col1</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span></pre></div>
</div>
<p>When sending the arguments positionally, no other keyword arguments are permitted.
In SQLAlchemy 2.0, the above calling style will be the only calling style
supported.</p>
<p>For the duration of 1.4, the previous calling style will still continue
to function, which passes the list of columns or other expressions as a list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># old way, still works in 1.4</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col1</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col2</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span></pre></div>
</div>
<p>The above legacy calling style also accepts the old keyword arguments that have
since been removed from most narrative documentation.  The existence of these
keyword arguments is why the columns clause was passed as a list in the first place:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># very much the old way, but still works in 1.4</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col1</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col2</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">whereclause</span><span class="o">=</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col1</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span></pre></div>
</div>
<p>The detection between the two styles is based on whether or not the first
positional argument is a list.   There are unfortunately still likely some
usages that look like the following, where the keyword for the “whereclause”
is omitted:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># very much the old way, but still works in 1.4</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col1</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col2</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">col1</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span></pre></div>
</div>
<p>As part of this change, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> construct also gains the 2.0-style
“future” API which includes an updated <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> method as well
as methods like <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by" title="sqlalchemy.sql.expression.Select.filter_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.filter_by()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a>.</p>
<p>In a related change, the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.case" title="sqlalchemy.sql.expression.case"><code class="xref py py-func docutils literal notranslate"><span class="pre">case()</span></code></a> construct has also been modified
to accept its list of WHEN clauses positionally, with a similar deprecation
track for the old calling style:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">users_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
    <span class="n">case</span><span class="p">(</span>
        <span class="p">(</span><span class="n">users_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="n">users_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">),</span>
        <span class="n">else_</span><span class="o">=</span><span class="s1">&#39;E&#39;</span>
    <span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>The convention for SQLAlchemy constructs accepting <code class="docutils literal notranslate"><span class="pre">*args</span></code> vs. a list of
values, as is the latter case for a construct like
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_" title="sqlalchemy.sql.expression.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.in_()</span></code></a>, is that <strong>positional arguments are used for
structural specification, lists are used for data specification</strong>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html#migration-20-5284"><span class="std std-ref">select() no longer accepts varied constructor arguments, columns are passed positionally</span></a></p>
<p><a class="reference internal" href="../errors.html#error-c9ae"><span class="std std-ref">select() construct created in “legacy” mode; keyword arguments, etc.</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5284">#5284</a></p>
</section>
<section id="all-in-expressions-render-parameters-for-each-value-in-the-list-on-the-fly-e-g-expanding-parameters">
<span id="change-4645"></span><h3>All IN expressions render parameters for each value in the list on the fly (e.g. expanding parameters)<a class="headerlink" href="#all-in-expressions-render-parameters-for-each-value-in-the-list-on-the-fly-e-g-expanding-parameters" title="Permalink to this headline">¶</a></h3>
<p>The “expanding IN” feature, first introduced in <a class="reference internal" href="migration_12.html#change-3953"><span class="std std-ref">Late-expanded IN parameter sets allow IN expressions with cached statements</span></a>, has matured
enough such that it is clearly superior to the previous method of rendering IN
expressions.  As the approach was improved to handle empty lists of values, it
is now the only means that Core / ORM will use to render lists of IN
parameters.</p>
<p>The previous approach which has been present in SQLAlchemy since its first
release was that when a list of values were passed to the
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_" title="sqlalchemy.sql.expression.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.in_()</span></code></a> method, the list would be expanded into a series
of individual <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BindParameter</span></code></a> objects at statement construction time.
This suffered from the limitation that it was not possible to vary the
parameter list at statement execution time based on the parameter dictionary,
which meant that string SQL statements could not be cached independently of
their parameters, nor could the parameter dictionary be fully used for
statements that included IN expressions generally.</p>
<p>In order to service the “baked query” feature described at
<a class="reference internal" href="../orm/extensions/baked.html"><span class="std std-ref">Baked Queries</span></a>, a cacheable version of IN was needed, which is what
brought about the “expanding IN” feature.  In contrast to the existing behavior
whereby the parameter list is expanded at statement construction time into
individual <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BindParameter</span></code></a> objects, the feature instead uses a single
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BindParameter</span></code></a> that stores the list of values at once; when the
statement is executed by the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>, it is “expanded” on the fly into
individual bound parameter positions based on the parameters passed to the call
to <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a>, and the existing SQL string which may have been
retrieved from a previous execution is modified using a regular expression to
suit the current parameter set.   This allows for the same <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Compiled" title="sqlalchemy.engine.Compiled"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compiled</span></code></a>
object, which stores the rendered string statement, to be invoked multiple
times against different parameter sets that modify the list contents passed to
IN expressions, while still maintaining the behavior of individual scalar
parameters being passed to the DBAPI.  While some DBAPIs do support this
functionality directly, it is not generally available; the “expanding IN”
feature now supports the behavior consistently for all backends.</p>
<p>As a major focus of 1.4 is to allow for true statement caching in Core and ORM
without the awkwardness of the “baked” system, and since the “expanding IN”
feature represents a simpler approach to building expressions in any case,
it’s now invoked automatically whenever a list of values is passed to
an IN expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span></pre></div>
</div>
<p>The pre-execution string representation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="go">SELECT a.id, a.data</span>
<span class="go">FROM a</span>
<span class="go">WHERE a.id IN ([POSTCOMPILE_id_1])</span></pre></div>
</div>
<p>To render the values directly, use <code class="docutils literal notranslate"><span class="pre">literal_binds</span></code> as was the case previously:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;literal_binds&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}))</span>
<span class="go">SELECT a.id, a.data</span>
<span class="go">FROM a</span>
<span class="go">WHERE a.id IN (1, 2, 3)</span></pre></div>
</div>
<p>A new flag, “render_postcompile”, is added as a helper to allow the current
bound value to be rendered as it would be passed to the database:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;render_postcompile&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}))</span>
<span class="go">SELECT a.id, a.data</span>
<span class="go">FROM a</span>
<span class="go">WHERE a.id IN (:id_1_1, :id_1_2, :id_1_3)</span></pre></div>
</div>
<p>Engine logging output shows the ultimate rendered statement as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>INFO sqlalchemy.engine.base.Engine SELECT a.id, a.data
FROM a
WHERE a.id IN (?, ?, ?)
INFO sqlalchemy.engine.base.Engine (1, 2, 3)</pre></div>
</div>
<p>As part of this change, the behavior of “empty IN” expressions, where the list
parameter is empty, is now standardized on use of the IN operator against a
so-called “empty set”.  As there is no standard SQL syntax for empty sets, a
SELECT that returns no rows is used, tailored in specific ways for each backend
so that the database treats it as an empty set; this feature was first
introduced in version 1.3 and is described at <a class="reference internal" href="migration_13.html#change-4271"><span class="std std-ref">Expanding IN feature now supports empty lists</span></a>.  The
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.empty_in_strategy</span></code></a> parameter, introduced in version
1.2 as a means for migrating for how this case was treated for the previous IN
system, is now deprecated and this flag no longer has an effect; as described
in <a class="reference internal" href="migration_12.html#change-3907"><span class="std std-ref">The IN / NOT IN operator’s empty collection behavior is now configurable; default expression simplified</span></a>, this flag allowed a dialect to switch between the
original system of comparing a column against itself, which turned out to be a
huge performance issue, and a newer system of comparing “1 != 1” in
order to produce a “false” expression. The 1.3 introduced behavior which
now takes place in all cases is more correct than both approaches as the IN
operator is still used, and does not have the performance issue of the original
system.</p>
<p>In addition, the “expanding” parameter system has been generalized so that it
also services other dialect-specific use cases where a parameter cannot be
accommodated by the DBAPI or backing database; see <a class="reference internal" href="#change-4808"><span class="std std-ref">New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server</span></a> for
details.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#change-4808"><span class="std std-ref">New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server</span></a></p>
<p><a class="reference internal" href="migration_13.html#change-4271"><span class="std std-ref">Expanding IN feature now supports empty lists</span></a></p>
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BindParameter</span></code></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4645">#4645</a></p>
</section>
<section id="built-in-from-linting-will-warn-for-any-potential-cartesian-products-in-a-select-statement">
<span id="change-4737"></span><h3>Built-in FROM linting will warn for any potential cartesian products in a SELECT statement<a class="headerlink" href="#built-in-from-linting-will-warn-for-any-potential-cartesian-products-in-a-select-statement" title="Permalink to this headline">¶</a></h3>
<p>As the Core expression language as well as the ORM are built on an “implicit
FROMs” model where a particular FROM clause is automatically added if any part
of the query refers to it, a common issue is the case where a SELECT statement,
either a top level statement or an embedded subquery, contains FROM elements
that are not joined to the rest of the FROM elements in the query, causing
what’s referred to as a “cartesian product” in the result set, i.e. every
possible combination of rows from each FROM element not otherwise joined.  In
relational databases, this is nearly always an undesirable outcome as it
produces an enormous result set full of duplicated, uncorrelated data.</p>
<p>SQLAlchemy, for all of its great features, is particularly prone to this sort
of issue happening as a SELECT statement will have elements added to its FROM
clause automatically from any table seen in the other clauses. A typical
scenario looks like the following, where two tables are JOINed together,
however an additional entry in the WHERE clause that perhaps inadvertently does
not line up with these two tables will create an additional FROM entry:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">address_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">address_alias</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span></pre></div>
</div>
<p>The above query selects from a JOIN of <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">address_alias</span></code>, the
latter of which is an alias of the <code class="docutils literal notranslate"><span class="pre">Address</span></code> entity.  However, the
<code class="docutils literal notranslate"><span class="pre">Address</span></code> entity is used within the WHERE clause directly, so the above would
result in the SQL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span>
    <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="n">users_id</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">name</span> <span class="n">AS</span> <span class="n">users_name</span><span class="p">,</span>
    <span class="n">users</span><span class="o">.</span><span class="n">fullname</span> <span class="n">AS</span> <span class="n">users_fullname</span><span class="p">,</span>
    <span class="n">users</span><span class="o">.</span><span class="n">nickname</span> <span class="n">AS</span> <span class="n">users_nickname</span>
<span class="n">FROM</span> <span class="n">addresses</span><span class="p">,</span> <span class="n">users</span> <span class="n">JOIN</span> <span class="n">addresses</span> <span class="n">AS</span> <span class="n">addresses_1</span> <span class="n">ON</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">addresses_1</span><span class="o">.</span><span class="n">user_id</span>
<span class="n">WHERE</span> <span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span> <span class="o">=</span> <span class="p">:</span><span class="n">email_address_1</span></pre></div>
</div>
<p>In the above SQL, we can see what SQLAlchemy developers term “the dreaded
comma”, as we see “FROM addresses, users JOIN addresses” in the FROM clause
which is the classic sign of a cartesian product; where a query is making use
of JOIN in order to join FROM clauses together, however because one of them is
not joined, it uses a comma.      The above query will return a full set of
rows that join the “user” and “addresses” table together on the “id / user_id”
column, and will then apply all those rows into a cartesian product against
every row in the “addresses” table directly.   That is, if there are ten user
rows and 100 rows in addresses, the above query will return its expected result
rows, likely to be 100 as all address rows would be selected, multiplied by 100
again, so that the total result size would be 10000 rows.</p>
<p>The “table1, table2 JOIN table3” pattern is one that also occurs quite
frequently within the SQLAlchemy ORM due to either subtle mis-application of
ORM features particularly those related to joined eager loading or joined table
inheritance, as well as a result of SQLAlchemy ORM bugs within those same
systems.   Similar issues apply to SELECT statements that use “implicit joins”,
where the JOIN keyword is not used and instead each FROM element is linked with
another one via the WHERE clause.</p>
<p>For some years there has been a recipe on the Wiki that applies a graph
algorithm to a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct at query execution time and inspects
the structure of the query for these un-linked FROM clauses, parsing through
the WHERE clause and all JOIN clauses to determine how FROM elements are linked
together and ensuring that all the FROM elements are connected in a single
graph. This recipe has now been adapted to be part of the <a class="reference internal" href="../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler" title="sqlalchemy.sql.compiler.SQLCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SQLCompiler</span></code></a>
itself where it now optionally emits a warning for a statement if this
condition is detected.   The warning is enabled using the
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.enable_from_linting" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.enable_from_linting</span></code></a> flag and is enabled by default.
The computational overhead of the linter is very low, and additionally it only
occurs during statement compilation which means for a cached SQL statement it
only occurs once.</p>
<p>Using this feature, our ORM query above will emit a warning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">SAWarning: SELECT statement has a cartesian product between FROM</span>
<span class="go">element(s) &quot;addresses_1&quot;, &quot;users&quot; and FROM element &quot;addresses&quot;.</span>
<span class="go">Apply join condition(s) between each element to resolve.</span></pre></div>
</div>
<p>The linter feature accommodates not just for tables linked together through the
JOIN clauses but also through the WHERE clause  Above, we can add a WHERE
clause to link the new <code class="docutils literal notranslate"><span class="pre">Address</span></code> entity with the previous <code class="docutils literal notranslate"><span class="pre">address_alias</span></code>
entity and that will remove the warning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">address_alias</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">address_alias</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>  <span class="c1"># resolve cartesian products,</span>
                                            <span class="c1"># will no longer warn</span></pre></div>
</div>
<p>The cartesian product warning considers <strong>any</strong> kind of link between two
FROM clauses to be a resolution, even if the end result set is still
wasteful, as the linter is intended only to detect the common case of a
FROM clause that is completely unexpected.  If the FROM clause is referred
to explicitly elsewhere and linked to the other FROMs, no warning is emitted:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">address_alias</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">address_alias</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>  <span class="c1"># will generate a lot of rows,</span>
                                           <span class="c1"># but no warning</span></pre></div>
</div>
<p>Full cartesian products are also allowed if they are explicitly stated; if we
wanted for example the cartesian product of <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code>, we can
JOIN on <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.true" title="sqlalchemy.sql.expression.true"><code class="xref py py-func docutils literal notranslate"><span class="pre">true()</span></code></a> so that every row will match with every other; the
following query will return all rows and produce no warnings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">true</span>

<span class="c1"># intentional cartesian product</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">true</span><span class="p">())</span>  <span class="c1"># intentional cartesian product</span></pre></div>
</div>
<p>The warning is only generated by default when the statement is compiled by the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> for execution; calling the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ClauseElement.compile" title="sqlalchemy.sql.expression.ClauseElement.compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ClauseElement.compile()</span></code></a>
method will not emit a warning unless the linting flag is supplied:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">FROM_LINTING</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">linting</span><span class="o">=</span><span class="n">FROM_LINTING</span><span class="p">))</span>
<span class="go">SAWarning: SELECT statement has a cartesian product between FROM element(s) &quot;addresses&quot; and FROM element &quot;users&quot;.  Apply join condition(s) between each element to resolve.</span>
<span class="go">SELECT users.id, users.name, users.fullname, users.nickname</span>
<span class="go">FROM addresses, users JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id</span>
<span class="go">WHERE addresses.email_address = :email_address_1</span></pre></div>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4737">#4737</a></p>
</section>
<section id="new-result-object">
<span id="change-result-14-core"></span><h3>New Result object<a class="headerlink" href="#new-result-object" title="Permalink to this headline">¶</a></h3>
<p>A major goal of SQLAlchemy 2.0 is to unify how “results” are handled between
the ORM and Core.   Towards this goal, version 1.4 introduces new versions
of both the <code class="docutils literal notranslate"><span class="pre">ResultProxy</span></code> and <code class="docutils literal notranslate"><span class="pre">RowProxy</span></code> objects that have been part
of SQLAlchemy since the beginning.</p>
<p>The new objects are documented at <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> and <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>,
and are used not only for Core result sets but for <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> results
within the ORM as well.</p>
<p>This result object is fully compatible with <code class="docutils literal notranslate"><span class="pre">ResultProxy</span></code> and includes many
new features, that are now applied to both Core and ORM results equally,
including methods such as:</p>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.one" title="sqlalchemy.engine.Result.one"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.one()</span></code></a> - returns exactly a single row, or raises:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">one</span><span class="p">()</span></pre></div>
</div>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.one_or_none" title="sqlalchemy.engine.Result.one_or_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.one_or_none()</span></code></a> - same, but also returns None for no rows</p>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.all" title="sqlalchemy.engine.Result.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.all()</span></code></a> - returns all rows</p>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.partitions" title="sqlalchemy.engine.Result.partitions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.partitions()</span></code></a> - fetches rows in chunks:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
        <span class="n">table</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">),</span>
        <span class="n">execution_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;stream_results&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">partitions</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
        <span class="c1"># process up to 500 records</span></pre></div>
</div>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.columns" title="sqlalchemy.engine.Result.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.columns()</span></code></a> - allows slicing and reorganizing of rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
   <span class="c1"># requests x, y, z</span>
   <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

   <span class="c1"># iterate rows as y, x</span>
   <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">):</span>
       <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Y: </span><span class="si">%s</span><span class="s2">  X: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span></pre></div>
</div>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.scalars" title="sqlalchemy.engine.Result.scalars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.scalars()</span></code></a> - returns lists of scalar objects, from the
first column by default but can also be selected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
<span class="k">for</span> <span class="n">user_obj</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">scalars</span><span class="p">():</span>
    <span class="c1"># ...</span></pre></div>
</div>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result.mappings" title="sqlalchemy.engine.Result.mappings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.mappings()</span></code></a> - instead of named-tuple rows, returns
dictionaries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
   <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

   <span class="k">for</span> <span class="n">map_</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">mappings</span><span class="p">():</span>
       <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Y: </span><span class="si">%(y)s</span><span class="s2">  X: </span><span class="si">%(x)s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">map_</span><span class="p">)</span></pre></div>
</div>
<p>When using Core, the object returned by <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a> is
an instance of <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CursorResult" title="sqlalchemy.engine.CursorResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">CursorResult</span></code></a>, which continues to feature the same API
features as <code class="docutils literal notranslate"><span class="pre">ResultProxy</span></code> regarding inserted primary keys, defaults,
rowcounts, etc.   For ORM, a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> subclass will be returned
that performs translation of Core rows into ORM rows, and then allows all the
same operations to take place.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="migration_20.html#migration-20-unify-select"><span class="std std-ref">ORM Query Unified with Core Select</span></a> - in the 2.0 migration documentation</p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5087">#5087</a></p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4395">#4395</a></p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4959">#4959</a></p>
</section>
<section id="rowproxy-is-no-longer-a-proxy-is-now-called-row-and-behaves-like-an-enhanced-named-tuple">
<span id="change-4710-core"></span><h3>RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple<a class="headerlink" href="#rowproxy-is-no-longer-a-proxy-is-now-called-row-and-behaves-like-an-enhanced-named-tuple" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code> class, which represents individual database result rows
in a Core result set, is now called <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> and is no longer a “proxy”
object; what this means is that when the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> object is returned, the
row is a simple tuple that contains the data in its final form, already having
been processed by result-row handling functions associated with datatypes
(examples include turning a date string from the database into a <code class="docutils literal notranslate"><span class="pre">datetime</span></code>
object, a JSON string into a Python <code class="docutils literal notranslate"><span class="pre">json.loads()</span></code> result, etc.).</p>
<p>The immediate rationale for this is so that the row can act more like a Python
named tuple, rather than a mapping, where the values in the tuple are the
subject of the <code class="docutils literal notranslate"><span class="pre">__contains__</span></code> operator on the tuple, rather than the keys.
With <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> acting like a named tuple, it is then suitable for use as as
replacement for the ORM’s <code class="xref py py-class docutils literal notranslate"><span class="pre">KeyedTuple</span></code> object, leading to an eventual
API where both the ORM and Core deliver result sets that  behave identically.
Unification of major patterns within ORM and Core is a major goal of SQLAlchemy
2.0, and release 1.4 aims to have most or all of the underlying architectural
patterns in place in order to support this process.   The note in
<a class="reference internal" href="#change-4710-orm"><span class="std std-ref">The “KeyedTuple” object returned by Query is replaced by Row</span></a> describes the ORM’s use of the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> class.</p>
<p>For release 1.4, the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> class provides an additional subclass
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a>, which is used by Core and provides a backwards-compatible
version of <code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code> while emitting deprecation warnings for those API
features and behaviors that will be moved.  ORM <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> now makes use
of <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> directly as a replacement for <code class="xref py py-class docutils literal notranslate"><span class="pre">KeyedTuple</span></code>.</p>
<p>The <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a> class is a transitional class where the
<code class="docutils literal notranslate"><span class="pre">__contains__</span></code> method is still testing against the keys, not the values,
while emitting a deprecation warning when the operation succeeds.
Additionally, all the other mapping-like methods on the previous
<code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code> are deprecated, including <code class="xref py py-meth docutils literal notranslate"><span class="pre">LegacyRow.keys()</span></code>,
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow.items" title="sqlalchemy.engine.LegacyRow.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LegacyRow.items()</span></code></a>, etc.  For mapping-like behaviors from a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>
object, including support for these methods as well as a key-oriented
<code class="docutils literal notranslate"><span class="pre">__contains__</span></code> operator, the API going forward will be to first access a
special attribute <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row._mapping" title="sqlalchemy.engine.Row._mapping"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Row._mapping</span></code></a>, which will then provide a complete
mapping interface to the row, rather than a tuple interface.</p>
<section id="rationale-to-behave-more-like-a-named-tuple-rather-than-a-mapping">
<h4>Rationale: To behave more like a named tuple rather than a mapping<a class="headerlink" href="#rationale-to-behave-more-like-a-named-tuple-rather-than-a-mapping" title="Permalink to this headline">¶</a></h4>
<p>The difference between a named tuple and a mapping as far as boolean operators
can be summarized.   Given a “named tuple” in pseudo code as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>  <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;some name&#39;</span><span class="p">)</span></pre></div>
</div>
<p>The biggest cross-incompatible difference is the behavior of <code class="docutils literal notranslate"><span class="pre">__contains__</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;id&quot;</span> <span class="ow">in</span> <span class="n">row</span>          <span class="c1"># True for a mapping, False for a named tuple</span>
<span class="s2">&quot;some name&quot;</span> <span class="ow">in</span> <span class="n">row</span>   <span class="c1"># False for a mapping, True for a named tuple</span></pre></div>
</div>
<p>In 1.4, when a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a> is returned by a Core result set, the above
<code class="docutils literal notranslate"><span class="pre">&quot;id&quot;</span> <span class="pre">in</span> <span class="pre">row</span></code> comparison will continue to succeed, however a deprecation
warning will be emitted.   To use the “in” operator as a mapping, use the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row._mapping" title="sqlalchemy.engine.Row._mapping"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Row._mapping</span></code></a> attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;id&quot;</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">_mapping</span></pre></div>
</div>
<p>SQLAlchemy 2.0’s result object will feature a <code class="docutils literal notranslate"><span class="pre">.mappings()</span></code> modifier so that
these mappings can be received directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># using sqlalchemy.future package</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">mappings</span><span class="p">():</span>
    <span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span></pre></div>
</div>
</section>
<section id="proxying-behavior-goes-away-was-also-unnecessary-in-modern-usage">
<h4>Proxying behavior goes away, was also unnecessary in modern usage<a class="headerlink" href="#proxying-behavior-goes-away-was-also-unnecessary-in-modern-usage" title="Permalink to this headline">¶</a></h4>
<p>The refactor of <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> to behave like a tuple requires that all
data values be fully available up front.  This is an internal behavior change
from that of <code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code>, where result-row processing functions would
be invoked at the point of accessing an element of the row, instead of
when the row was first fetched.     This means for example when retrieving
a datetime value from SQLite, the data for the row as present in the
<code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code> object would previously have looked like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">row_proxy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2019-12-31 19:56:58.272106&#39;</span><span class="p">)</span></pre></div>
</div>
<p>and then upon access via <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, the <code class="docutils literal notranslate"><span class="pre">datetime.strptime()</span></code> function
would be used on the fly to convert the above string date into a <code class="docutils literal notranslate"><span class="pre">datetime</span></code>
object.     With the new architecture, the <code class="docutils literal notranslate"><span class="pre">datetime()</span></code> object is present
in the tuple when it is returned, the <code class="docutils literal notranslate"><span class="pre">datetime.strptime()</span></code> function
having been called just once up front:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2019</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">272106</span><span class="p">))</span></pre></div>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code> and <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> objects in SQLAlchemy are where the
majority of SQLAlchemy’s C extension code takes place.   This code has been
highly refactored to provide the new behavior in an efficient manner, and
overall performance has been improved as the design of <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> is now
considerably simpler.</p>
<p>The rationale behind the previous  behavior assumed a usage model where a
result row might have dozens or hundreds of columns present, where most of
those columns would not be accessed, and for which a majority of those columns
would require some result-value processing function.  By invoking the
processing function only when needed, the goal was that lots of result
processing functions would not be necessary, thus increasing performance.</p>
<p>There are many reasons why the above assumptions do not hold:</p>
<ol class="arabic simple">
<li><p>the vast majority of row-processing functions called were to Unicode decode
a bytestring into a Python Unicode string under Python 2.   This was right
as Python Unicode was beginning to see use and before Python 3 existed.
Once Python 3 was introduced, within a few years, all Python DBAPIs took
on the proper role of supporting the delivering of Python Unicode objects directly, under
both Python 2 and Python 3, as an option in the former case and as the only
way forward in the latter case.  Eventually, in most cases it became
the default for Python 2 as well.   SQLAlchemy’s Python 2 support still
enables explicit string-to-Unicode conversion for some DBAPIs such as
cx_Oracle, however it is now performed at the DBAPI level rather than
as a standard SQLAlchemy result row processing function.</p></li>
<li><p>The above string conversion, when it is used, was made to be extremely
performant via the C extensions, so much so that even in 1.4, SQLAlchemy’s
byte-to-Unicode codec hook is plugged into cx_Oracle where it has been
observed to be more performant than cx_Oracle’s own hook; this meant that
the overhead for converting all strings in a row was not as significant
as it originally was in any case.</p></li>
<li><p>Row processing functions are not used in most other cases; the
exceptions are SQLite’s datetime support, JSON support for some backends,
some numeric handlers such as string to <code class="docutils literal notranslate"><span class="pre">Decimal</span></code>.   In the case of
<code class="docutils literal notranslate"><span class="pre">Decimal</span></code>, Python 3 also standardized on the highly performant <code class="docutils literal notranslate"><span class="pre">cdecimal</span></code>
implementation, which is not the case in Python 2 which continues to use
the much less performant pure Python version.</p></li>
<li><p>Fetching full rows where only a few columns are needed is not common within
real-world use cases  In the early days of SQLAlchemy, database code from other
languages of the form “row = fetch(‘SELECT * FROM table’)” was common;
using SQLAlchemy’s expression language however, code observed in the wild
typically makes use of the specific columns needed.</p></li>
</ol>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#change-4710-orm"><span class="std std-ref">The “KeyedTuple” object returned by Query is replaced by Row</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4710">#4710</a></p>
</section>
</section>
<section id="select-objects-and-derived-from-clauses-allow-for-duplicate-columns-and-column-labels">
<span id="change-4753"></span><h3>SELECT objects and derived FROM clauses allow for duplicate columns and column labels<a class="headerlink" href="#select-objects-and-derived-from-clauses-allow-for-duplicate-columns-and-column-labels" title="Permalink to this headline">¶</a></h3>
<p>This change allows that the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct now allows for duplicate
column labels as well as duplicate column objects themselves, so that result
tuples are organized and ordered in the identical way in that the columns were
selected.  The ORM <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> already works this way, so this change
allows for greater cross-compatibility between the two, which is a key goal of
the 2.0 transition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">column</span><span class="p">,</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c4</span> <span class="o">=</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;c1&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;c2&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;c3&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;c4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;c2&#39;</span><span class="p">),</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="go">SELECT c1, c2, c3 AS c2, c2, c4</span></pre></div>
</div>
<p>To support this change, the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection" title="sqlalchemy.sql.expression.ColumnCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnCollection</span></code></a> used by
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase" title="sqlalchemy.sql.expression.SelectBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectBase</span></code></a> as well as for derived FROM clauses such as subqueries
also support duplicate columns; this includes the new
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns" title="sqlalchemy.sql.expression.SelectBase.selected_columns"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SelectBase.selected_columns</span></code></a> attribute, the deprecated <code class="docutils literal notranslate"><span class="pre">SelectBase.c</span></code>
attribute, as well as the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.c" title="sqlalchemy.sql.expression.FromClause.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FromClause.c</span></code></a> attribute seen on constructs
such as <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">selected_columns</span><span class="p">)</span>
<span class="go">[</span>
<span class="go">    &lt;sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcca20; c1&gt;,</span>
<span class="go">    &lt;sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcc9e8; c2&gt;,</span>
<span class="go">    &lt;sqlalchemy.sql.elements.Label object at 0x7fa540b3e2e8&gt;,</span>
<span class="go">    &lt;sqlalchemy.sql.elements.ColumnClause at 0x7fa540bcc9e8; c2&gt;,</span>
<span class="go">    &lt;sqlalchemy.sql.elements.ColumnClause at 0x7fa540897048; c4&gt;</span>
<span class="go">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">subquery</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">())</span>
<span class="go">SELECT anon_1.c1, anon_1.c2, anon_1.c2, anon_1.c2, anon_1.c4</span>
<span class="go">FROM (SELECT c1, c2, c3 AS c2, c2, c4) AS anon_1</span></pre></div>
</div>
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection" title="sqlalchemy.sql.expression.ColumnCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnCollection</span></code></a> also allows access by integer index to support
when the string “key” is ambiguous:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span><span class="o">.</span><span class="n">selected_columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&lt;sqlalchemy.sql.elements.Label object at 0x7fa540b3e2e8&gt;</span></pre></div>
</div>
<p>To suit the use of <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection" title="sqlalchemy.sql.expression.ColumnCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnCollection</span></code></a> in objects such as
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> and <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint" title="sqlalchemy.schema.PrimaryKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrimaryKeyConstraint</span></code></a>, the old “deduplicating”
behavior which is more critical for these objects is preserved in a new class
<code class="xref py py-class docutils literal notranslate"><span class="pre">DedupeColumnCollection</span></code>.</p>
<p>The change includes that the familiar warning <code class="docutils literal notranslate"><span class="pre">&quot;Column</span> <span class="pre">%r</span> <span class="pre">on</span> <span class="pre">table</span> <span class="pre">%r</span> <span class="pre">being</span>
<span class="pre">replaced</span> <span class="pre">by</span> <span class="pre">%r,</span> <span class="pre">which</span> <span class="pre">has</span> <span class="pre">the</span> <span class="pre">same</span> <span class="pre">key.</span>&#160; <span class="pre">Consider</span> <span class="pre">use_labels</span> <span class="pre">for</span> <span class="pre">select()</span>
<span class="pre">statements.&quot;</span></code> is <strong>removed</strong>; the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.apply_labels" title="sqlalchemy.sql.expression.Select.apply_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.apply_labels()</span></code></a> is still
available and is still used by the ORM for all SELECT operations, however it
does not imply deduplication of column objects, although it does imply
deduplication of implicitly generated labels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">apply_labels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="go">SELECT &quot;user&quot;.id AS user_id, &quot;user&quot;.name AS user_name, &quot;user&quot;.id AS id_1</span>
<span class="go">FROM &quot;user&quot;</span></pre></div>
</div>
<p>Finally, the change makes it easier to create UNION and other
<code class="xref py py-class docutils literal notranslate"><span class="pre">_selectable.CompoundSelect</span></code> objects, by ensuring that the number and position
of columns in a SELECT statement mirrors what was given, in a use case such
as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">union</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">union</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">SELECT &quot;user&quot;.id, &quot;user&quot;.name, &quot;user&quot;.id</span>
<span class="go">FROM &quot;user&quot; UNION SELECT c1, c2, c3</span></pre></div>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4753">#4753</a></p>
</section>
<section id="improved-column-labeling-for-simple-column-expressions-using-cast-or-similar">
<span id="change-4449"></span><h3>Improved column labeling for simple column expressions using CAST or similar<a class="headerlink" href="#improved-column-labeling-for-simple-column-expressions-using-cast-or-similar" title="Permalink to this headline">¶</a></h3>
<p>A user pointed out that the PostgreSQL database has a convenient behavior when
using functions like CAST against a named column, in that the result column name
is named the same as the inner expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="o">=&gt;</span> <span class="n">SELECT</span> <span class="n">CAST</span><span class="p">(</span><span class="n">data</span> <span class="n">AS</span> <span class="n">VARCHAR</span><span class="p">)</span> <span class="n">FROM</span> <span class="n">foo</span><span class="p">;</span>

<span class="n">data</span>
<span class="o">------</span>
 <span class="mi">5</span>
<span class="p">(</span><span class="mi">1</span> <span class="n">row</span><span class="p">)</span></pre></div>
</div>
<p>This allows one to apply CAST to table columns while not losing the column
name (above using the name <code class="docutils literal notranslate"><span class="pre">&quot;data&quot;</span></code>) in the result row.    Compare to
databases such as MySQL/MariaDB, as well as most others, where the column
name is taken from the full SQL expression and is not very portable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MariaDB</span> <span class="p">[</span><span class="n">test</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">SELECT</span> <span class="n">CAST</span><span class="p">(</span><span class="n">data</span> <span class="n">AS</span> <span class="n">CHAR</span><span class="p">)</span> <span class="n">FROM</span> <span class="n">foo</span><span class="p">;</span>
<span class="o">+--------------------+</span>
<span class="o">|</span> <span class="n">CAST</span><span class="p">(</span><span class="n">data</span> <span class="n">AS</span> <span class="n">CHAR</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+--------------------+</span>
<span class="o">|</span> <span class="mi">5</span>                  <span class="o">|</span>
<span class="o">+--------------------+</span>
<span class="mi">1</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">set</span> <span class="p">(</span><span class="mf">0.003</span> <span class="n">sec</span><span class="p">)</span></pre></div>
</div>
<p>In SQLAlchemy Core expressions, we never deal with a raw generated name like
the above, as SQLAlchemy applies auto-labeling to expressions like these, which
are up until now always a so-called “anonymous” expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">String</span><span class="p">)))</span>
<span class="go">SELECT CAST(foo.data AS VARCHAR) AS anon_1     # old behavior</span>
<span class="go">FROM foo</span></pre></div>
</div>
<p>These anonymous expressions were necessary as SQLAlchemy’s
<code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code> made heavy use of result column names in order to match
up datatypes, such as the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> datatype which used to have
result-row-processing behavior, to the correct column, so most importantly the
names had to be both easy to determine in a database-agnostic manner as well as
unique in all cases.    In SQLAlchemy 1.0 as part of <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/918">#918</a>, this
reliance on named columns in result rows (specifically the
<code class="docutils literal notranslate"><span class="pre">cursor.description</span></code> element of the PEP-249 cursor) was scaled back to not be
necessary for most Core SELECT constructs; in release 1.4, the system overall
is becoming more comfortable with SELECT statements that have duplicate column
or label names such as in <a class="reference internal" href="#change-4753"><span class="std std-ref">SELECT objects and derived FROM clauses allow for duplicate columns and column labels</span></a>.  So we now emulate PostgreSQL’s
reasonable behavior for simple modifications to a single column, most
prominently with CAST:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">String</span><span class="p">)))</span>
<span class="go">SELECT CAST(foo.data AS VARCHAR) AS data</span>
<span class="go">FROM foo</span></pre></div>
</div>
<p>For CAST against expressions that don’t have a name, the previous logic is used
to generate the usual “anonymous” labels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;hi there,&#39;</span> <span class="o">+</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">String</span><span class="p">)))</span>
<span class="go">SELECT CAST(:data_1 + foo.data AS VARCHAR) AS anon_1</span>
<span class="go">FROM foo</span></pre></div>
</div>
<p>A <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> against a <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Label" title="sqlalchemy.sql.expression.Label"><code class="xref py py-class docutils literal notranslate"><span class="pre">Label</span></code></a>, despite having to omit the label
expression as these don’t render inside of a CAST, will nonetheless make use of
the given name:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">cast</span><span class="p">((</span><span class="s1">&#39;hi there,&#39;</span> <span class="o">+</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;hello_data&#39;</span><span class="p">),</span> <span class="n">String</span><span class="p">)))</span>
<span class="go">SELECT CAST(:data_1 + foo.data AS VARCHAR) AS hello_data</span>
<span class="go">FROM foo</span></pre></div>
</div>
<p>And of course as was always the case, <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Label" title="sqlalchemy.sql.expression.Label"><code class="xref py py-class docutils literal notranslate"><span class="pre">Label</span></code></a> can be applied to the
expression on the outside to apply an “AS &lt;name&gt;” label directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">cast</span><span class="p">((</span><span class="s1">&#39;hi there,&#39;</span> <span class="o">+</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">String</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;hello_data&#39;</span><span class="p">)))</span>
<span class="go">SELECT CAST(:data_1 + foo.data AS VARCHAR) AS hello_data</span>
<span class="go">FROM foo</span></pre></div>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4449">#4449</a></p>
</section>
<section id="new-post-compile-bound-parameters-used-for-limit-offset-in-oracle-sql-server">
<span id="change-4808"></span><h3>New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server<a class="headerlink" href="#new-post-compile-bound-parameters-used-for-limit-offset-in-oracle-sql-server" title="Permalink to this headline">¶</a></h3>
<p>A major goal of the 1.4 series is to establish that all Core SQL constructs
are completely cacheable, meaning that a particular <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Compiled" title="sqlalchemy.engine.Compiled"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compiled</span></code></a>
structure will produce an identical SQL string regardless of any SQL parameters
used with it, which notably includes those used to specify the LIMIT and
OFFSET values, typically used for pagination and “top N” style results.</p>
<p>While SQLAlchemy has used bound parameters for LIMIT/OFFSET schemes for many
years, a few outliers remained where such parameters were not allowed, including
a SQL Server “TOP N” statement, such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">TOP</span> <span class="mi">5</span> <span class="n">mytable</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">mytable</span><span class="o">.</span><span class="n">data</span> <span class="n">FROM</span> <span class="n">mytable</span></pre></div>
</div>
<p>as well as with Oracle, where the FIRST_ROWS() hint (which SQLAlchemy will
use if the <code class="docutils literal notranslate"><span class="pre">optimize_limits=True</span></code> parameter is passed to
<a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> with an Oracle URL) does not allow them,
but also that using bound parameters with ROWNUM comparisons has been reported
as producing slower query plans:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">data</span> <span class="n">FROM</span> <span class="p">(</span>
    <span class="n">SELECT</span> <span class="o">/*+</span> <span class="n">FIRST_ROWS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">anon_2</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="nb">id</span><span class="p">,</span>
    <span class="n">anon_2</span><span class="o">.</span><span class="n">data</span> <span class="n">AS</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">ROWNUM</span> <span class="n">AS</span> <span class="n">ora_rn</span> <span class="n">FROM</span> <span class="p">(</span>
        <span class="n">SELECT</span> <span class="n">mytable</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">mytable</span><span class="o">.</span><span class="n">data</span> <span class="n">FROM</span> <span class="n">mytable</span>
    <span class="p">)</span> <span class="n">anon_2</span>
    <span class="n">WHERE</span> <span class="n">ROWNUM</span> <span class="o">&lt;=</span> <span class="p">:</span><span class="n">param_1</span>
<span class="p">)</span> <span class="n">anon_1</span> <span class="n">WHERE</span> <span class="n">ora_rn</span> <span class="o">&gt;</span> <span class="p">:</span><span class="n">param_2</span></pre></div>
</div>
<p>In order to allow for all statements to be unconditionally cacheable at the
compilation level, a new form of bound parameter called a “post compile”
parameter has been added, which makes use of the same mechanism as that
of “expanding IN parameters”.  This is a <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> that behaves
identically to any other bound parameter except that parameter value will
be rendered literally into the SQL string before sending it to the DBAPI
<code class="docutils literal notranslate"><span class="pre">cursor.execute()</span></code> method.   The new parameter is used internally by the
SQL Server and Oracle dialects, so that the drivers receive the literal
rendered value but the rest of SQLAlchemy can still consider this as a
bound parameter.   The above two statements when stringified using
<code class="docutils literal notranslate"><span class="pre">str(statement.compile(dialect=&lt;dialect&gt;))</span></code> now look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">TOP</span> <span class="p">[</span><span class="n">POSTCOMPILE_param_1</span><span class="p">]</span> <span class="n">mytable</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">mytable</span><span class="o">.</span><span class="n">data</span> <span class="n">FROM</span> <span class="n">mytable</span></pre></div>
</div>
<p>and:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">data</span> <span class="n">FROM</span> <span class="p">(</span>
    <span class="n">SELECT</span> <span class="o">/*+</span> <span class="n">FIRST_ROWS</span><span class="p">([</span><span class="n">POSTCOMPILE__ora_frow_1</span><span class="p">])</span> <span class="o">*/</span>
    <span class="n">anon_2</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="nb">id</span><span class="p">,</span>
    <span class="n">anon_2</span><span class="o">.</span><span class="n">data</span> <span class="n">AS</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">ROWNUM</span> <span class="n">AS</span> <span class="n">ora_rn</span> <span class="n">FROM</span> <span class="p">(</span>
        <span class="n">SELECT</span> <span class="n">mytable</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">mytable</span><span class="o">.</span><span class="n">data</span> <span class="n">FROM</span> <span class="n">mytable</span>
    <span class="p">)</span> <span class="n">anon_2</span>
    <span class="n">WHERE</span> <span class="n">ROWNUM</span> <span class="o">&lt;=</span> <span class="p">[</span><span class="n">POSTCOMPILE_param_1</span><span class="p">]</span>
<span class="p">)</span> <span class="n">anon_1</span> <span class="n">WHERE</span> <span class="n">ora_rn</span> <span class="o">&gt;</span> <span class="p">[</span><span class="n">POSTCOMPILE_param_2</span><span class="p">]</span></pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">[POSTCOMPILE_&lt;param&gt;]</span></code> format is also what is seen when an
“expanding IN” is used.</p>
<p>When viewing the SQL logging output, the final form of the statement will
be seen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">data</span> <span class="n">FROM</span> <span class="p">(</span>
    <span class="n">SELECT</span> <span class="o">/*+</span> <span class="n">FIRST_ROWS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">anon_2</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="nb">id</span><span class="p">,</span>
    <span class="n">anon_2</span><span class="o">.</span><span class="n">data</span> <span class="n">AS</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">ROWNUM</span> <span class="n">AS</span> <span class="n">ora_rn</span> <span class="n">FROM</span> <span class="p">(</span>
        <span class="n">SELECT</span> <span class="n">mytable</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="nb">id</span><span class="p">,</span> <span class="n">mytable</span><span class="o">.</span><span class="n">data</span> <span class="n">AS</span> <span class="n">data</span> <span class="n">FROM</span> <span class="n">mytable</span>
    <span class="p">)</span> <span class="n">anon_2</span>
    <span class="n">WHERE</span> <span class="n">ROWNUM</span> <span class="o">&lt;=</span> <span class="mi">8</span>
<span class="p">)</span> <span class="n">anon_1</span> <span class="n">WHERE</span> <span class="n">ora_rn</span> <span class="o">&gt;</span> <span class="mi">3</span></pre></div>
</div>
<p>The “post compile parameter” feature is exposed as public API through the
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">bindparam.literal_execute</span></code></a> parameter, however is currently not
intended for general use.   The literal values are rendered using the
<a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor" title="sqlalchemy.types.TypeEngine.literal_processor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.literal_processor()</span></code></a> of the underlying datatype, which in
SQLAlchemy has <strong>extremely limited</strong> scope, supporting only integers and simple
string values.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4808">#4808</a></p>
</section>
<section id="connection-level-transactions-can-now-be-inactive-based-on-subtransaction">
<span id="change-4712"></span><h3>Connection-level transactions can now be inactive based on subtransaction<a class="headerlink" href="#connection-level-transactions-can-now-be-inactive-based-on-subtransaction" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> now includes the behavior where a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Transaction" title="sqlalchemy.engine.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>
can be made inactive due to a rollback on an inner transaction, however the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Transaction" title="sqlalchemy.engine.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a> will not clear until it is itself rolled back.</p>
<p>This is essentially a new error condition which will disallow statement
executions to proceed on a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> if an inner “sub” transaction
has been rolled back.  The behavior works very similarly to that of the
ORM <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, where if an outer transaction has been begun, it needs
to be rolled back to clear the invalid transaction; this behavior is described
in <a class="reference internal" href="../faq/sessions.html#faq-session-rollback"><span class="std std-ref">“This Session’s transaction has been rolled back due to a previous exception during flush.” (or similar)</span></a>.</p>
<p>While the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> has had a less strict behavioral pattern than
the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, this change was made as it helps to identify when
a subtransaction has rolled back the DBAPI transaction, however the external
code isn’t aware of this and attempts to continue proceeding, which in fact
runs operations on a new transaction.   The “test harness” pattern described
at <a class="reference internal" href="../orm/session_transaction.html#session-external-transaction"><span class="std std-ref">Joining a Session into an External Transaction (such as for test suites)</span></a> is the common place for this to occur.</p>
<p>The “subtransaction” feature of Core and ORM is itself deprecated and will
no longer be present in version 2.0.   As a result, this new error condition
is itself temporary as it will no longer apply once subtransactions are removed.</p>
<p>In order to work with the 2.0 style behavior that does not include
subtransactions, use the <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine.params.future" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.future</span></code></a> parameter
on <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>.</p>
<p>The error message is described in the errors page at <a class="reference internal" href="../errors.html#error-8s2a"><span class="std std-ref">This connection is on an inactive transaction.  Please rollback() fully before proceeding</span></a>.</p>
</section>
<section id="enum-and-boolean-datatypes-no-longer-default-to-create-constraint">
<span id="change-5367"></span><h3>Enum and Boolean datatypes no longer default to “create constraint”<a class="headerlink" href="#enum-and-boolean-datatypes-no-longer-default-to-create-constraint" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint" title="sqlalchemy.types.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.create_constraint</span></code></a> and
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint" title="sqlalchemy.types.Boolean"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Boolean.create_constraint</span></code></a> parameters now default to False,
indicating when a so-called “non-native” version of these two datatypes is
created, a CHECK constraint will <strong>not</strong> be generated by default.   These
CHECK constraints present schema-management maintenance complexities that
should be opted in to, rather than being turned on by default.</p>
<p>To ensure that a CREATE CONSTRAINT is emitted for these types, set these
flags to <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Spam</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;spam&quot;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">boolean</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Boolean</span><span class="p">(</span><span class="n">create_constraint</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">enum</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Enum</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">create_constraint</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></pre></div>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5367">#5367</a></p>
</section>
</section>
<section id="new-features-orm">
<h2>New Features - ORM<a class="headerlink" href="#new-features-orm" title="Permalink to this headline">¶</a></h2>
<section id="raiseload-for-columns">
<span id="change-4826"></span><h3>Raiseload for Columns<a class="headerlink" href="#raiseload-for-columns" title="Permalink to this headline">¶</a></h3>
<p>The “raiseload” feature, which raises <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.InvalidRequestError" title="sqlalchemy.exc.InvalidRequestError"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidRequestError</span></code></a> when an
unloaded attribute is accessed, is now available for column-oriented attributes
using the <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.defer.params.raiseload" title="sqlalchemy.orm.defer"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">defer.raiseload</span></code></a> parameter of <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.defer" title="sqlalchemy.orm.defer"><code class="xref py py-func docutils literal notranslate"><span class="pre">defer()</span></code></a>. This
works in the same manner as that of the <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a> option used by
relationship loading:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">book</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Book</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">defer</span><span class="p">(</span><span class="n">Book</span><span class="o">.</span><span class="n">summary</span><span class="p">,</span> <span class="n">raiseload</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># would raise an exception</span>
<span class="n">book</span><span class="o">.</span><span class="n">summary</span></pre></div>
</div>
<p>To configure column-level raiseload on a mapping, the
<a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.deferred.params.raiseload" title="sqlalchemy.orm.deferred"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">deferred.raiseload</span></code></a> parameter of <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.deferred" title="sqlalchemy.orm.deferred"><code class="xref py py-func docutils literal notranslate"><span class="pre">deferred()</span></code></a> may be used.  The
<a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.undefer" title="sqlalchemy.orm.undefer"><code class="xref py py-func docutils literal notranslate"><span class="pre">undefer()</span></code></a> option may then be used at query time to eagerly load
the attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;book&#39;</span>

    <span class="n">book_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="n">deferred</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">2000</span><span class="p">)),</span> <span class="n">raiseload</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">excerpt</span> <span class="o">=</span> <span class="n">deferred</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="n">Text</span><span class="p">),</span> <span class="n">raiseload</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">book_w_excerpt</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Book</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">undefer</span><span class="p">(</span><span class="n">Book</span><span class="o">.</span><span class="n">excerpt</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span></pre></div>
</div>
<p>It was originally considered that the existing <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a> option that
works for <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> attributes be expanded to also support column-oriented
attributes.    However, this would break the “wildcard” behavior of <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a>,
which is documented as allowing one to prevent all relationships from loading:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">),</span> <span class="n">raiseload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span></pre></div>
</div>
<p>Above, if we had expanded <a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a> to accommodate for columns  as
well, the wildcard would also prevent columns from loading and thus be  a
backwards incompatible change; additionally, it’s not clear if
<a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a> covered both column expressions and relationships, how one
would achieve the  effect above of only blocking relationship loads, without
new API being added.   So to keep things simple, the option for columns
remains on <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.defer" title="sqlalchemy.orm.defer"><code class="xref py py-func docutils literal notranslate"><span class="pre">defer()</span></code></a>:</p>
<blockquote>
<div><p><a class="reference internal" href="../orm/loading_relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a> - query option to raise for relationship loads</p>
<p><a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.defer.params.raiseload" title="sqlalchemy.orm.defer"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">defer.raiseload</span></code></a> - query option to raise for column expression loads</p>
</div></blockquote>
<p>As part of this change, the behavior of “deferred” in conjunction with
attribute expiration has changed.   Previously, when an object would be marked
as expired, and then unexpired via the access of one of the expired attributes,
attributes which were mapped as “deferred” at the mapper level would also load.
This has been changed such that an attribute that is deferred in the mapping
will never “unexpire”, it only loads when accessed as part of the deferral
loader.</p>
<p>An attribute that is not mapped as “deferred”, however was deferred at query
time via the <a class="reference internal" href="../orm/loading_columns.html#sqlalchemy.orm.defer" title="sqlalchemy.orm.defer"><code class="xref py py-func docutils literal notranslate"><span class="pre">defer()</span></code></a> option, will be reset when the object or attribute
is expired; that is, the deferred option is removed. This is the same behavior
as was present previously.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/loading_columns.html#deferred-raiseload"><span class="std std-ref">Raiseload for Deferred Columns</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4826">#4826</a></p>
</section>
<section id="orm-batch-inserts-with-psycopg2-now-batch-statements-with-returning-in-most-cases">
<span id="change-5263"></span><h3>ORM Batch inserts with psycopg2 now batch statements with RETURNING in most cases<a class="headerlink" href="#orm-batch-inserts-with-psycopg2-now-batch-statements-with-returning-in-most-cases" title="Permalink to this headline">¶</a></h3>
<p>The change in <a class="reference internal" href="#change-5401"><span class="std std-ref">psycopg2 dialect features “execute_values” with RETURNING for INSERT statements by default</span></a> adds support for “executemany” + “RETURNING”
at the same time in Core, which is now enabled for the psycopg2 dialect
by default using the psycopg2 <code class="docutils literal notranslate"><span class="pre">execute_values()</span></code> extension.   The ORM flush
process now makes use of this feature such that the retrieval of newly generated
primary key values and server defaults can be achieved while not losing the
performance benefits of being able to batch INSERT statements together.  Additionally,
psycopg2’s <code class="docutils literal notranslate"><span class="pre">execute_values()</span></code> extension itself provides a five-fold performance
improvement over psycopg2’s default “executemany” implementation, by rewriting
an INSERT statement to include many “VALUES” expressions all in one statement
rather than invoking the same statement repeatedly, as psycopg2 lacks the ability
to PREPARE the statement ahead of time as would normally be expected for this
approach to be performant.</p>
<p>SQLAlchemy includes a <a class="reference internal" href="../orm/examples.html#examples-performance"><span class="std std-ref">performance suite</span></a> within
its examples, where we can compare the times generated for the “batch_inserts”
runner against 1.3 and 1.4, revealing a 3x-5x speedup for most flavors
of batch insert:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># 1.3
$ python -m examples.performance bulk_inserts --dburl postgresql://scott:tiger@localhost/test
test_flush_no_pk : (100000 iterations); total time 14.051527 sec
test_bulk_save_return_pks : (100000 iterations); total time 15.002470 sec
test_flush_pk_given : (100000 iterations); total time 7.863680 sec
test_bulk_save : (100000 iterations); total time 6.780378 sec
test_bulk_insert_mappings :  (100000 iterations); total time 5.363070 sec
test_core_insert : (100000 iterations); total time 5.362647 sec

# 1.4 with enhancement
$ python -m examples.performance bulk_inserts --dburl postgresql://scott:tiger@localhost/test
test_flush_no_pk : (100000 iterations); total time 3.820807 sec
test_bulk_save_return_pks : (100000 iterations); total time 3.176378 sec
test_flush_pk_given : (100000 iterations); total time 4.037789 sec
test_bulk_save : (100000 iterations); total time 2.604446 sec
test_bulk_insert_mappings : (100000 iterations); total time 1.204897 sec
test_core_insert : (100000 iterations); total time 0.958976 sec</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">execute_values()</span></code> extension modifies the INSERT statement in the psycopg2
layer, <strong>after</strong> it’s been logged by SQLAlchemy.  So with SQL logging, one will see the
parameter sets batched together, but the joining of multiple “values” will not be visible
on the application side:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mi">18</span><span class="p">,</span><span class="mi">166</span> <span class="n">INFO</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">Engine</span> <span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">a</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="n">VALUES</span> <span class="p">(</span><span class="o">%</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="n">s</span><span class="p">)</span> <span class="n">RETURNING</span> <span class="n">a</span><span class="o">.</span><span class="n">id</span>
<span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mi">18</span><span class="p">,</span><span class="mi">166</span> <span class="n">INFO</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">Engine</span> <span class="p">[</span><span class="n">generated</span> <span class="ow">in</span> <span class="mf">0.00698</span><span class="n">s</span><span class="p">]</span> <span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 1&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 2&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 3&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 4&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 5&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 6&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 7&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 8&#39;</span><span class="p">}</span>  <span class="o">...</span> <span class="n">displaying</span> <span class="mi">10</span> <span class="n">of</span> <span class="mi">4999</span> <span class="n">total</span> <span class="n">bound</span> <span class="n">parameter</span> <span class="n">sets</span> <span class="o">...</span>  <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 4998&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;data 4999&#39;</span><span class="p">})</span>
<span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mi">18</span><span class="p">,</span><span class="mi">254</span> <span class="n">INFO</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">Engine</span> <span class="n">COMMIT</span></pre></div>
</div>
<p>The ultimate INSERT statement can be seen by enabling statement logging on the PostgreSQL side:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mf">18.169</span> <span class="n">EDT</span> <span class="p">[</span><span class="mi">26960</span><span class="p">]</span> <span class="n">LOG</span><span class="p">:</span>  <span class="n">statement</span><span class="p">:</span> <span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">a</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">VALUES</span> <span class="p">(</span><span class="s1">&#39;data 1&#39;</span><span class="p">),(</span><span class="s1">&#39;data 2&#39;</span><span class="p">),(</span><span class="s1">&#39;data 3&#39;</span><span class="p">),(</span><span class="s1">&#39;data 4&#39;</span><span class="p">),(</span><span class="s1">&#39;data 5&#39;</span><span class="p">),(</span><span class="s1">&#39;data 6&#39;</span><span class="p">),(</span><span class="s1">&#39;data</span>
<span class="mi">7</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">8</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">9</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">10</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">11</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">12</span><span class="s1">&#39;),</span>
<span class="o">...</span> <span class="p">(</span><span class="s1">&#39;data 999&#39;</span><span class="p">),(</span><span class="s1">&#39;data 1000&#39;</span><span class="p">)</span> <span class="n">RETURNING</span> <span class="n">a</span><span class="o">.</span><span class="n">id</span>

<span class="mi">2020</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mf">18.175</span> <span class="n">EDT</span>
<span class="p">[</span><span class="mi">26960</span><span class="p">]</span> <span class="n">LOG</span><span class="p">:</span>  <span class="n">statement</span><span class="p">:</span> <span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">a</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="n">VALUES</span> <span class="p">(</span><span class="s1">&#39;data 1001&#39;</span><span class="p">),(</span><span class="s1">&#39;data</span>
<span class="mi">1002</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">1003</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">1004</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">1005</span> <span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">1006</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span>
<span class="mi">1007</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">1008</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">1009</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">1010</span><span class="s1">&#39;),(&#39;</span><span class="n">data</span> <span class="mi">1011</span><span class="s1">&#39;), ...</span></pre></div>
</div>
<p>The feature batches rows into groups of 1000 by default which can be affected
using the <code class="docutils literal notranslate"><span class="pre">executemany_values_page_size</span></code> argument documented at
<a class="reference internal" href="../dialects/postgresql.html#psycopg2-executemany-mode"><span class="std std-ref">Psycopg2 Fast Execution Helpers</span></a>.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5263">#5263</a></p>
</section>
<section id="orm-bulk-update-and-delete-use-returning-for-fetch-strategy-when-available">
<span id="change-orm-update-returning-14"></span><h3>ORM Bulk Update and Delete use RETURNING for “fetch” strategy when available<a class="headerlink" href="#orm-bulk-update-and-delete-use-returning-for-fetch-strategy-when-available" title="Permalink to this headline">¶</a></h3>
<p>An ORM bulk update or delete that uses the “fetch” strategy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">age</span> <span class="o">&gt;</span> <span class="mi">29</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="p">{</span><span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="n">User</span><span class="o">.</span><span class="n">age</span> <span class="o">-</span> <span class="mi">10</span><span class="p">},</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="s2">&quot;fetch&quot;</span>
<span class="p">)</span></pre></div>
</div>
<p>Will now use RETURNING if the backend database supports it; this currently
includes PostgreSQL and SQL Server (the Oracle dialect does not support RETURNING
of multiple rows):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">users</span> <span class="n">SET</span> <span class="n">age_int</span><span class="o">=</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">age_int</span> <span class="o">-</span> <span class="o">%</span><span class="p">(</span><span class="n">age_int_1</span><span class="p">)</span><span class="n">s</span><span class="p">)</span> <span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">age_int</span> <span class="o">&gt;</span> <span class="o">%</span><span class="p">(</span><span class="n">age_int_2</span><span class="p">)</span><span class="n">s</span> <span class="n">RETURNING</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span>
<span class="p">[</span><span class="n">generated</span> <span class="ow">in</span> <span class="mf">0.00060</span><span class="n">s</span><span class="p">]</span> <span class="p">{</span><span class="s1">&#39;age_int_1&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;age_int_2&#39;</span><span class="p">:</span> <span class="mi">29</span><span class="p">}</span>
<span class="n">Col</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,)</span>
<span class="n">Row</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)</span>
<span class="n">Row</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span></pre></div>
</div>
<p>For backends that do not support RETURNING of multiple rows, the previous approach
of emitting SELECT for the primary keys beforehand is still used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="n">FROM</span> <span class="n">users</span> <span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">age_int</span> <span class="o">&gt;</span> <span class="o">%</span><span class="p">(</span><span class="n">age_int_1</span><span class="p">)</span><span class="n">s</span>
<span class="p">[</span><span class="n">generated</span> <span class="ow">in</span> <span class="mf">0.00043</span><span class="n">s</span><span class="p">]</span> <span class="p">{</span><span class="s1">&#39;age_int_1&#39;</span><span class="p">:</span> <span class="mi">29</span><span class="p">}</span>
<span class="n">Col</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,)</span>
<span class="n">Row</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)</span>
<span class="n">Row</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)</span>
<span class="n">UPDATE</span> <span class="n">users</span> <span class="n">SET</span> <span class="n">age_int</span><span class="o">=</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">age_int</span> <span class="o">-</span> <span class="o">%</span><span class="p">(</span><span class="n">age_int_1</span><span class="p">)</span><span class="n">s</span><span class="p">)</span> <span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">age_int</span> <span class="o">&gt;</span> <span class="o">%</span><span class="p">(</span><span class="n">age_int_2</span><span class="p">)</span><span class="n">s</span>
<span class="p">[</span><span class="n">generated</span> <span class="ow">in</span> <span class="mf">0.00102</span><span class="n">s</span><span class="p">]</span> <span class="p">{</span><span class="s1">&#39;age_int_1&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;age_int_2&#39;</span><span class="p">:</span> <span class="mi">29</span><span class="p">}</span></pre></div>
</div>
<p>One of the intricate challenges of this change is to support cases such as the
horizontal sharding extension, where a single bulk update or delete may be
multiplexed among backends some of which support RETURNING and some don’t.   The
new 1.4 execution architecture supports this case so that the “fetch” strategy
can be left intact with a graceful degrade to using a SELECT, rather than having
to add a new “returning” strategy that would not be backend-agnostic.</p>
<p>As part of this change, the “fetch” strategy is also made much more efficient
in that it will no longer expire the objects located which match the rows,
for Python expressions used in the SET clause which can be evaluated in
Python; these are instead assigned
directly onto the object in the same way as the “evaluate” strategy.  Only
for SQL expressions that can’t be evaluated does it fall back to expiring
the attributes.   The “evaluate” strategy has also been enhanced to fall back
to “expire” for a value that cannot be evaluated.</p>
</section>
</section>
<section id="behavioral-changes-orm">
<h2>Behavioral Changes - ORM<a class="headerlink" href="#behavioral-changes-orm" title="Permalink to this headline">¶</a></h2>
<section id="the-keyedtuple-object-returned-by-query-is-replaced-by-row">
<span id="change-4710-orm"></span><h3>The “KeyedTuple” object returned by Query is replaced by Row<a class="headerlink" href="#the-keyedtuple-object-returned-by-query-is-replaced-by-row" title="Permalink to this headline">¶</a></h3>
<p>As discussed at <a class="reference internal" href="#change-4710-core"><span class="std std-ref">RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple</span></a>, the Core <code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code> object
is now replaced by a class called <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>.    The base <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>
object now behaves more fully like a named tuple, and as such it is now
used as the basis for tuple-like results returned by the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
object, rather than the previous “KeyedTuple” class.</p>
<p>The rationale is so that by SQLAlchemy 2.0, both Core and ORM SELECT statements
will return result rows using the same <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> object which behaves  like
a named tuple.  Dictionary-like functionality is available from <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>
via the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row._mapping" title="sqlalchemy.engine.Row._mapping"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Row._mapping</span></code></a> attribute.   In the interim, Core result sets
will make use of a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> subclass <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.LegacyRow" title="sqlalchemy.engine.LegacyRow"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegacyRow</span></code></a> which maintains
the previous dict/tuple hybrid behavior for backwards compatibility while the
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> class will be used directly for ORM tuple results returned
by the <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> object.</p>
<p>Effort has been made to get most of the featureset of <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> to be
available within the ORM, meaning that access by string name as well
as entity / column should work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">row</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="n">row</span><span class="o">.</span><span class="n">_mapping</span><span class="p">[</span><span class="n">User</span><span class="p">]</span>  <span class="c1"># same as row[0]</span>
<span class="n">row</span><span class="o">.</span><span class="n">_mapping</span><span class="p">[</span><span class="n">Address</span><span class="p">]</span>  <span class="c1"># same as row[1]</span>
<span class="n">row</span><span class="o">.</span><span class="n">_mapping</span><span class="p">[</span><span class="s2">&quot;User&quot;</span><span class="p">]</span>  <span class="c1"># same as row[0]</span>
<span class="n">row</span><span class="o">.</span><span class="n">_mapping</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]</span>  <span class="c1"># same as row[1]</span>

<span class="n">u1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span><span class="o">.</span><span class="n">only_return_tuples</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">row</span><span class="o">.</span><span class="n">_mapping</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span>  <span class="c1"># same as row[0]</span>


<span class="n">row</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span>
    <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span>
    <span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="p">)</span>

<span class="n">row</span><span class="o">.</span><span class="n">_mapping</span><span class="p">[</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>  <span class="c1"># same as row[0]</span>
<span class="n">row</span><span class="o">.</span><span class="n">_mapping</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>  <span class="c1"># same as row[0]</span>
<span class="n">row</span><span class="o">.</span><span class="n">_mapping</span><span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>  <span class="c1"># same as row[0]</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#change-4710-core"><span class="std std-ref">RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4710">#4710</a>.</p>
</section>
<section id="session-features-new-autobegin-behavior">
<span id="change-5074"></span><h3>Session features new “autobegin” behavior<a class="headerlink" href="#session-features-new-autobegin-behavior" title="Permalink to this headline">¶</a></h3>
<p>Previously, the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> in its default mode of <code class="docutils literal notranslate"><span class="pre">autocommit=False</span></code>
would internally begin a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a> object immediately
on construction, and additionally would create a new one after each call to
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.rollback" title="sqlalchemy.orm.Session.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code></a> or <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a>.</p>
<p>The new behavior is that this <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a> object is now
created on demand only, when methods such as <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.add" title="sqlalchemy.orm.Session.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add()</span></code></a> or
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> are called.    However it is also now possible
to call <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.begin" title="sqlalchemy.orm.Session.begin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.begin()</span></code></a> explicitly in order to begin the transaction,
even in <code class="docutils literal notranslate"><span class="pre">autocommit=False</span></code> mode, thus matching the behavior of the
future-style <code class="xref py py-class docutils literal notranslate"><span class="pre">_base.Connection</span></code>.</p>
<p>The behavioral changes this indicates are:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> can now be in the state where no transaction is begun,
even in <code class="docutils literal notranslate"><span class="pre">autocommit=False</span></code> mode. Previously, this state was only available
in “autocommit” mode.</p></li>
<li><p>Within this state, the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a> and <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.rollback" title="sqlalchemy.orm.Session.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code></a>
methods are no-ops. Code that relies upon these methods to expire all objects
should make explicit use of either <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.begin" title="sqlalchemy.orm.Session.begin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.begin()</span></code></a> or
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.expire_all" title="sqlalchemy.orm.Session.expire_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expire_all()</span></code></a> to suit their use case.</p></li>
<li><p>The <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create" title="sqlalchemy.orm.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.after_transaction_create()</span></code></a> event hook is not emitted
immediately when the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> is created, or after a
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.rollback" title="sqlalchemy.orm.Session.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code></a> or <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a> completes.</p></li>
<li><p>The <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.close" title="sqlalchemy.orm.Session.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code></a> method also does not imply implicit begin of a new
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a>.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/session_basics.html#session-autobegin"><span class="std std-ref">Auto Begin</span></a></p>
</div>
<section id="rationale">
<h4>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> object’s default behavior of <code class="docutils literal notranslate"><span class="pre">autocommit=False</span></code>
historically has meant that there is always a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a>
object in play, associated with the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> via the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.transaction" title="sqlalchemy.orm.Session.transaction"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Session.transaction</span></code></a> attribute.   When the given
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a> was complete, due to a commit, rollback, or close,
it was immediately replaced with a new one.  The <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a>
by itself does not imply the usage of any connection-oriented resources, so
this long-standing behavior has a particular elegance to it in that the state
of <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.transaction" title="sqlalchemy.orm.Session.transaction"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Session.transaction</span></code></a> is always predictable as non-None.</p>
<p>However, as part of the initiative in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5056">#5056</a> to greatly reduce
reference cycles, this assumption means that calling upon
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.close" title="sqlalchemy.orm.Session.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code></a> results in a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> object that still has
reference cycles and is more expensive to clean up, not to mention that there
is a small overhead in constructing the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a>
object, which meant that there would be unnecessary overhead created
for a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> that for example invoked <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a>
and then <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.close" title="sqlalchemy.orm.Session.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code></a>.</p>
<p>As such, it was decided that <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.close" title="sqlalchemy.orm.Session.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code></a> should leave the internal
state of <code class="docutils literal notranslate"><span class="pre">self.transaction</span></code>, now referred to internally as
<code class="docutils literal notranslate"><span class="pre">self._transaction</span></code>, as None, and that a new <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a>
should only be created when needed.  For consistency and code coverage, this
behavior was also expanded to include all the points at which “autobegin” is
expected, not just when <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.close" title="sqlalchemy.orm.Session.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code></a> were called.</p>
<p>In particular, this causes a behavioral change for applications which
subscribe to the <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create" title="sqlalchemy.orm.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.after_transaction_create()</span></code></a> event hook;
previously, this event would be emitted when the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> were  first
constructed, as well as for most actions that closed the previous transaction
and would emit <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end" title="sqlalchemy.orm.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.after_transaction_end()</span></code></a>.  The new behavior
is that <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create" title="sqlalchemy.orm.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.after_transaction_create()</span></code></a> is emitted on demand,
when the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> has not yet created a  new
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.SessionTransaction" title="sqlalchemy.orm.SessionTransaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionTransaction</span></code></a> object and mapped objects are associated with the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> through methods like <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.add" title="sqlalchemy.orm.Session.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add()</span></code></a> and
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.delete" title="sqlalchemy.orm.Session.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.delete()</span></code></a>, when  the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.transaction" title="sqlalchemy.orm.Session.transaction"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Session.transaction</span></code></a> attribute is
called upon, when the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.flush" title="sqlalchemy.orm.Session.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.flush()</span></code></a> method has tasks to complete, etc.</p>
<p>In addition, code which relies upon the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a> or
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.rollback" title="sqlalchemy.orm.Session.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code></a> method to unconditionally expire all objects can no
longer do so. Code which needs to expire all objects when no change that has
occurred should be calling <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.expire_all" title="sqlalchemy.orm.Session.expire_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expire_all()</span></code></a> for this case.</p>
<p>Besides the change in when the <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create" title="sqlalchemy.orm.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.after_transaction_create()</span></code></a>
event is emitted as well as the no-op nature of <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a> or
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.rollback" title="sqlalchemy.orm.Session.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code></a>, the change should have no other user-visible impact
on the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> object’s behavior; the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> will continue
to have the behavior that it remains usable for new operations after
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.close" title="sqlalchemy.orm.Session.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code></a> is called, and the sequencing of how the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> interacts with the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> and the database
itself should also remain unaffected, since these operations were already
operating in an on-demand fashion.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5074">#5074</a></p>
</section>
</section>
<section id="viewonly-relationships-don-t-synchronize-backrefs">
<span id="change-5237-14"></span><h3>Viewonly relationships don’t synchronize backrefs<a class="headerlink" href="#viewonly-relationships-don-t-synchronize-backrefs" title="Permalink to this headline">¶</a></h3>
<p>In <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5149">#5149</a> in 1.3.14, SQLAlchemy began emitting a warning when the
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.backref</span></code></a> or <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a>
keywords would be used at the same time as the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.viewonly</span></code></a>
flag on the target relationship.  This was because a “viewonly” relationship does
not actually persist changes made to it, which could cause some misleading
behaviors to occur.  However, in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5237">#5237</a>, we sought to refine this
behavior as there are legitimate use cases to have backrefs set up on
viewonly relationships, including that back populates attributes are used
in some cases by the relationship lazy loaders to determine that an additional
eager load in the other direction is not necessary, as well as that back
populates can be used for mapper introspection and that <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.backref" title="sqlalchemy.orm.backref"><code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code></a>
can be a convenient way to set up bi-directional relationships.</p>
<p>The solution then was to make the “mutation” that occurs from a backref
an optional thing, using the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.sync_backref</span></code></a>
flag.  In 1.4 the value of <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.sync_backref</span></code></a> defaults
to False for a relationship target that also sets <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.viewonly</span></code></a>.
This indicates that any changes made to a relationship with
viewonly will not impact the state of the other side or of the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>
in any way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="n">backref</span><span class="p">(</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="n">viewonly</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>


<span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">()</span>
<span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">u1</span></pre></div>
</div>
<p>Above, the <code class="docutils literal notranslate"><span class="pre">a1</span></code> object will <strong>not</strong> be added to the <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code>
collection, nor will the <code class="docutils literal notranslate"><span class="pre">a1</span></code> object be added to the session.  Previously,
both of these things would be true.   The warning that
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.sync_backref</span></code></a> should be set to <code class="docutils literal notranslate"><span class="pre">False</span></code> when
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.viewonly</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code> is no longer emitted as this is
now the default behavior.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5237">#5237</a></p>
</section>
<section id="cascade-backrefs-behavior-deprecated-for-removal-in-2-0">
<span id="change-5150"></span><h3>cascade_backrefs behavior deprecated for removal in 2.0<a class="headerlink" href="#cascade-backrefs-behavior-deprecated-for-removal-in-2-0" title="Permalink to this headline">¶</a></h3>
<p>SQLAlchemy has long had a behavior of cascading objects into the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> based on backref assignment.   Given <code class="docutils literal notranslate"><span class="pre">User</span></code> below
already in a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, assigning it to the <code class="docutils literal notranslate"><span class="pre">Address.user</span></code>
attribute of an <code class="docutils literal notranslate"><span class="pre">Address</span></code> object, assuming a bidirectional relationship
is set up, would mean that the <code class="docutils literal notranslate"><span class="pre">Address</span></code> also gets put into the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> at that point:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>

<span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">()</span>
<span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">u1</span>  <span class="c1"># &lt;--- adds &quot;a1&quot; to the Session</span></pre></div>
</div>
<p>The above behavior was an unintended side effect of backref behavior, in that
since <code class="docutils literal notranslate"><span class="pre">a1.user</span></code> implies <code class="docutils literal notranslate"><span class="pre">u1.addresses.append(a1)</span></code>, <code class="docutils literal notranslate"><span class="pre">a1</span></code> would get
cascaded into the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>.  This remains the default behavior
throughout 1.4.     At some point, a new flag <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade_backrefs</span></code></a>
was added to disable to above behavior, along with <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs" title="sqlalchemy.orm.backref"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">backref.cascade_backrefs</span></code></a>
to set this when the relationship is specified by <code class="docutils literal notranslate"><span class="pre">relationship.backref</span></code>, as it can be
surprising and also gets in the way of some operations where the object would be placed in
the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> too early and get prematurely flushed.</p>
<p>In 2.0, the default behavior will be that “cascade_backrefs” is False, and
additionally there will be no “True” behavior as this is not generally a desirable
behavior.    When 2.0 deprecation warnings are enabled, a warning will be emitted
when a “backref cascade” actually takes place.    To get the new behavior, either
set <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade_backrefs</span></code></a> and
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs" title="sqlalchemy.orm.backref"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">backref.cascade_backrefs</span></code></a> to <code class="docutils literal notranslate"><span class="pre">False</span></code> on any target
relationships, as is already supported in 1.3 and earlier, or alternatively make
use of the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.params.future" title="sqlalchemy.orm.Session"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.future</span></code></a> flag to <a class="reference internal" href="../glossary.html#term-1"><span class="xref std std-term">2.0-style</span></a> mode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">future</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
  <span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
  <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>

  <span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">()</span>
  <span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">u1</span>  <span class="c1"># &lt;--- will not add &quot;a1&quot; to the Session</span></pre></div>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5150">#5150</a></p>
</section>
<section id="eager-loaders-emit-during-unexpire-operations">
<span id="change-1763"></span><h3>Eager loaders emit during unexpire operations<a class="headerlink" href="#eager-loaders-emit-during-unexpire-operations" title="Permalink to this headline">¶</a></h3>
<p>A long sought behavior was that when an expired object is accessed, configured
eager loaders will run in order to eagerly load relationships on the expired
object when the object is refreshed or otherwise unexpired.   This behavior has
now been added, so that joinedloaders will add inline JOINs as usual, and
selectin/subquery loaders will run an “immediateload” operation for a given
relationship, when an expired object is unexpired or an object is refreshed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bs</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;new data&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>Above, the <code class="docutils literal notranslate"><span class="pre">A</span></code> object was loaded with a <code class="docutils literal notranslate"><span class="pre">joinedload()</span></code> option associated
with it in order to eagerly load the <code class="docutils literal notranslate"><span class="pre">bs</span></code> collection.    After the
<code class="docutils literal notranslate"><span class="pre">session.commit()</span></code>, the state of the object is expired.  Upon accessing
the <code class="docutils literal notranslate"><span class="pre">.data</span></code> column attribute, the object is refreshed and this will now
include the joinedload operation as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">data</span>
<span class="go">SELECT a.id AS a_id, a.data AS a_data, b_1.id AS b_1_id, b_1.a_id AS b_1_a_id</span>
<span class="go">FROM a LEFT OUTER JOIN b AS b_1 ON a.id = b_1.a_id</span>
<span class="go">WHERE a.id = ?</span></pre></div>
</div>
<p>The behavior applies both to loader strategies applied to the
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> directly, as well as with options used with
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query.options" title="sqlalchemy.orm.Query.options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.options()</span></code></a>, provided that the object was originally loaded by that
query.</p>
<p>For the “secondary” eager loaders “selectinload” and “subqueryload”, the SQL
strategy for these loaders is not necessary in order to eagerly load attributes
on a single object; so they will instead invoke the “immediateload” strategy in
a refresh scenario, which resembles the query emitted by “lazyload”, emitted as
an additional query:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bs</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;new data&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">data</span>
<span class="go">SELECT a.id AS a_id, a.data AS a_data</span>
<span class="go">FROM a</span>
<span class="go">WHERE a.id = ?</span>
<span class="go">(1,)</span>
<span class="go">SELECT b.id AS b_id, b.a_id AS b_a_id</span>
<span class="go">FROM b</span>
<span class="go">WHERE ? = b.a_id</span>
<span class="go">(1,)</span></pre></div>
</div>
<p>Note that a loader option does not apply to an object that was introduced
into the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> in a different way.  That is, if the <code class="docutils literal notranslate"><span class="pre">a1</span></code> object
were just persisted in this <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, or was loaded with a different
query before the eager option had been applied, then the object doesn’t have
an eager load option associated with it.  This is not a new concept, however
users who are looking for the eagerload on refresh behavior may find this
to be more noticeable.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/1763">#1763</a></p>
</section>
<section id="accessing-an-uninitialized-collection-attribute-on-a-transient-object-no-longer-mutates-dict">
<span id="change-4519"></span><h3>Accessing an uninitialized collection attribute on a transient object no longer mutates __dict__<a class="headerlink" href="#accessing-an-uninitialized-collection-attribute-on-a-transient-object-no-longer-mutates-dict" title="Permalink to this headline">¶</a></h3>
<p>It has always been SQLAlchemy’s behavior that accessing mapped attributes on a
newly created object returns an implicitly generated value, rather than raising
<code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>, such as <code class="docutils literal notranslate"><span class="pre">None</span></code> for scalar attributes or <code class="docutils literal notranslate"><span class="pre">[]</span></code> for a
list-holding relationship:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">name</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[]</span></pre></div>
</div>
<p>The rationale for the above behavior was originally to make ORM objects easier
to work with.  Since an ORM object represents an empty row when first created
without any state, it is intuitive that its un-accessed attributes would
resolve to <code class="docutils literal notranslate"><span class="pre">None</span></code> (or SQL NULL) for scalars and to empty collections for
relationships.   In particular, it makes possible an extremely common pattern
of being able to mutate the new collection without manually creating and
assigning an empty collection first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Address</span><span class="p">())</span>  <span class="c1"># no need to assign u1.addresses = []</span></pre></div>
</div>
<p>Up until version 1.0 of SQLAlchemy, the behavior of this initialization  system
for both scalar attributes as well as collections would be that the <code class="docutils literal notranslate"><span class="pre">None</span></code> or
empty collection would be <em>populated</em> into the object’s  state, e.g.
<code class="docutils literal notranslate"><span class="pre">__dict__</span></code>.  This meant that the following two operations were equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># explicit assignment</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># implicit assignment just by accessing it</span>
<span class="go">None</span></pre></div>
</div>
<p>Where above, both <code class="docutils literal notranslate"><span class="pre">u1</span></code> and <code class="docutils literal notranslate"><span class="pre">u2</span></code> would have the value <code class="docutils literal notranslate"><span class="pre">None</span></code> populated
in the value of the <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute.  Since this is a SQL NULL, the ORM
would skip including these values within an INSERT so that SQL-level defaults
take place, if any, else the value defaults to NULL on the database side.</p>
<p>In version 1.0 as part of <a class="reference internal" href="migration_10.html#migration-3061"><span class="std std-ref">Changes to attribute events and other operations regarding attributes that have no pre-existing value</span></a>, this behavior was refined so
that the <code class="docutils literal notranslate"><span class="pre">None</span></code> value was no longer populated into <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>, only
returned.   Besides removing the mutating side effect of a getter operation,
this change also made it possible to set columns that did have server defaults
to the value NULL by actually assigning <code class="docutils literal notranslate"><span class="pre">None</span></code>, which was now distinguished
from just reading it.</p>
<p>The change however did not accommodate for collections, where returning an
empty collection that is not assigned meant that this mutable collection would
be different each time and also would not be able to correctly accommodate for
mutating operations (e.g. append, add, etc.) called upon it.    While the
behavior continued to generally not get in anyone’s way, an edge case was
eventually identified in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4519">#4519</a> where this empty collection could be
harmful, which is when the object is merged into a session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># create an empty User to merge with id=1 in the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>  <span class="c1"># value of merged1.addresses is unchanged from that of the DB</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># create an empty User to merge with id=2 in the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged2</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">u2</span><span class="p">)</span>  <span class="c1"># value of merged2.addresses has been emptied in the DB</span></pre></div>
</div>
<p>Above, the <code class="docutils literal notranslate"><span class="pre">.addresses</span></code> collection on <code class="docutils literal notranslate"><span class="pre">merged1</span></code> will contain all the
<code class="docutils literal notranslate"><span class="pre">Address()</span></code> objects that were already in the database.   <code class="docutils literal notranslate"><span class="pre">merged2</span></code> will
not; because it has an empty list implicitly assigned, the <code class="docutils literal notranslate"><span class="pre">.addresses</span></code>
collection will be erased.   This is an example of where this mutating side
effect can actually mutate the database itself.</p>
<p>While it was considered that perhaps the attribute system should begin using
strict “plain Python” behavior, raising <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> in all cases for
non-existent attributes on non-persistent objects and requiring that  all
collections be explicitly assigned, such a change would likely be too extreme
for the vast number of applications that have relied upon this  behavior for
many years, leading to a complex rollout / backwards compatibility problem as
well as the likelihood that workarounds to restore the old behavior would
become prevalent, thus rendering the whole change ineffective in any case.</p>
<p>The change then is to keep the default producing behavior, but to finally make
the non-mutating behavior of scalars a reality for collections as well, via the
addition of additional mechanics in the collection system.  When accessing the
empty attribute, the new collection is created and associated with the state,
however is not added to <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> until it is actually mutated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l1</span> <span class="o">=</span> <span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>  <span class="c1"># new list is created, associated with the state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">u1</span><span class="o">.</span><span class="n">addresses</span> <span class="ow">is</span> <span class="n">l1</span>  <span class="c1"># you get the same list each time you access it</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s2">&quot;addresses&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">u1</span><span class="o">.</span><span class="vm">__dict__</span>  <span class="c1"># but it won&#39;t go into __dict__ until it&#39;s mutated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">history</span>
<span class="go">History(added=None, unchanged=None, deleted=None)</span></pre></div>
</div>
<p>When the list is changed, then it becomes part of the tracked changes to
be persisted to the database:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Address</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s2">&quot;addresses&quot;</span> <span class="ow">in</span> <span class="n">u1</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">history</span>
<span class="go">History(added=[&lt;__main__.Address object at 0x7f49b725eda0&gt;], unchanged=[], deleted=[])</span></pre></div>
</div>
<p>This change is expected to have <em>nearly</em> no impact on existing applications
in any way, except that it has been observed that some applications may be
relying upon the implicit assignment of this collection, such as to assert that
the object contains certain values based on its <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[]</span>
<span class="go"># this will now fail, would pass before</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u1</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)}</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;addresses&quot;</span><span class="p">:</span> <span class="p">[]}</span></pre></div>
</div>
<p>or to ensure that the collection won’t require a lazy load to proceed, the
(admittedly awkward) code below will now also fail:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>  <span class="c1"># &lt;-- will fail, .addresses is not loaded and object is detached</span></pre></div>
</div>
<p>Applications that rely upon the implicit mutating behavior of collections will
need to be changed so that they assign the desired collection explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span> <span class="o">=</span> <span class="p">[]</span></pre></div>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4519">#4519</a></p>
</section>
<section id="the-new-instance-conflicts-with-existing-identity-error-is-now-a-warning">
<span id="change-4662"></span><h3>The “New instance conflicts with existing identity” error is now a warning<a class="headerlink" href="#the-new-instance-conflicts-with-existing-identity-error-is-now-a-warning" title="Permalink to this headline">¶</a></h3>
<p>SQLAlchemy has always had logic to detect when an object in the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>
to be inserted has the same primary key as an object that is already present:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;product&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># add Product with primary key 1</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Product</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="c1"># add another Product with same primary key</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Product</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">s</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># &lt;-- will raise FlushError</span></pre></div>
</div>
<p>The change is that the <a class="reference internal" href="../orm/exceptions.html#sqlalchemy.orm.exc.FlushError" title="sqlalchemy.orm.exc.FlushError"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlushError</span></code></a> is altered to be only a warning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sqlalchemy/orm/persistence.py:408: SAWarning: New instance &lt;Product at 0x7f1ff65e0ba8&gt; with identity key (&lt;class &#39;__main__.Product&#39;&gt;, (1,), None) conflicts with persistent instance &lt;Product at 0x7f1ff60a4550&gt;</pre></div>
</div>
<p>Subsequent to that, the condition will attempt to insert the row into the
database which will emit <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.IntegrityError" title="sqlalchemy.exc.IntegrityError"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegrityError</span></code></a>, which is the same error that
would be raised if the primary key identity was not already present in the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">IntegrityError</span><span class="p">:</span> <span class="p">(</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">IntegrityError</span><span class="p">)</span> <span class="n">UNIQUE</span> <span class="n">constraint</span> <span class="n">failed</span><span class="p">:</span> <span class="n">product</span><span class="o">.</span><span class="n">id</span></pre></div>
</div>
<p>The rationale is to allow code that is using <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.IntegrityError" title="sqlalchemy.exc.IntegrityError"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegrityError</span></code></a> to catch
duplicates to function regardless of the existing state of the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, as is often done using savepoints:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># add another Product with same primary key</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">():</span>
        <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Product</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">IntegrityError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;row already exists&quot;</span><span class="p">)</span></pre></div>
</div>
<p>The above logic was not fully feasible earlier, as in the case that the
<code class="docutils literal notranslate"><span class="pre">Product</span></code> object with the existing identity were already in the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, the code would also have to catch <a class="reference internal" href="../orm/exceptions.html#sqlalchemy.orm.exc.FlushError" title="sqlalchemy.orm.exc.FlushError"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlushError</span></code></a>,
which additionally is not filtered for the specific condition of integrity
issues.   With the change, the above block behaves consistently with the
exception of the warning also being emitted.</p>
<p>Since the logic in question deals with the primary key, all databases emit an
integrity error in the case of primary key conflicts on INSERT.    The case
where an error would not be raised, that would have earlier, is the extremely
unusual scenario of a mapping that defines a primary key on the mapped
selectable that is more restrictive than what is actually configured in the
database schema, such as when mapping to joins of tables or when defining
additional columns as part of a composite primary key that is not actually
constrained in the database schema. However, these situations also work  more
consistently in that the INSERT would theoretically proceed whether or not the
existing identity were still in the database.  The warning can also be
configured to raise an exception using the Python warnings filter.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4662">#4662</a></p>
</section>
<section id="persistence-related-cascade-operations-disallowed-with-viewonly-true">
<span id="change-4994"></span><h3>Persistence-related cascade operations disallowed with viewonly=True<a class="headerlink" href="#persistence-related-cascade-operations-disallowed-with-viewonly-true" title="Permalink to this headline">¶</a></h3>
<p>When a <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> is set as <code class="docutils literal notranslate"><span class="pre">viewonly=True</span></code> using the
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.viewonly</span></code></a> flag, it indicates this relationship should
only be used to load data from the database, and should not be mutated
or involved in a persistence operation.   In order to ensure this contract
works successfully, the relationship can no longer specify
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade</span></code></a> settings that make no sense in terms of
“viewonly”.</p>
<p>The primary targets here are the “delete, delete-orphan”  cascades, which
through 1.3 continued to impact persistence even if viewonly were True, which
is a bug; even if viewonly were True, an object would still cascade these
two operations onto the related object if the parent were deleted or the
object were detached.   Rather than modify the cascade operations to check
for viewonly, the configuration of both of these together is simply
disallowed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="c1"># this is now an error</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">viewonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cascade</span><span class="o">=</span><span class="s2">&quot;all, delete-orphan&quot;</span><span class="p">)</span></pre></div>
</div>
<p>The above will raise:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">:</span> <span class="n">Cascade</span> <span class="n">settings</span>
<span class="s2">&quot;delete, delete-orphan, merge, save-update&quot;</span> <span class="n">apply</span> <span class="n">to</span> <span class="n">persistence</span>
<span class="n">operations</span> <span class="ow">and</span> <span class="n">should</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">combined</span> <span class="k">with</span> <span class="n">a</span> <span class="n">viewonly</span><span class="o">=</span><span class="kc">True</span> <span class="n">relationship</span><span class="o">.</span></pre></div>
</div>
<p>Applications that have this issue should be emitting a warning as of
SQLAlchemy 1.3.12, and for the above error the solution is to remove
the cascade settings for a viewonly relationship.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4993">#4993</a>
<a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4994">#4994</a></p>
</section>
<section id="stricter-behavior-when-querying-inheritance-mappings-using-custom-queries">
<span id="change-5122"></span><h3>Stricter behavior when querying inheritance mappings using custom queries<a class="headerlink" href="#stricter-behavior-when-querying-inheritance-mappings-using-custom-queries" title="Permalink to this headline">¶</a></h3>
<p>This change applies to the scenario where a joined- or single- table
inheritance subclass entity is being queried, given a completed SELECT subquery
to select from.   If the given subquery returns rows that do not correspond to
the requested polymorphic identity or identities, an error is raised.
Previously, this condition would pass silently under joined table inheritance,
returning an invalid subclass, and under single table inheritance, the
<a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> would be adding additional criteria against the subquery to
limit the results which could inappropriately interfere with the intent of the
query.</p>
<p>Given the example mapping of <code class="docutils literal notranslate"><span class="pre">Employee</span></code>, <code class="docutils literal notranslate"><span class="pre">Engineer(Employee)</span></code>, <code class="docutils literal notranslate"><span class="pre">Manager(Employee)</span></code>,
in the 1.3 series if we were to emit the following query against a joined
inheritance mapping:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">s</span><span class="o">.</span><span class="n">add_all</span><span class="p">([</span><span class="n">Engineer</span><span class="p">(),</span> <span class="n">Manager</span><span class="p">()])</span>

<span class="n">s</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Manager</span><span class="p">)</span><span class="o">.</span><span class="n">select_entity_from</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">subquery</span><span class="p">())</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="p">)</span></pre></div>
</div>
<p>The subquery selects both the <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> and the <code class="docutils literal notranslate"><span class="pre">Manager</span></code> rows, and
even though the outer query is against <code class="docutils literal notranslate"><span class="pre">Manager</span></code>, we get a non <code class="docutils literal notranslate"><span class="pre">Manager</span></code>
object back:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">type</span> <span class="n">AS</span> <span class="n">anon_1_type</span><span class="p">,</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="n">anon_1_id</span>
<span class="n">FROM</span> <span class="p">(</span><span class="n">SELECT</span> <span class="n">employee</span><span class="o">.</span><span class="n">type</span> <span class="n">AS</span> <span class="nb">type</span><span class="p">,</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="nb">id</span>
<span class="n">FROM</span> <span class="n">employee</span><span class="p">)</span> <span class="n">AS</span> <span class="n">anon_1</span>
<span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">29</span> <span class="mi">18</span><span class="p">:</span><span class="mi">04</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span><span class="mi">524</span> <span class="n">INFO</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Engine</span> <span class="p">()</span>
<span class="p">[</span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Engineer</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f7f5b9a9810</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Manager</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f7f5b9a9750</span><span class="o">&gt;</span><span class="p">]</span></pre></div>
</div>
<p>The new behavior is that this condition raises an error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sqlalchemy.exc.InvalidRequestError: Row with identity key
(&lt;class &#39;__main__.Employee&#39;&gt;, (1,), None) can&#39;t be loaded into an object;
the polymorphic discriminator column &#39;%(140205120401296 anon)s.type&#39;
refers to mapped class Engineer-&gt;engineer, which is not a sub-mapper of
the requested mapped class Manager-&gt;manager</pre></div>
</div>
<p>The above error only raises if the primary key columns of that entity are
non-NULL.  If there’s no primary key for a given entity in a row, no attempt
to construct an entity is made.</p>
<p>In the case of single inheritance mapping, the change in behavior is slightly
more involved;   if <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> and <code class="docutils literal notranslate"><span class="pre">Manager</span></code> above are mapped with
single table inheritance, in 1.3 the following query would be emitted and
only a <code class="docutils literal notranslate"><span class="pre">Manager</span></code> object is returned:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id
FROM (SELECT employee.type AS type, employee.id AS id
FROM employee) AS anon_1
WHERE anon_1.type IN (?)
2020-01-29 18:08:32,975 INFO sqlalchemy.engine.base.Engine (&#39;manager&#39;,)
[&lt;__main__.Manager object at 0x7ff1b0200d50&gt;]</pre></div>
</div>
<p>The <a class="reference internal" href="../orm/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> added the “single table inheritance” criteria to the
subquery, editorializing on the intent that was originally set up by it.
This behavior was added in version 1.0 in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/3891">#3891</a>, and creates a
behavioral inconsistency between “joined” and “single” table inheritance,
and additionally modifies the intent of the given query, which may intend
to return additional rows where the columns that correspond to the inheriting
entity are NULL, which is a valid use case.    The behavior is now equivalent
to that of joined table inheritance, where it is assumed that the subquery
returns the correct rows and an error is raised if an unexpected polymorphic
identity is encountered:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id
FROM (SELECT employee.type AS type, employee.id AS id
FROM employee) AS anon_1
2020-01-29 18:13:10,554 INFO sqlalchemy.engine.base.Engine ()
Traceback (most recent call last):
# ...
sqlalchemy.exc.InvalidRequestError: Row with identity key
(&lt;class &#39;__main__.Employee&#39;&gt;, (1,), None) can&#39;t be loaded into an object;
the polymorphic discriminator column &#39;%(140700085268432 anon)s.type&#39;
refers to mapped class Engineer-&gt;employee, which is not a sub-mapper of
the requested mapped class Manager-&gt;employee</pre></div>
</div>
<p>The correct adjustment to the situation as presented above which worked on 1.3
is to adjust the given subquery to correctly filter the rows based on the
discriminator column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>print(
    s.query(Manager).select_entity_from(
        s.query(Employee).filter(Employee.discriminator == &#39;manager&#39;).
        subquery()).all()
)

SELECT anon_1.type AS anon_1_type, anon_1.id AS anon_1_id
FROM (SELECT employee.type AS type, employee.id AS id
FROM employee
WHERE employee.type = ?) AS anon_1
2020-01-29 18:14:49,770 INFO sqlalchemy.engine.base.Engine (&#39;manager&#39;,)
[&lt;__main__.Manager object at 0x7f70e13fca90&gt;]</pre></div>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5122">#5122</a></p>
</section>
</section>
<section id="dialect-changes">
<h2>Dialect Changes<a class="headerlink" href="#dialect-changes" title="Permalink to this headline">¶</a></h2>
<section id="psycopg2-version-2-7-or-higher-is-required-for-the-postgresql-psycopg2-dialect">
<h3>psycopg2 version 2.7 or higher is required for the PostgreSQL psycopg2 dialect<a class="headerlink" href="#psycopg2-version-2-7-or-higher-is-required-for-the-postgresql-psycopg2-dialect" title="Permalink to this headline">¶</a></h3>
<p>The psycopg2 dialect relies upon many features of psycopg2 released
in the past few years.  To simplify the dialect, version 2.7, released
in March, 2017 is now the minimum version required.</p>
</section>
<section id="psycopg2-dialect-no-longer-has-limitations-regarding-bound-parameter-names">
<span id="change-5941"></span><h3>psycopg2 dialect no longer has limitations regarding bound parameter names<a class="headerlink" href="#psycopg2-dialect-no-longer-has-limitations-regarding-bound-parameter-names" title="Permalink to this headline">¶</a></h3>
<p>SQLAlchemy 1.3 was not able to accommodate bound parameter names that included
percent signs or parenthesis under the psycopg2 dialect. This in turn meant
that column names which included these characters were also problematic as
INSERT and other DML statements would generate parameter names that matched
that of the column, which would then cause failures. The workaround was to make
use of the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.key" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.key</span></code></a> parameter so that an alternate name
that would be used to generate the parameter, or otherwise the parameter style
of the dialect had to be changed at the <a class="reference internal" href="../core/engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> level. As of
SQLAlchemy 1.4.0beta3 all naming limitations have been removed and parameters
are fully escaped in all scenarios, so these workarounds are no longer
necessary.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5941">#5941</a></p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5653">#5653</a></p>
</section>
<section id="psycopg2-dialect-features-execute-values-with-returning-for-insert-statements-by-default">
<span id="change-5401"></span><h3>psycopg2 dialect features “execute_values” with RETURNING for INSERT statements by default<a class="headerlink" href="#psycopg2-dialect-features-execute-values-with-returning-for-insert-statements-by-default" title="Permalink to this headline">¶</a></h3>
<p>The first half of a significant performance enhancement for PostgreSQL when
using both Core and ORM, the psycopg2 dialect now uses
<code class="docutils literal notranslate"><span class="pre">psycopg2.extras.execute_values()</span></code> by default for compiled INSERT statements
and also implements RETURNING support in this mode.   The other half of this
change is <a class="reference internal" href="#change-5263"><span class="std std-ref">ORM Batch inserts with psycopg2 now batch statements with RETURNING in most cases</span></a> which allows the ORM to take advantage of
RETURNING with executemany (i.e. batching of INSERT statements) so that ORM
bulk inserts with psycopg2 are up to 400% faster depending on specifics.</p>
<p>This extension method allows many rows to be INSERTed within a single
statement, using an extended VALUES clause for the statement.  While
SQLAlchemy’s <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a> construct already supports this syntax via
the <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert.values" title="sqlalchemy.sql.expression.Insert.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.values()</span></code></a> method, the extension method allows the
construction of the VALUES clause to occur dynamically when the statement
is executed as an “executemany” execution, which is what occurs when one
passes a list of parameter dictionaries to <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a>.
It also occurs beyond the cache boundary so that the INSERT statement may
be cached before the VALUES are rendered.</p>
<p>A quick test of the <code class="docutils literal notranslate"><span class="pre">execute_values()</span></code> approach using the
<code class="docutils literal notranslate"><span class="pre">bulk_inserts.py</span></code> script in the <a class="reference internal" href="../orm/examples.html#examples-performance"><span class="std std-ref">Performance</span></a> example
suite reveals an approximate <strong>fivefold performance increase</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python -m examples.performance bulk_inserts --test test_core_insert --num 100000 --dburl postgresql://scott:tiger@localhost/test

# 1.3
test_core_insert : A single Core INSERT construct inserting mappings in bulk. (100000 iterations); total time 5.229326 sec

# 1.4
test_core_insert : A single Core INSERT construct inserting mappings in bulk. (100000 iterations); total time 0.944007 sec</pre></div>
</div>
<p>Support for the “batch” extension was added in version 1.2 in
<a class="reference internal" href="migration_12.html#change-4109"><span class="std std-ref">Support for Batch Mode / Fast Execution Helpers</span></a>, and enhanced to include support for the <code class="docutils literal notranslate"><span class="pre">execute_values</span></code>
extension in 1.3 in <a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4623">#4623</a>.  In 1.4 the <code class="docutils literal notranslate"><span class="pre">execute_values</span></code> extension is
now being turned on by default for INSERT statements; the “batch” extension
for UPDATE and DELETE remains off by default.</p>
<p>In addition, the <code class="docutils literal notranslate"><span class="pre">execute_values</span></code> extension function supports returning the
rows that are generated by RETURNING as an aggregated list.  The psycopg2
dialect will now retrieve this list if the given <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a> construct
requests returning via the <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert.returning" title="sqlalchemy.sql.expression.Insert.returning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.returning()</span></code></a> method or similar methods
intended to return generated defaults; the rows are then installed in the
result so that they are retrieved as though they came from the cursor
directly.   This allows tools like the ORM to use batched inserts in all cases,
which is expected to provide a dramatic performance improvement.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">executemany_mode</span></code> feature of the psycopg2 dialect has been revised
with the following changes:</p>
<ul class="simple">
<li><p>A new mode <code class="docutils literal notranslate"><span class="pre">&quot;values_only&quot;</span></code> is added.  This mode uses the very performant
<code class="docutils literal notranslate"><span class="pre">psycopg2.extras.execute_values()</span></code> extension method for compiled INSERT
statements run with executemany(), but does not use <code class="docutils literal notranslate"><span class="pre">execute_batch()</span></code> for
UPDATE and DELETE statements.  This new mode is now the default setting for
the psycopg2 dialect.</p></li>
<li><p>The existing <code class="docutils literal notranslate"><span class="pre">&quot;values&quot;</span></code> mode is now named <code class="docutils literal notranslate"><span class="pre">&quot;values_plus_batch&quot;</span></code>.  This mode
will use <code class="docutils literal notranslate"><span class="pre">execute_values</span></code> for INSERT statements and <code class="docutils literal notranslate"><span class="pre">execute_batch</span></code>
for UPDATE and DELETE statements.  The mode is not enabled by default
because it disables the proper functioning of <code class="docutils literal notranslate"><span class="pre">cursor.rowcount</span></code> with
UPDATE and DELETE statements executed with <code class="docutils literal notranslate"><span class="pre">executemany()</span></code>.</p></li>
<li><p>RETURNING support is enabled for <code class="docutils literal notranslate"><span class="pre">&quot;values_only&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;values&quot;</span></code> for
INSERT statements.  The psycopg2 dialect will receive the rows back
from psycopg2 using the fetch=True flag and install them into the result
set as though they came directly from the cursor (which they ultimately did,
however psycopg2’s extension function has aggregated multiple batches into
one list).</p></li>
<li><p>The default “page_size” setting for <code class="docutils literal notranslate"><span class="pre">execute_values</span></code> has been increased
from 100 to 1000.   The default remains at 100 for the <code class="docutils literal notranslate"><span class="pre">execute_batch</span></code>
function.  These parameters may both be modified as was the case before.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">use_batch_mode</span></code> flag that was part of the 1.2 version of the feature
is removed; the behavior remains controllable via the <code class="docutils literal notranslate"><span class="pre">executemany_mode</span></code>
flag added in 1.3.</p></li>
<li><p>The Core engine and dialect has been enhanced to support executemany
plus returning mode, currently only available with psycopg2, by providing
new <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key_rows" title="sqlalchemy.engine.CursorResult.inserted_primary_key_rows"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CursorResult.inserted_primary_key_rows</span></code></a> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">CursorResult.returned_default_rows</span></code> accessors.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/postgresql.html#psycopg2-executemany-mode"><span class="std std-ref">Psycopg2 Fast Execution Helpers</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/5401">#5401</a></p>
</section>
<section id="removed-join-rewriting-logic-from-sqlite-dialect-updated-imports">
<span id="change-4895"></span><h3>Removed “join rewriting” logic from SQLite dialect; updated imports<a class="headerlink" href="#removed-join-rewriting-logic-from-sqlite-dialect-updated-imports" title="Permalink to this headline">¶</a></h3>
<p>Dropped support for right-nested join rewriting to support old SQLite
versions prior to 3.7.16, released in 2013.   It is not expected that
any modern Python versions rely upon this limitation.</p>
<p>The behavior was first introduced in 0.9 and was part of the larger change of
allowing for right nested joins as described at <a class="reference internal" href="migration_09.html#feature-joins-09"><span class="std std-ref">Many JOIN and LEFT OUTER JOIN expressions will no longer be wrapped in (SELECT * FROM ..) AS ANON_1</span></a>.
However the SQLite workaround produced many regressions in the 2013-2014
period due to its complexity. In 2016, the dialect was modified so that the
join rewriting logic would only occur for SQLite versions prior to 3.7.16 after
bisection was used to  identify where SQLite fixed its support for this
construct, and no further issues were reported against the behavior (even
though some bugs were found internally).    It is now anticipated that there
are little to no Python builds for Python 2.7 or 3.5 and above (the supported
Python versions) which would include a SQLite version prior to 3.7.17, and
the behavior is only necessary only in more complex ORM joining scenarios.
A warning is now emitted if the installed SQLite version is older than
3.7.16.</p>
<p>In related changes, the module imports for SQLite no longer attempt to
import the “pysqlite2” driver on Python 3 as this driver does not exist
on Python 3; a very old warning for old pysqlite2 versions is also dropped.</p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4895">#4895</a></p>
</section>
<section id="added-sequence-support-for-mariadb-10-3">
<span id="change-4976"></span><h3>Added Sequence support for MariaDB 10.3<a class="headerlink" href="#added-sequence-support-for-mariadb-10-3" title="Permalink to this headline">¶</a></h3>
<p>The MariaDB database as of 10.3 supports sequences.   SQLAlchemy’s MySQL
dialect now implements support for the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> object against this
database, meaning “CREATE SEQUENCE” DDL will be emitted for a
<a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> that is present in a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> or <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
collection in the same way as it works for backends such as PostgreSQL, Oracle,
when the dialect’s server version check has confirmed the database is MariaDB
10.3 or greater.    Additionally, the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> will act as a
column default and primary key generation object when used in these ways.</p>
<p>Since this change will impact the assumptions both for DDL as well as the
behavior of INSERT statements for an application that is currently deployed
against MariaDB 10.3 which also happens to make explicit use the
<a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> construct within its table definitions, it is important to
note that <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> supports a flag <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence.params.optional" title="sqlalchemy.schema.Sequence"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Sequence.optional</span></code></a>
which is used to limit the scenarios in which the <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> to take
effect. When “optional” is used on a <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> that is present in the
integer primary key column of a table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;some_table&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">(</span><span class="s2">&quot;some_seq&quot;</span><span class="p">,</span> <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>The above <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> is only used for DDL and INSERT statements if the
target database does not support any other means of generating integer primary
key values for the column.  That is, the Oracle database above would use the
sequence, however the PostgreSQL and MariaDB 10.3 databases would not. This may
be important for an existing application that is upgrading to SQLAlchemy 1.4
which may not have emitted DDL for this <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> against its backing
database, as an INSERT statement will fail if it seeks to use a sequence that
was not created.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/defaults.html#defaults-sequences"><span class="std std-ref">Defining Sequences</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4976">#4976</a></p>
</section>
<section id="added-sequence-support-distinct-from-identity-to-sql-server">
<span id="change-4235"></span><h3>Added Sequence support distinct from IDENTITY to SQL Server<a class="headerlink" href="#added-sequence-support-distinct-from-identity-to-sql-server" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> construct is now fully functional with Microsoft
SQL Server.  When applied to a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>, the DDL for the table will
no longer include IDENTITY keywords and instead will rely upon “CREATE SEQUENCE”
to ensure a sequence is present which will then be used for INSERT statements
on the table.</p>
<p>The <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.Sequence" title="sqlalchemy.schema.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> prior to version 1.3 was used to control parameters for
the IDENTITY column in SQL Server; this usage emitted deprecation warnings
throughout 1.3 and is now removed in 1.4.  For control of parameters for an
IDENTITY column, the <code class="docutils literal notranslate"><span class="pre">mssql_identity_start</span></code> and <code class="docutils literal notranslate"><span class="pre">mssql_identity_increment</span></code>
parameters should be used; see the MSSQL dialect documentation linked below.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/mssql.html#mssql-identity"><span class="std std-ref">Auto Increment Behavior / IDENTITY Columns</span></a></p>
</div>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4235">#4235</a></p>
<p><a class="reference external" href="https://www.sqlalchemy.org/trac/ticket/4633">#4633</a></p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="index.html" title="previous chapter">Changes and Migration</a>
        Next:
        <a href="migration_20.html" title="next chapter">Migrating to SQLAlchemy 2.0</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2021, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 4.1.2.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.4.23',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


